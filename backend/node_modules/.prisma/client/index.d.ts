
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Projeto
 * 
 */
export type Projeto = $Result.DefaultSelection<Prisma.$ProjetoPayload>
/**
 * Model Analyst
 * 
 */
export type Analyst = $Result.DefaultSelection<Prisma.$AnalystPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model DecisionLog
 * 
 */
export type DecisionLog = $Result.DefaultSelection<Prisma.$DecisionLogPayload>
/**
 * Model LogProjeto
 * 
 */
export type LogProjeto = $Result.DefaultSelection<Prisma.$LogProjetoPayload>
/**
 * Model Deployment
 * 
 */
export type Deployment = $Result.DefaultSelection<Prisma.$DeploymentPayload>
/**
 * Model Levantamento
 * 
 */
export type Levantamento = $Result.DefaultSelection<Prisma.$LevantamentoPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model EmailConfig
 * 
 */
export type EmailConfig = $Result.DefaultSelection<Prisma.$EmailConfigPayload>
/**
 * Model SharePointSite
 * 
 */
export type SharePointSite = $Result.DefaultSelection<Prisma.$SharePointSitePayload>
/**
 * Model TeamsConfig
 * 
 */
export type TeamsConfig = $Result.DefaultSelection<Prisma.$TeamsConfigPayload>
/**
 * Model CronogramaItem
 * 
 */
export type CronogramaItem = $Result.DefaultSelection<Prisma.$CronogramaItemPayload>
/**
 * Model Licenciamento
 * 
 */
export type Licenciamento = $Result.DefaultSelection<Prisma.$LicenciamentoPayload>
/**
 * Model Orientacao
 * 
 */
export type Orientacao = $Result.DefaultSelection<Prisma.$OrientacaoPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Projetos
 * const projetos = await prisma.projeto.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Projetos
   * const projetos = await prisma.projeto.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.projeto`: Exposes CRUD operations for the **Projeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projetos
    * const projetos = await prisma.projeto.findMany()
    * ```
    */
  get projeto(): Prisma.ProjetoDelegate<ExtArgs>;

  /**
   * `prisma.analyst`: Exposes CRUD operations for the **Analyst** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analysts
    * const analysts = await prisma.analyst.findMany()
    * ```
    */
  get analyst(): Prisma.AnalystDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.decisionLog`: Exposes CRUD operations for the **DecisionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DecisionLogs
    * const decisionLogs = await prisma.decisionLog.findMany()
    * ```
    */
  get decisionLog(): Prisma.DecisionLogDelegate<ExtArgs>;

  /**
   * `prisma.logProjeto`: Exposes CRUD operations for the **LogProjeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogProjetos
    * const logProjetos = await prisma.logProjeto.findMany()
    * ```
    */
  get logProjeto(): Prisma.LogProjetoDelegate<ExtArgs>;

  /**
   * `prisma.deployment`: Exposes CRUD operations for the **Deployment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deployments
    * const deployments = await prisma.deployment.findMany()
    * ```
    */
  get deployment(): Prisma.DeploymentDelegate<ExtArgs>;

  /**
   * `prisma.levantamento`: Exposes CRUD operations for the **Levantamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levantamentos
    * const levantamentos = await prisma.levantamento.findMany()
    * ```
    */
  get levantamento(): Prisma.LevantamentoDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.emailConfig`: Exposes CRUD operations for the **EmailConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailConfigs
    * const emailConfigs = await prisma.emailConfig.findMany()
    * ```
    */
  get emailConfig(): Prisma.EmailConfigDelegate<ExtArgs>;

  /**
   * `prisma.sharePointSite`: Exposes CRUD operations for the **SharePointSite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharePointSites
    * const sharePointSites = await prisma.sharePointSite.findMany()
    * ```
    */
  get sharePointSite(): Prisma.SharePointSiteDelegate<ExtArgs>;

  /**
   * `prisma.teamsConfig`: Exposes CRUD operations for the **TeamsConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamsConfigs
    * const teamsConfigs = await prisma.teamsConfig.findMany()
    * ```
    */
  get teamsConfig(): Prisma.TeamsConfigDelegate<ExtArgs>;

  /**
   * `prisma.cronogramaItem`: Exposes CRUD operations for the **CronogramaItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CronogramaItems
    * const cronogramaItems = await prisma.cronogramaItem.findMany()
    * ```
    */
  get cronogramaItem(): Prisma.CronogramaItemDelegate<ExtArgs>;

  /**
   * `prisma.licenciamento`: Exposes CRUD operations for the **Licenciamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenciamentos
    * const licenciamentos = await prisma.licenciamento.findMany()
    * ```
    */
  get licenciamento(): Prisma.LicenciamentoDelegate<ExtArgs>;

  /**
   * `prisma.orientacao`: Exposes CRUD operations for the **Orientacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orientacaos
    * const orientacaos = await prisma.orientacao.findMany()
    * ```
    */
  get orientacao(): Prisma.OrientacaoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Projeto: 'Projeto',
    Analyst: 'Analyst',
    Client: 'Client',
    DecisionLog: 'DecisionLog',
    LogProjeto: 'LogProjeto',
    Deployment: 'Deployment',
    Levantamento: 'Levantamento',
    Usuario: 'Usuario',
    EmailConfig: 'EmailConfig',
    SharePointSite: 'SharePointSite',
    TeamsConfig: 'TeamsConfig',
    CronogramaItem: 'CronogramaItem',
    Licenciamento: 'Licenciamento',
    Orientacao: 'Orientacao'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "projeto" | "analyst" | "client" | "decisionLog" | "logProjeto" | "deployment" | "levantamento" | "usuario" | "emailConfig" | "sharePointSite" | "teamsConfig" | "cronogramaItem" | "licenciamento" | "orientacao"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Projeto: {
        payload: Prisma.$ProjetoPayload<ExtArgs>
        fields: Prisma.ProjetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>
          }
          findFirst: {
            args: Prisma.ProjetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>
          }
          findMany: {
            args: Prisma.ProjetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>[]
          }
          create: {
            args: Prisma.ProjetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>
          }
          createMany: {
            args: Prisma.ProjetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjetoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>[]
          }
          delete: {
            args: Prisma.ProjetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>
          }
          update: {
            args: Prisma.ProjetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>
          }
          deleteMany: {
            args: Prisma.ProjetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjetoPayload>
          }
          aggregate: {
            args: Prisma.ProjetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjeto>
          }
          groupBy: {
            args: Prisma.ProjetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjetoCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetoCountAggregateOutputType> | number
          }
        }
      }
      Analyst: {
        payload: Prisma.$AnalystPayload<ExtArgs>
        fields: Prisma.AnalystFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalystFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalystFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>
          }
          findFirst: {
            args: Prisma.AnalystFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalystFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>
          }
          findMany: {
            args: Prisma.AnalystFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>[]
          }
          create: {
            args: Prisma.AnalystCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>
          }
          createMany: {
            args: Prisma.AnalystCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalystCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>[]
          }
          delete: {
            args: Prisma.AnalystDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>
          }
          update: {
            args: Prisma.AnalystUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>
          }
          deleteMany: {
            args: Prisma.AnalystDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalystUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalystUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalystPayload>
          }
          aggregate: {
            args: Prisma.AnalystAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyst>
          }
          groupBy: {
            args: Prisma.AnalystGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalystGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalystCountArgs<ExtArgs>
            result: $Utils.Optional<AnalystCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      DecisionLog: {
        payload: Prisma.$DecisionLogPayload<ExtArgs>
        fields: Prisma.DecisionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecisionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecisionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          findFirst: {
            args: Prisma.DecisionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecisionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          findMany: {
            args: Prisma.DecisionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>[]
          }
          create: {
            args: Prisma.DecisionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          createMany: {
            args: Prisma.DecisionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecisionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>[]
          }
          delete: {
            args: Prisma.DecisionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          update: {
            args: Prisma.DecisionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          deleteMany: {
            args: Prisma.DecisionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecisionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DecisionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionLogPayload>
          }
          aggregate: {
            args: Prisma.DecisionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecisionLog>
          }
          groupBy: {
            args: Prisma.DecisionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecisionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecisionLogCountArgs<ExtArgs>
            result: $Utils.Optional<DecisionLogCountAggregateOutputType> | number
          }
        }
      }
      LogProjeto: {
        payload: Prisma.$LogProjetoPayload<ExtArgs>
        fields: Prisma.LogProjetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogProjetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogProjetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>
          }
          findFirst: {
            args: Prisma.LogProjetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogProjetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>
          }
          findMany: {
            args: Prisma.LogProjetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>[]
          }
          create: {
            args: Prisma.LogProjetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>
          }
          createMany: {
            args: Prisma.LogProjetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogProjetoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>[]
          }
          delete: {
            args: Prisma.LogProjetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>
          }
          update: {
            args: Prisma.LogProjetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>
          }
          deleteMany: {
            args: Prisma.LogProjetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogProjetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogProjetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogProjetoPayload>
          }
          aggregate: {
            args: Prisma.LogProjetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogProjeto>
          }
          groupBy: {
            args: Prisma.LogProjetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogProjetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogProjetoCountArgs<ExtArgs>
            result: $Utils.Optional<LogProjetoCountAggregateOutputType> | number
          }
        }
      }
      Deployment: {
        payload: Prisma.$DeploymentPayload<ExtArgs>
        fields: Prisma.DeploymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          findFirst: {
            args: Prisma.DeploymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          findMany: {
            args: Prisma.DeploymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>[]
          }
          create: {
            args: Prisma.DeploymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          createMany: {
            args: Prisma.DeploymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>[]
          }
          delete: {
            args: Prisma.DeploymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          update: {
            args: Prisma.DeploymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          aggregate: {
            args: Prisma.DeploymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeployment>
          }
          groupBy: {
            args: Prisma.DeploymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentCountAggregateOutputType> | number
          }
        }
      }
      Levantamento: {
        payload: Prisma.$LevantamentoPayload<ExtArgs>
        fields: Prisma.LevantamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevantamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevantamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>
          }
          findFirst: {
            args: Prisma.LevantamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevantamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>
          }
          findMany: {
            args: Prisma.LevantamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>[]
          }
          create: {
            args: Prisma.LevantamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>
          }
          createMany: {
            args: Prisma.LevantamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevantamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>[]
          }
          delete: {
            args: Prisma.LevantamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>
          }
          update: {
            args: Prisma.LevantamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>
          }
          deleteMany: {
            args: Prisma.LevantamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevantamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevantamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevantamentoPayload>
          }
          aggregate: {
            args: Prisma.LevantamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevantamento>
          }
          groupBy: {
            args: Prisma.LevantamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevantamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevantamentoCountArgs<ExtArgs>
            result: $Utils.Optional<LevantamentoCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      EmailConfig: {
        payload: Prisma.$EmailConfigPayload<ExtArgs>
        fields: Prisma.EmailConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>
          }
          findFirst: {
            args: Prisma.EmailConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>
          }
          findMany: {
            args: Prisma.EmailConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>[]
          }
          create: {
            args: Prisma.EmailConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>
          }
          createMany: {
            args: Prisma.EmailConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>[]
          }
          delete: {
            args: Prisma.EmailConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>
          }
          update: {
            args: Prisma.EmailConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>
          }
          deleteMany: {
            args: Prisma.EmailConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigPayload>
          }
          aggregate: {
            args: Prisma.EmailConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailConfig>
          }
          groupBy: {
            args: Prisma.EmailConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailConfigCountArgs<ExtArgs>
            result: $Utils.Optional<EmailConfigCountAggregateOutputType> | number
          }
        }
      }
      SharePointSite: {
        payload: Prisma.$SharePointSitePayload<ExtArgs>
        fields: Prisma.SharePointSiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharePointSiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharePointSiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>
          }
          findFirst: {
            args: Prisma.SharePointSiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharePointSiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>
          }
          findMany: {
            args: Prisma.SharePointSiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>[]
          }
          create: {
            args: Prisma.SharePointSiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>
          }
          createMany: {
            args: Prisma.SharePointSiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharePointSiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>[]
          }
          delete: {
            args: Prisma.SharePointSiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>
          }
          update: {
            args: Prisma.SharePointSiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>
          }
          deleteMany: {
            args: Prisma.SharePointSiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharePointSiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SharePointSiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePointSitePayload>
          }
          aggregate: {
            args: Prisma.SharePointSiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharePointSite>
          }
          groupBy: {
            args: Prisma.SharePointSiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharePointSiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharePointSiteCountArgs<ExtArgs>
            result: $Utils.Optional<SharePointSiteCountAggregateOutputType> | number
          }
        }
      }
      TeamsConfig: {
        payload: Prisma.$TeamsConfigPayload<ExtArgs>
        fields: Prisma.TeamsConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamsConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamsConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>
          }
          findFirst: {
            args: Prisma.TeamsConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamsConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>
          }
          findMany: {
            args: Prisma.TeamsConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>[]
          }
          create: {
            args: Prisma.TeamsConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>
          }
          createMany: {
            args: Prisma.TeamsConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamsConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>[]
          }
          delete: {
            args: Prisma.TeamsConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>
          }
          update: {
            args: Prisma.TeamsConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>
          }
          deleteMany: {
            args: Prisma.TeamsConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamsConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamsConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsConfigPayload>
          }
          aggregate: {
            args: Prisma.TeamsConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamsConfig>
          }
          groupBy: {
            args: Prisma.TeamsConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamsConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamsConfigCountArgs<ExtArgs>
            result: $Utils.Optional<TeamsConfigCountAggregateOutputType> | number
          }
        }
      }
      CronogramaItem: {
        payload: Prisma.$CronogramaItemPayload<ExtArgs>
        fields: Prisma.CronogramaItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CronogramaItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CronogramaItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>
          }
          findFirst: {
            args: Prisma.CronogramaItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CronogramaItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>
          }
          findMany: {
            args: Prisma.CronogramaItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>[]
          }
          create: {
            args: Prisma.CronogramaItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>
          }
          createMany: {
            args: Prisma.CronogramaItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CronogramaItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>[]
          }
          delete: {
            args: Prisma.CronogramaItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>
          }
          update: {
            args: Prisma.CronogramaItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>
          }
          deleteMany: {
            args: Prisma.CronogramaItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CronogramaItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CronogramaItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CronogramaItemPayload>
          }
          aggregate: {
            args: Prisma.CronogramaItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCronogramaItem>
          }
          groupBy: {
            args: Prisma.CronogramaItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CronogramaItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CronogramaItemCountArgs<ExtArgs>
            result: $Utils.Optional<CronogramaItemCountAggregateOutputType> | number
          }
        }
      }
      Licenciamento: {
        payload: Prisma.$LicenciamentoPayload<ExtArgs>
        fields: Prisma.LicenciamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenciamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenciamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>
          }
          findFirst: {
            args: Prisma.LicenciamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenciamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>
          }
          findMany: {
            args: Prisma.LicenciamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>[]
          }
          create: {
            args: Prisma.LicenciamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>
          }
          createMany: {
            args: Prisma.LicenciamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenciamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>[]
          }
          delete: {
            args: Prisma.LicenciamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>
          }
          update: {
            args: Prisma.LicenciamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>
          }
          deleteMany: {
            args: Prisma.LicenciamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenciamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LicenciamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicenciamentoPayload>
          }
          aggregate: {
            args: Prisma.LicenciamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicenciamento>
          }
          groupBy: {
            args: Prisma.LicenciamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenciamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenciamentoCountArgs<ExtArgs>
            result: $Utils.Optional<LicenciamentoCountAggregateOutputType> | number
          }
        }
      }
      Orientacao: {
        payload: Prisma.$OrientacaoPayload<ExtArgs>
        fields: Prisma.OrientacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrientacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrientacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>
          }
          findFirst: {
            args: Prisma.OrientacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrientacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>
          }
          findMany: {
            args: Prisma.OrientacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>[]
          }
          create: {
            args: Prisma.OrientacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>
          }
          createMany: {
            args: Prisma.OrientacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrientacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>[]
          }
          delete: {
            args: Prisma.OrientacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>
          }
          update: {
            args: Prisma.OrientacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>
          }
          deleteMany: {
            args: Prisma.OrientacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrientacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrientacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrientacaoPayload>
          }
          aggregate: {
            args: Prisma.OrientacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrientacao>
          }
          groupBy: {
            args: Prisma.OrientacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrientacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrientacaoCountArgs<ExtArgs>
            result: $Utils.Optional<OrientacaoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProjetoCountOutputType
   */

  export type ProjetoCountOutputType = {
    levantamento: number
    usuarios: number
    sharepoint: number
    cronograma: number
    logs: number
  }

  export type ProjetoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    levantamento?: boolean | ProjetoCountOutputTypeCountLevantamentoArgs
    usuarios?: boolean | ProjetoCountOutputTypeCountUsuariosArgs
    sharepoint?: boolean | ProjetoCountOutputTypeCountSharepointArgs
    cronograma?: boolean | ProjetoCountOutputTypeCountCronogramaArgs
    logs?: boolean | ProjetoCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjetoCountOutputType
     */
    select?: ProjetoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountLevantamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevantamentoWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountSharepointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharePointSiteWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountCronogramaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CronogramaItemWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogProjetoWhereInput
  }


  /**
   * Count Type AnalystCountOutputType
   */

  export type AnalystCountOutputType = {
    logs: number
  }

  export type AnalystCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | AnalystCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * AnalystCountOutputType without action
   */
  export type AnalystCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalystCountOutputType
     */
    select?: AnalystCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnalystCountOutputType without action
   */
  export type AnalystCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    projetos: number
    deployments: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetos?: boolean | ClientCountOutputTypeCountProjetosArgs
    deployments?: boolean | ClientCountOutputTypeCountDeploymentsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProjetosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjetoWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
  }


  /**
   * Count Type DeploymentCountOutputType
   */

  export type DeploymentCountOutputType = {
    decisions: number
  }

  export type DeploymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decisions?: boolean | DeploymentCountOutputTypeCountDecisionsArgs
  }

  // Custom InputTypes
  /**
   * DeploymentCountOutputType without action
   */
  export type DeploymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentCountOutputType
     */
    select?: DeploymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeploymentCountOutputType without action
   */
  export type DeploymentCountOutputTypeCountDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Projeto
   */

  export type AggregateProjeto = {
    _count: ProjetoCountAggregateOutputType | null
    _avg: ProjetoAvgAggregateOutputType | null
    _sum: ProjetoSumAggregateOutputType | null
    _min: ProjetoMinAggregateOutputType | null
    _max: ProjetoMaxAggregateOutputType | null
  }

  export type ProjetoAvgAggregateOutputType = {
    progresso: number | null
  }

  export type ProjetoSumAggregateOutputType = {
    progresso: number | null
  }

  export type ProjetoMinAggregateOutputType = {
    id: string | null
    nome: string | null
    clienteId: string | null
    descricao: string | null
    status: string | null
    progresso: number | null
    dataCriacao: Date | null
    dataAtualizacao: Date | null
  }

  export type ProjetoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    clienteId: string | null
    descricao: string | null
    status: string | null
    progresso: number | null
    dataCriacao: Date | null
    dataAtualizacao: Date | null
  }

  export type ProjetoCountAggregateOutputType = {
    id: number
    nome: number
    clienteId: number
    descricao: number
    status: number
    progresso: number
    dataCriacao: number
    dataAtualizacao: number
    _all: number
  }


  export type ProjetoAvgAggregateInputType = {
    progresso?: true
  }

  export type ProjetoSumAggregateInputType = {
    progresso?: true
  }

  export type ProjetoMinAggregateInputType = {
    id?: true
    nome?: true
    clienteId?: true
    descricao?: true
    status?: true
    progresso?: true
    dataCriacao?: true
    dataAtualizacao?: true
  }

  export type ProjetoMaxAggregateInputType = {
    id?: true
    nome?: true
    clienteId?: true
    descricao?: true
    status?: true
    progresso?: true
    dataCriacao?: true
    dataAtualizacao?: true
  }

  export type ProjetoCountAggregateInputType = {
    id?: true
    nome?: true
    clienteId?: true
    descricao?: true
    status?: true
    progresso?: true
    dataCriacao?: true
    dataAtualizacao?: true
    _all?: true
  }

  export type ProjetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projeto to aggregate.
     */
    where?: ProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projetos to fetch.
     */
    orderBy?: ProjetoOrderByWithRelationInput | ProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projetos
    **/
    _count?: true | ProjetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetoMaxAggregateInputType
  }

  export type GetProjetoAggregateType<T extends ProjetoAggregateArgs> = {
        [P in keyof T & keyof AggregateProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjeto[P]>
      : GetScalarType<T[P], AggregateProjeto[P]>
  }




  export type ProjetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjetoWhereInput
    orderBy?: ProjetoOrderByWithAggregationInput | ProjetoOrderByWithAggregationInput[]
    by: ProjetoScalarFieldEnum[] | ProjetoScalarFieldEnum
    having?: ProjetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetoCountAggregateInputType | true
    _avg?: ProjetoAvgAggregateInputType
    _sum?: ProjetoSumAggregateInputType
    _min?: ProjetoMinAggregateInputType
    _max?: ProjetoMaxAggregateInputType
  }

  export type ProjetoGroupByOutputType = {
    id: string
    nome: string
    clienteId: string
    descricao: string | null
    status: string
    progresso: number
    dataCriacao: Date
    dataAtualizacao: Date
    _count: ProjetoCountAggregateOutputType | null
    _avg: ProjetoAvgAggregateOutputType | null
    _sum: ProjetoSumAggregateOutputType | null
    _min: ProjetoMinAggregateOutputType | null
    _max: ProjetoMaxAggregateOutputType | null
  }

  type GetProjetoGroupByPayload<T extends ProjetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
        }
      >
    >


  export type ProjetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    clienteId?: boolean
    descricao?: boolean
    status?: boolean
    progresso?: boolean
    dataCriacao?: boolean
    dataAtualizacao?: boolean
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
    levantamento?: boolean | Projeto$levantamentoArgs<ExtArgs>
    usuarios?: boolean | Projeto$usuariosArgs<ExtArgs>
    emailConfig?: boolean | Projeto$emailConfigArgs<ExtArgs>
    sharepoint?: boolean | Projeto$sharepointArgs<ExtArgs>
    teams?: boolean | Projeto$teamsArgs<ExtArgs>
    cronograma?: boolean | Projeto$cronogramaArgs<ExtArgs>
    licenciamento?: boolean | Projeto$licenciamentoArgs<ExtArgs>
    orientacoes?: boolean | Projeto$orientacoesArgs<ExtArgs>
    logs?: boolean | Projeto$logsArgs<ExtArgs>
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projeto"]>

  export type ProjetoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    clienteId?: boolean
    descricao?: boolean
    status?: boolean
    progresso?: boolean
    dataCriacao?: boolean
    dataAtualizacao?: boolean
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projeto"]>

  export type ProjetoSelectScalar = {
    id?: boolean
    nome?: boolean
    clienteId?: boolean
    descricao?: boolean
    status?: boolean
    progresso?: boolean
    dataCriacao?: boolean
    dataAtualizacao?: boolean
  }

  export type ProjetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
    levantamento?: boolean | Projeto$levantamentoArgs<ExtArgs>
    usuarios?: boolean | Projeto$usuariosArgs<ExtArgs>
    emailConfig?: boolean | Projeto$emailConfigArgs<ExtArgs>
    sharepoint?: boolean | Projeto$sharepointArgs<ExtArgs>
    teams?: boolean | Projeto$teamsArgs<ExtArgs>
    cronograma?: boolean | Projeto$cronogramaArgs<ExtArgs>
    licenciamento?: boolean | Projeto$licenciamentoArgs<ExtArgs>
    orientacoes?: boolean | Projeto$orientacoesArgs<ExtArgs>
    logs?: boolean | Projeto$logsArgs<ExtArgs>
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjetoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ProjetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Projeto"
    objects: {
      cliente: Prisma.$ClientPayload<ExtArgs>
      levantamento: Prisma.$LevantamentoPayload<ExtArgs>[]
      usuarios: Prisma.$UsuarioPayload<ExtArgs>[]
      emailConfig: Prisma.$EmailConfigPayload<ExtArgs> | null
      sharepoint: Prisma.$SharePointSitePayload<ExtArgs>[]
      teams: Prisma.$TeamsConfigPayload<ExtArgs> | null
      cronograma: Prisma.$CronogramaItemPayload<ExtArgs>[]
      licenciamento: Prisma.$LicenciamentoPayload<ExtArgs> | null
      orientacoes: Prisma.$OrientacaoPayload<ExtArgs> | null
      logs: Prisma.$LogProjetoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      clienteId: string
      descricao: string | null
      status: string
      progresso: number
      dataCriacao: Date
      dataAtualizacao: Date
    }, ExtArgs["result"]["projeto"]>
    composites: {}
  }

  type ProjetoGetPayload<S extends boolean | null | undefined | ProjetoDefaultArgs> = $Result.GetResult<Prisma.$ProjetoPayload, S>

  type ProjetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjetoCountAggregateInputType | true
    }

  export interface ProjetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Projeto'], meta: { name: 'Projeto' } }
    /**
     * Find zero or one Projeto that matches the filter.
     * @param {ProjetoFindUniqueArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjetoFindUniqueArgs>(args: SelectSubset<T, ProjetoFindUniqueArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Projeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjetoFindUniqueOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjetoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Projeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoFindFirstArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjetoFindFirstArgs>(args?: SelectSubset<T, ProjetoFindFirstArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Projeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoFindFirstOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjetoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projetos
     * const projetos = await prisma.projeto.findMany()
     * 
     * // Get first 10 Projetos
     * const projetos = await prisma.projeto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projetoWithIdOnly = await prisma.projeto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjetoFindManyArgs>(args?: SelectSubset<T, ProjetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Projeto.
     * @param {ProjetoCreateArgs} args - Arguments to create a Projeto.
     * @example
     * // Create one Projeto
     * const Projeto = await prisma.projeto.create({
     *   data: {
     *     // ... data to create a Projeto
     *   }
     * })
     * 
     */
    create<T extends ProjetoCreateArgs>(args: SelectSubset<T, ProjetoCreateArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projetos.
     * @param {ProjetoCreateManyArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjetoCreateManyArgs>(args?: SelectSubset<T, ProjetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projetos and returns the data saved in the database.
     * @param {ProjetoCreateManyAndReturnArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projetos and only return the `id`
     * const projetoWithIdOnly = await prisma.projeto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjetoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjetoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Projeto.
     * @param {ProjetoDeleteArgs} args - Arguments to delete one Projeto.
     * @example
     * // Delete one Projeto
     * const Projeto = await prisma.projeto.delete({
     *   where: {
     *     // ... filter to delete one Projeto
     *   }
     * })
     * 
     */
    delete<T extends ProjetoDeleteArgs>(args: SelectSubset<T, ProjetoDeleteArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Projeto.
     * @param {ProjetoUpdateArgs} args - Arguments to update one Projeto.
     * @example
     * // Update one Projeto
     * const projeto = await prisma.projeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjetoUpdateArgs>(args: SelectSubset<T, ProjetoUpdateArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projetos.
     * @param {ProjetoDeleteManyArgs} args - Arguments to filter Projetos to delete.
     * @example
     * // Delete a few Projetos
     * const { count } = await prisma.projeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjetoDeleteManyArgs>(args?: SelectSubset<T, ProjetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projetos
     * const projeto = await prisma.projeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjetoUpdateManyArgs>(args: SelectSubset<T, ProjetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projeto.
     * @param {ProjetoUpsertArgs} args - Arguments to update or create a Projeto.
     * @example
     * // Update or create a Projeto
     * const projeto = await prisma.projeto.upsert({
     *   create: {
     *     // ... data to create a Projeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projeto we want to update
     *   }
     * })
     */
    upsert<T extends ProjetoUpsertArgs>(args: SelectSubset<T, ProjetoUpsertArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoCountArgs} args - Arguments to filter Projetos to count.
     * @example
     * // Count the number of Projetos
     * const count = await prisma.projeto.count({
     *   where: {
     *     // ... the filter for the Projetos we want to count
     *   }
     * })
    **/
    count<T extends ProjetoCountArgs>(
      args?: Subset<T, ProjetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetoAggregateArgs>(args: Subset<T, ProjetoAggregateArgs>): Prisma.PrismaPromise<GetProjetoAggregateType<T>>

    /**
     * Group by Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjetoGroupByArgs['orderBy'] }
        : { orderBy?: ProjetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Projeto model
   */
  readonly fields: ProjetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Projeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    levantamento<T extends Projeto$levantamentoArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$levantamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "findMany"> | Null>
    usuarios<T extends Projeto$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    emailConfig<T extends Projeto$emailConfigArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$emailConfigArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sharepoint<T extends Projeto$sharepointArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$sharepointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends Projeto$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$teamsArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cronograma<T extends Projeto$cronogramaArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$cronogramaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "findMany"> | Null>
    licenciamento<T extends Projeto$licenciamentoArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$licenciamentoArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    orientacoes<T extends Projeto$orientacoesArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$orientacoesArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Projeto$logsArgs<ExtArgs> = {}>(args?: Subset<T, Projeto$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Projeto model
   */ 
  interface ProjetoFieldRefs {
    readonly id: FieldRef<"Projeto", 'String'>
    readonly nome: FieldRef<"Projeto", 'String'>
    readonly clienteId: FieldRef<"Projeto", 'String'>
    readonly descricao: FieldRef<"Projeto", 'String'>
    readonly status: FieldRef<"Projeto", 'String'>
    readonly progresso: FieldRef<"Projeto", 'Int'>
    readonly dataCriacao: FieldRef<"Projeto", 'DateTime'>
    readonly dataAtualizacao: FieldRef<"Projeto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Projeto findUnique
   */
  export type ProjetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * Filter, which Projeto to fetch.
     */
    where: ProjetoWhereUniqueInput
  }

  /**
   * Projeto findUniqueOrThrow
   */
  export type ProjetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * Filter, which Projeto to fetch.
     */
    where: ProjetoWhereUniqueInput
  }

  /**
   * Projeto findFirst
   */
  export type ProjetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * Filter, which Projeto to fetch.
     */
    where?: ProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projetos to fetch.
     */
    orderBy?: ProjetoOrderByWithRelationInput | ProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projetos.
     */
    cursor?: ProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * Projeto findFirstOrThrow
   */
  export type ProjetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * Filter, which Projeto to fetch.
     */
    where?: ProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projetos to fetch.
     */
    orderBy?: ProjetoOrderByWithRelationInput | ProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projetos.
     */
    cursor?: ProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * Projeto findMany
   */
  export type ProjetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * Filter, which Projetos to fetch.
     */
    where?: ProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projetos to fetch.
     */
    orderBy?: ProjetoOrderByWithRelationInput | ProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projetos.
     */
    cursor?: ProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projetos.
     */
    skip?: number
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * Projeto create
   */
  export type ProjetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * The data needed to create a Projeto.
     */
    data: XOR<ProjetoCreateInput, ProjetoUncheckedCreateInput>
  }

  /**
   * Projeto createMany
   */
  export type ProjetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projetos.
     */
    data: ProjetoCreateManyInput | ProjetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Projeto createManyAndReturn
   */
  export type ProjetoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projetos.
     */
    data: ProjetoCreateManyInput | ProjetoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Projeto update
   */
  export type ProjetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * The data needed to update a Projeto.
     */
    data: XOR<ProjetoUpdateInput, ProjetoUncheckedUpdateInput>
    /**
     * Choose, which Projeto to update.
     */
    where: ProjetoWhereUniqueInput
  }

  /**
   * Projeto updateMany
   */
  export type ProjetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projetos.
     */
    data: XOR<ProjetoUpdateManyMutationInput, ProjetoUncheckedUpdateManyInput>
    /**
     * Filter which Projetos to update
     */
    where?: ProjetoWhereInput
  }

  /**
   * Projeto upsert
   */
  export type ProjetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * The filter to search for the Projeto to update in case it exists.
     */
    where: ProjetoWhereUniqueInput
    /**
     * In case the Projeto found by the `where` argument doesn't exist, create a new Projeto with this data.
     */
    create: XOR<ProjetoCreateInput, ProjetoUncheckedCreateInput>
    /**
     * In case the Projeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjetoUpdateInput, ProjetoUncheckedUpdateInput>
  }

  /**
   * Projeto delete
   */
  export type ProjetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    /**
     * Filter which Projeto to delete.
     */
    where: ProjetoWhereUniqueInput
  }

  /**
   * Projeto deleteMany
   */
  export type ProjetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projetos to delete
     */
    where?: ProjetoWhereInput
  }

  /**
   * Projeto.levantamento
   */
  export type Projeto$levantamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    where?: LevantamentoWhereInput
    orderBy?: LevantamentoOrderByWithRelationInput | LevantamentoOrderByWithRelationInput[]
    cursor?: LevantamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevantamentoScalarFieldEnum | LevantamentoScalarFieldEnum[]
  }

  /**
   * Projeto.usuarios
   */
  export type Projeto$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Projeto.emailConfig
   */
  export type Projeto$emailConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    where?: EmailConfigWhereInput
  }

  /**
   * Projeto.sharepoint
   */
  export type Projeto$sharepointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    where?: SharePointSiteWhereInput
    orderBy?: SharePointSiteOrderByWithRelationInput | SharePointSiteOrderByWithRelationInput[]
    cursor?: SharePointSiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharePointSiteScalarFieldEnum | SharePointSiteScalarFieldEnum[]
  }

  /**
   * Projeto.teams
   */
  export type Projeto$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    where?: TeamsConfigWhereInput
  }

  /**
   * Projeto.cronograma
   */
  export type Projeto$cronogramaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    where?: CronogramaItemWhereInput
    orderBy?: CronogramaItemOrderByWithRelationInput | CronogramaItemOrderByWithRelationInput[]
    cursor?: CronogramaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CronogramaItemScalarFieldEnum | CronogramaItemScalarFieldEnum[]
  }

  /**
   * Projeto.licenciamento
   */
  export type Projeto$licenciamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    where?: LicenciamentoWhereInput
  }

  /**
   * Projeto.orientacoes
   */
  export type Projeto$orientacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    where?: OrientacaoWhereInput
  }

  /**
   * Projeto.logs
   */
  export type Projeto$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    where?: LogProjetoWhereInput
    orderBy?: LogProjetoOrderByWithRelationInput | LogProjetoOrderByWithRelationInput[]
    cursor?: LogProjetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogProjetoScalarFieldEnum | LogProjetoScalarFieldEnum[]
  }

  /**
   * Projeto without action
   */
  export type ProjetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
  }


  /**
   * Model Analyst
   */

  export type AggregateAnalyst = {
    _count: AnalystCountAggregateOutputType | null
    _min: AnalystMinAggregateOutputType | null
    _max: AnalystMaxAggregateOutputType | null
  }

  export type AnalystMinAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    papel: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AnalystMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    papel: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AnalystCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    papel: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type AnalystMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    papel?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AnalystMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    papel?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AnalystCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    papel?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type AnalystAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analyst to aggregate.
     */
    where?: AnalystWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analysts to fetch.
     */
    orderBy?: AnalystOrderByWithRelationInput | AnalystOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalystWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analysts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analysts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analysts
    **/
    _count?: true | AnalystCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalystMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalystMaxAggregateInputType
  }

  export type GetAnalystAggregateType<T extends AnalystAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyst]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyst[P]>
      : GetScalarType<T[P], AggregateAnalyst[P]>
  }




  export type AnalystGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalystWhereInput
    orderBy?: AnalystOrderByWithAggregationInput | AnalystOrderByWithAggregationInput[]
    by: AnalystScalarFieldEnum[] | AnalystScalarFieldEnum
    having?: AnalystScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalystCountAggregateInputType | true
    _min?: AnalystMinAggregateInputType
    _max?: AnalystMaxAggregateInputType
  }

  export type AnalystGroupByOutputType = {
    id: string
    nome: string
    email: string
    senha: string
    papel: string
    criadoEm: Date
    atualizadoEm: Date
    _count: AnalystCountAggregateOutputType | null
    _min: AnalystMinAggregateOutputType | null
    _max: AnalystMaxAggregateOutputType | null
  }

  type GetAnalystGroupByPayload<T extends AnalystGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalystGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalystGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalystGroupByOutputType[P]>
            : GetScalarType<T[P], AnalystGroupByOutputType[P]>
        }
      >
    >


  export type AnalystSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    papel?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    logs?: boolean | Analyst$logsArgs<ExtArgs>
    _count?: boolean | AnalystCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyst"]>

  export type AnalystSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    papel?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["analyst"]>

  export type AnalystSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    papel?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type AnalystInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | Analyst$logsArgs<ExtArgs>
    _count?: boolean | AnalystCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnalystIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnalystPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analyst"
    objects: {
      logs: Prisma.$DecisionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      email: string
      senha: string
      papel: string
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["analyst"]>
    composites: {}
  }

  type AnalystGetPayload<S extends boolean | null | undefined | AnalystDefaultArgs> = $Result.GetResult<Prisma.$AnalystPayload, S>

  type AnalystCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalystFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalystCountAggregateInputType | true
    }

  export interface AnalystDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analyst'], meta: { name: 'Analyst' } }
    /**
     * Find zero or one Analyst that matches the filter.
     * @param {AnalystFindUniqueArgs} args - Arguments to find a Analyst
     * @example
     * // Get one Analyst
     * const analyst = await prisma.analyst.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalystFindUniqueArgs>(args: SelectSubset<T, AnalystFindUniqueArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Analyst that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalystFindUniqueOrThrowArgs} args - Arguments to find a Analyst
     * @example
     * // Get one Analyst
     * const analyst = await prisma.analyst.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalystFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalystFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Analyst that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystFindFirstArgs} args - Arguments to find a Analyst
     * @example
     * // Get one Analyst
     * const analyst = await prisma.analyst.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalystFindFirstArgs>(args?: SelectSubset<T, AnalystFindFirstArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Analyst that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystFindFirstOrThrowArgs} args - Arguments to find a Analyst
     * @example
     * // Get one Analyst
     * const analyst = await prisma.analyst.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalystFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalystFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Analysts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analysts
     * const analysts = await prisma.analyst.findMany()
     * 
     * // Get first 10 Analysts
     * const analysts = await prisma.analyst.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analystWithIdOnly = await prisma.analyst.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalystFindManyArgs>(args?: SelectSubset<T, AnalystFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Analyst.
     * @param {AnalystCreateArgs} args - Arguments to create a Analyst.
     * @example
     * // Create one Analyst
     * const Analyst = await prisma.analyst.create({
     *   data: {
     *     // ... data to create a Analyst
     *   }
     * })
     * 
     */
    create<T extends AnalystCreateArgs>(args: SelectSubset<T, AnalystCreateArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Analysts.
     * @param {AnalystCreateManyArgs} args - Arguments to create many Analysts.
     * @example
     * // Create many Analysts
     * const analyst = await prisma.analyst.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalystCreateManyArgs>(args?: SelectSubset<T, AnalystCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analysts and returns the data saved in the database.
     * @param {AnalystCreateManyAndReturnArgs} args - Arguments to create many Analysts.
     * @example
     * // Create many Analysts
     * const analyst = await prisma.analyst.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analysts and only return the `id`
     * const analystWithIdOnly = await prisma.analyst.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalystCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalystCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Analyst.
     * @param {AnalystDeleteArgs} args - Arguments to delete one Analyst.
     * @example
     * // Delete one Analyst
     * const Analyst = await prisma.analyst.delete({
     *   where: {
     *     // ... filter to delete one Analyst
     *   }
     * })
     * 
     */
    delete<T extends AnalystDeleteArgs>(args: SelectSubset<T, AnalystDeleteArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Analyst.
     * @param {AnalystUpdateArgs} args - Arguments to update one Analyst.
     * @example
     * // Update one Analyst
     * const analyst = await prisma.analyst.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalystUpdateArgs>(args: SelectSubset<T, AnalystUpdateArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Analysts.
     * @param {AnalystDeleteManyArgs} args - Arguments to filter Analysts to delete.
     * @example
     * // Delete a few Analysts
     * const { count } = await prisma.analyst.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalystDeleteManyArgs>(args?: SelectSubset<T, AnalystDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analysts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analysts
     * const analyst = await prisma.analyst.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalystUpdateManyArgs>(args: SelectSubset<T, AnalystUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analyst.
     * @param {AnalystUpsertArgs} args - Arguments to update or create a Analyst.
     * @example
     * // Update or create a Analyst
     * const analyst = await prisma.analyst.upsert({
     *   create: {
     *     // ... data to create a Analyst
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analyst we want to update
     *   }
     * })
     */
    upsert<T extends AnalystUpsertArgs>(args: SelectSubset<T, AnalystUpsertArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Analysts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystCountArgs} args - Arguments to filter Analysts to count.
     * @example
     * // Count the number of Analysts
     * const count = await prisma.analyst.count({
     *   where: {
     *     // ... the filter for the Analysts we want to count
     *   }
     * })
    **/
    count<T extends AnalystCountArgs>(
      args?: Subset<T, AnalystCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalystCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analyst.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalystAggregateArgs>(args: Subset<T, AnalystAggregateArgs>): Prisma.PrismaPromise<GetAnalystAggregateType<T>>

    /**
     * Group by Analyst.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalystGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalystGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalystGroupByArgs['orderBy'] }
        : { orderBy?: AnalystGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalystGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalystGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analyst model
   */
  readonly fields: AnalystFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analyst.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalystClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends Analyst$logsArgs<ExtArgs> = {}>(args?: Subset<T, Analyst$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analyst model
   */ 
  interface AnalystFieldRefs {
    readonly id: FieldRef<"Analyst", 'String'>
    readonly nome: FieldRef<"Analyst", 'String'>
    readonly email: FieldRef<"Analyst", 'String'>
    readonly senha: FieldRef<"Analyst", 'String'>
    readonly papel: FieldRef<"Analyst", 'String'>
    readonly criadoEm: FieldRef<"Analyst", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Analyst", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analyst findUnique
   */
  export type AnalystFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * Filter, which Analyst to fetch.
     */
    where: AnalystWhereUniqueInput
  }

  /**
   * Analyst findUniqueOrThrow
   */
  export type AnalystFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * Filter, which Analyst to fetch.
     */
    where: AnalystWhereUniqueInput
  }

  /**
   * Analyst findFirst
   */
  export type AnalystFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * Filter, which Analyst to fetch.
     */
    where?: AnalystWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analysts to fetch.
     */
    orderBy?: AnalystOrderByWithRelationInput | AnalystOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analysts.
     */
    cursor?: AnalystWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analysts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analysts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analysts.
     */
    distinct?: AnalystScalarFieldEnum | AnalystScalarFieldEnum[]
  }

  /**
   * Analyst findFirstOrThrow
   */
  export type AnalystFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * Filter, which Analyst to fetch.
     */
    where?: AnalystWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analysts to fetch.
     */
    orderBy?: AnalystOrderByWithRelationInput | AnalystOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analysts.
     */
    cursor?: AnalystWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analysts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analysts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analysts.
     */
    distinct?: AnalystScalarFieldEnum | AnalystScalarFieldEnum[]
  }

  /**
   * Analyst findMany
   */
  export type AnalystFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * Filter, which Analysts to fetch.
     */
    where?: AnalystWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analysts to fetch.
     */
    orderBy?: AnalystOrderByWithRelationInput | AnalystOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analysts.
     */
    cursor?: AnalystWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analysts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analysts.
     */
    skip?: number
    distinct?: AnalystScalarFieldEnum | AnalystScalarFieldEnum[]
  }

  /**
   * Analyst create
   */
  export type AnalystCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * The data needed to create a Analyst.
     */
    data: XOR<AnalystCreateInput, AnalystUncheckedCreateInput>
  }

  /**
   * Analyst createMany
   */
  export type AnalystCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analysts.
     */
    data: AnalystCreateManyInput | AnalystCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analyst createManyAndReturn
   */
  export type AnalystCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Analysts.
     */
    data: AnalystCreateManyInput | AnalystCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analyst update
   */
  export type AnalystUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * The data needed to update a Analyst.
     */
    data: XOR<AnalystUpdateInput, AnalystUncheckedUpdateInput>
    /**
     * Choose, which Analyst to update.
     */
    where: AnalystWhereUniqueInput
  }

  /**
   * Analyst updateMany
   */
  export type AnalystUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analysts.
     */
    data: XOR<AnalystUpdateManyMutationInput, AnalystUncheckedUpdateManyInput>
    /**
     * Filter which Analysts to update
     */
    where?: AnalystWhereInput
  }

  /**
   * Analyst upsert
   */
  export type AnalystUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * The filter to search for the Analyst to update in case it exists.
     */
    where: AnalystWhereUniqueInput
    /**
     * In case the Analyst found by the `where` argument doesn't exist, create a new Analyst with this data.
     */
    create: XOR<AnalystCreateInput, AnalystUncheckedCreateInput>
    /**
     * In case the Analyst was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalystUpdateInput, AnalystUncheckedUpdateInput>
  }

  /**
   * Analyst delete
   */
  export type AnalystDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
    /**
     * Filter which Analyst to delete.
     */
    where: AnalystWhereUniqueInput
  }

  /**
   * Analyst deleteMany
   */
  export type AnalystDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analysts to delete
     */
    where?: AnalystWhereInput
  }

  /**
   * Analyst.logs
   */
  export type Analyst$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    cursor?: DecisionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * Analyst without action
   */
  export type AnalystDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analyst
     */
    select?: AnalystSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalystInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    nome: string | null
    dominio: string | null
    segmento: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    dominio: string | null
    segmento: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    nome: number
    dominio: number
    segmento: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    nome?: true
    dominio?: true
    segmento?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    nome?: true
    dominio?: true
    segmento?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    nome?: true
    dominio?: true
    segmento?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    nome: string
    dominio: string
    segmento: string
    criadoEm: Date
    atualizadoEm: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dominio?: boolean
    segmento?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    projetos?: boolean | Client$projetosArgs<ExtArgs>
    deployments?: boolean | Client$deploymentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dominio?: boolean
    segmento?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    nome?: boolean
    dominio?: boolean
    segmento?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetos?: boolean | Client$projetosArgs<ExtArgs>
    deployments?: boolean | Client$deploymentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      projetos: Prisma.$ProjetoPayload<ExtArgs>[]
      deployments: Prisma.$DeploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      dominio: string
      segmento: string
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projetos<T extends Client$projetosArgs<ExtArgs> = {}>(args?: Subset<T, Client$projetosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findMany"> | Null>
    deployments<T extends Client$deploymentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$deploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly nome: FieldRef<"Client", 'String'>
    readonly dominio: FieldRef<"Client", 'String'>
    readonly segmento: FieldRef<"Client", 'String'>
    readonly criadoEm: FieldRef<"Client", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.projetos
   */
  export type Client$projetosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Projeto
     */
    select?: ProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjetoInclude<ExtArgs> | null
    where?: ProjetoWhereInput
    orderBy?: ProjetoOrderByWithRelationInput | ProjetoOrderByWithRelationInput[]
    cursor?: ProjetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * Client.deployments
   */
  export type Client$deploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    cursor?: DeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model DecisionLog
   */

  export type AggregateDecisionLog = {
    _count: DecisionLogCountAggregateOutputType | null
    _min: DecisionLogMinAggregateOutputType | null
    _max: DecisionLogMaxAggregateOutputType | null
  }

  export type DecisionLogMinAggregateOutputType = {
    id: string | null
    analistaId: string | null
    deploymentId: string | null
    descricao: string | null
    criadoEm: Date | null
  }

  export type DecisionLogMaxAggregateOutputType = {
    id: string | null
    analistaId: string | null
    deploymentId: string | null
    descricao: string | null
    criadoEm: Date | null
  }

  export type DecisionLogCountAggregateOutputType = {
    id: number
    analistaId: number
    deploymentId: number
    descricao: number
    criadoEm: number
    _all: number
  }


  export type DecisionLogMinAggregateInputType = {
    id?: true
    analistaId?: true
    deploymentId?: true
    descricao?: true
    criadoEm?: true
  }

  export type DecisionLogMaxAggregateInputType = {
    id?: true
    analistaId?: true
    deploymentId?: true
    descricao?: true
    criadoEm?: true
  }

  export type DecisionLogCountAggregateInputType = {
    id?: true
    analistaId?: true
    deploymentId?: true
    descricao?: true
    criadoEm?: true
    _all?: true
  }

  export type DecisionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionLog to aggregate.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DecisionLogs
    **/
    _count?: true | DecisionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecisionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecisionLogMaxAggregateInputType
  }

  export type GetDecisionLogAggregateType<T extends DecisionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDecisionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecisionLog[P]>
      : GetScalarType<T[P], AggregateDecisionLog[P]>
  }




  export type DecisionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithAggregationInput | DecisionLogOrderByWithAggregationInput[]
    by: DecisionLogScalarFieldEnum[] | DecisionLogScalarFieldEnum
    having?: DecisionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecisionLogCountAggregateInputType | true
    _min?: DecisionLogMinAggregateInputType
    _max?: DecisionLogMaxAggregateInputType
  }

  export type DecisionLogGroupByOutputType = {
    id: string
    analistaId: string
    deploymentId: string
    descricao: string
    criadoEm: Date
    _count: DecisionLogCountAggregateOutputType | null
    _min: DecisionLogMinAggregateOutputType | null
    _max: DecisionLogMaxAggregateOutputType | null
  }

  type GetDecisionLogGroupByPayload<T extends DecisionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecisionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecisionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecisionLogGroupByOutputType[P]>
            : GetScalarType<T[P], DecisionLogGroupByOutputType[P]>
        }
      >
    >


  export type DecisionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analistaId?: boolean
    deploymentId?: boolean
    descricao?: boolean
    criadoEm?: boolean
    analista?: boolean | AnalystDefaultArgs<ExtArgs>
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decisionLog"]>

  export type DecisionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    analistaId?: boolean
    deploymentId?: boolean
    descricao?: boolean
    criadoEm?: boolean
    analista?: boolean | AnalystDefaultArgs<ExtArgs>
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decisionLog"]>

  export type DecisionLogSelectScalar = {
    id?: boolean
    analistaId?: boolean
    deploymentId?: boolean
    descricao?: boolean
    criadoEm?: boolean
  }

  export type DecisionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analista?: boolean | AnalystDefaultArgs<ExtArgs>
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
  }
  export type DecisionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analista?: boolean | AnalystDefaultArgs<ExtArgs>
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
  }

  export type $DecisionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DecisionLog"
    objects: {
      analista: Prisma.$AnalystPayload<ExtArgs>
      deployment: Prisma.$DeploymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      analistaId: string
      deploymentId: string
      descricao: string
      criadoEm: Date
    }, ExtArgs["result"]["decisionLog"]>
    composites: {}
  }

  type DecisionLogGetPayload<S extends boolean | null | undefined | DecisionLogDefaultArgs> = $Result.GetResult<Prisma.$DecisionLogPayload, S>

  type DecisionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DecisionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DecisionLogCountAggregateInputType | true
    }

  export interface DecisionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DecisionLog'], meta: { name: 'DecisionLog' } }
    /**
     * Find zero or one DecisionLog that matches the filter.
     * @param {DecisionLogFindUniqueArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecisionLogFindUniqueArgs>(args: SelectSubset<T, DecisionLogFindUniqueArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DecisionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DecisionLogFindUniqueOrThrowArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecisionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DecisionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DecisionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogFindFirstArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecisionLogFindFirstArgs>(args?: SelectSubset<T, DecisionLogFindFirstArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DecisionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogFindFirstOrThrowArgs} args - Arguments to find a DecisionLog
     * @example
     * // Get one DecisionLog
     * const decisionLog = await prisma.decisionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecisionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DecisionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DecisionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DecisionLogs
     * const decisionLogs = await prisma.decisionLog.findMany()
     * 
     * // Get first 10 DecisionLogs
     * const decisionLogs = await prisma.decisionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decisionLogWithIdOnly = await prisma.decisionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecisionLogFindManyArgs>(args?: SelectSubset<T, DecisionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DecisionLog.
     * @param {DecisionLogCreateArgs} args - Arguments to create a DecisionLog.
     * @example
     * // Create one DecisionLog
     * const DecisionLog = await prisma.decisionLog.create({
     *   data: {
     *     // ... data to create a DecisionLog
     *   }
     * })
     * 
     */
    create<T extends DecisionLogCreateArgs>(args: SelectSubset<T, DecisionLogCreateArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DecisionLogs.
     * @param {DecisionLogCreateManyArgs} args - Arguments to create many DecisionLogs.
     * @example
     * // Create many DecisionLogs
     * const decisionLog = await prisma.decisionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecisionLogCreateManyArgs>(args?: SelectSubset<T, DecisionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DecisionLogs and returns the data saved in the database.
     * @param {DecisionLogCreateManyAndReturnArgs} args - Arguments to create many DecisionLogs.
     * @example
     * // Create many DecisionLogs
     * const decisionLog = await prisma.decisionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DecisionLogs and only return the `id`
     * const decisionLogWithIdOnly = await prisma.decisionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecisionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DecisionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DecisionLog.
     * @param {DecisionLogDeleteArgs} args - Arguments to delete one DecisionLog.
     * @example
     * // Delete one DecisionLog
     * const DecisionLog = await prisma.decisionLog.delete({
     *   where: {
     *     // ... filter to delete one DecisionLog
     *   }
     * })
     * 
     */
    delete<T extends DecisionLogDeleteArgs>(args: SelectSubset<T, DecisionLogDeleteArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DecisionLog.
     * @param {DecisionLogUpdateArgs} args - Arguments to update one DecisionLog.
     * @example
     * // Update one DecisionLog
     * const decisionLog = await prisma.decisionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecisionLogUpdateArgs>(args: SelectSubset<T, DecisionLogUpdateArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DecisionLogs.
     * @param {DecisionLogDeleteManyArgs} args - Arguments to filter DecisionLogs to delete.
     * @example
     * // Delete a few DecisionLogs
     * const { count } = await prisma.decisionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecisionLogDeleteManyArgs>(args?: SelectSubset<T, DecisionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DecisionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DecisionLogs
     * const decisionLog = await prisma.decisionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecisionLogUpdateManyArgs>(args: SelectSubset<T, DecisionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DecisionLog.
     * @param {DecisionLogUpsertArgs} args - Arguments to update or create a DecisionLog.
     * @example
     * // Update or create a DecisionLog
     * const decisionLog = await prisma.decisionLog.upsert({
     *   create: {
     *     // ... data to create a DecisionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DecisionLog we want to update
     *   }
     * })
     */
    upsert<T extends DecisionLogUpsertArgs>(args: SelectSubset<T, DecisionLogUpsertArgs<ExtArgs>>): Prisma__DecisionLogClient<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DecisionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogCountArgs} args - Arguments to filter DecisionLogs to count.
     * @example
     * // Count the number of DecisionLogs
     * const count = await prisma.decisionLog.count({
     *   where: {
     *     // ... the filter for the DecisionLogs we want to count
     *   }
     * })
    **/
    count<T extends DecisionLogCountArgs>(
      args?: Subset<T, DecisionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecisionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DecisionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecisionLogAggregateArgs>(args: Subset<T, DecisionLogAggregateArgs>): Prisma.PrismaPromise<GetDecisionLogAggregateType<T>>

    /**
     * Group by DecisionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecisionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecisionLogGroupByArgs['orderBy'] }
        : { orderBy?: DecisionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecisionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecisionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DecisionLog model
   */
  readonly fields: DecisionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DecisionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecisionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    analista<T extends AnalystDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnalystDefaultArgs<ExtArgs>>): Prisma__AnalystClient<$Result.GetResult<Prisma.$AnalystPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deployment<T extends DeploymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentDefaultArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DecisionLog model
   */ 
  interface DecisionLogFieldRefs {
    readonly id: FieldRef<"DecisionLog", 'String'>
    readonly analistaId: FieldRef<"DecisionLog", 'String'>
    readonly deploymentId: FieldRef<"DecisionLog", 'String'>
    readonly descricao: FieldRef<"DecisionLog", 'String'>
    readonly criadoEm: FieldRef<"DecisionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DecisionLog findUnique
   */
  export type DecisionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog findUniqueOrThrow
   */
  export type DecisionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog findFirst
   */
  export type DecisionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionLogs.
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionLogs.
     */
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * DecisionLog findFirstOrThrow
   */
  export type DecisionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLog to fetch.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DecisionLogs.
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DecisionLogs.
     */
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * DecisionLog findMany
   */
  export type DecisionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter, which DecisionLogs to fetch.
     */
    where?: DecisionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DecisionLogs to fetch.
     */
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DecisionLogs.
     */
    cursor?: DecisionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DecisionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DecisionLogs.
     */
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * DecisionLog create
   */
  export type DecisionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DecisionLog.
     */
    data: XOR<DecisionLogCreateInput, DecisionLogUncheckedCreateInput>
  }

  /**
   * DecisionLog createMany
   */
  export type DecisionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DecisionLogs.
     */
    data: DecisionLogCreateManyInput | DecisionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DecisionLog createManyAndReturn
   */
  export type DecisionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DecisionLogs.
     */
    data: DecisionLogCreateManyInput | DecisionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DecisionLog update
   */
  export type DecisionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DecisionLog.
     */
    data: XOR<DecisionLogUpdateInput, DecisionLogUncheckedUpdateInput>
    /**
     * Choose, which DecisionLog to update.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog updateMany
   */
  export type DecisionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DecisionLogs.
     */
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyInput>
    /**
     * Filter which DecisionLogs to update
     */
    where?: DecisionLogWhereInput
  }

  /**
   * DecisionLog upsert
   */
  export type DecisionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DecisionLog to update in case it exists.
     */
    where: DecisionLogWhereUniqueInput
    /**
     * In case the DecisionLog found by the `where` argument doesn't exist, create a new DecisionLog with this data.
     */
    create: XOR<DecisionLogCreateInput, DecisionLogUncheckedCreateInput>
    /**
     * In case the DecisionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecisionLogUpdateInput, DecisionLogUncheckedUpdateInput>
  }

  /**
   * DecisionLog delete
   */
  export type DecisionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    /**
     * Filter which DecisionLog to delete.
     */
    where: DecisionLogWhereUniqueInput
  }

  /**
   * DecisionLog deleteMany
   */
  export type DecisionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DecisionLogs to delete
     */
    where?: DecisionLogWhereInput
  }

  /**
   * DecisionLog without action
   */
  export type DecisionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
  }


  /**
   * Model LogProjeto
   */

  export type AggregateLogProjeto = {
    _count: LogProjetoCountAggregateOutputType | null
    _min: LogProjetoMinAggregateOutputType | null
    _max: LogProjetoMaxAggregateOutputType | null
  }

  export type LogProjetoMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    mensagem: string | null
    criadoEm: Date | null
  }

  export type LogProjetoMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    mensagem: string | null
    criadoEm: Date | null
  }

  export type LogProjetoCountAggregateOutputType = {
    id: number
    projetoId: number
    mensagem: number
    criadoEm: number
    _all: number
  }


  export type LogProjetoMinAggregateInputType = {
    id?: true
    projetoId?: true
    mensagem?: true
    criadoEm?: true
  }

  export type LogProjetoMaxAggregateInputType = {
    id?: true
    projetoId?: true
    mensagem?: true
    criadoEm?: true
  }

  export type LogProjetoCountAggregateInputType = {
    id?: true
    projetoId?: true
    mensagem?: true
    criadoEm?: true
    _all?: true
  }

  export type LogProjetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogProjeto to aggregate.
     */
    where?: LogProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogProjetos to fetch.
     */
    orderBy?: LogProjetoOrderByWithRelationInput | LogProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogProjetos
    **/
    _count?: true | LogProjetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogProjetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogProjetoMaxAggregateInputType
  }

  export type GetLogProjetoAggregateType<T extends LogProjetoAggregateArgs> = {
        [P in keyof T & keyof AggregateLogProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogProjeto[P]>
      : GetScalarType<T[P], AggregateLogProjeto[P]>
  }




  export type LogProjetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogProjetoWhereInput
    orderBy?: LogProjetoOrderByWithAggregationInput | LogProjetoOrderByWithAggregationInput[]
    by: LogProjetoScalarFieldEnum[] | LogProjetoScalarFieldEnum
    having?: LogProjetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogProjetoCountAggregateInputType | true
    _min?: LogProjetoMinAggregateInputType
    _max?: LogProjetoMaxAggregateInputType
  }

  export type LogProjetoGroupByOutputType = {
    id: string
    projetoId: string
    mensagem: string
    criadoEm: Date
    _count: LogProjetoCountAggregateOutputType | null
    _min: LogProjetoMinAggregateOutputType | null
    _max: LogProjetoMaxAggregateOutputType | null
  }

  type GetLogProjetoGroupByPayload<T extends LogProjetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogProjetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogProjetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], LogProjetoGroupByOutputType[P]>
        }
      >
    >


  export type LogProjetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    mensagem?: boolean
    criadoEm?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logProjeto"]>

  export type LogProjetoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    mensagem?: boolean
    criadoEm?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logProjeto"]>

  export type LogProjetoSelectScalar = {
    id?: boolean
    projetoId?: boolean
    mensagem?: boolean
    criadoEm?: boolean
  }

  export type LogProjetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type LogProjetoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $LogProjetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogProjeto"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      mensagem: string
      criadoEm: Date
    }, ExtArgs["result"]["logProjeto"]>
    composites: {}
  }

  type LogProjetoGetPayload<S extends boolean | null | undefined | LogProjetoDefaultArgs> = $Result.GetResult<Prisma.$LogProjetoPayload, S>

  type LogProjetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogProjetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogProjetoCountAggregateInputType | true
    }

  export interface LogProjetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogProjeto'], meta: { name: 'LogProjeto' } }
    /**
     * Find zero or one LogProjeto that matches the filter.
     * @param {LogProjetoFindUniqueArgs} args - Arguments to find a LogProjeto
     * @example
     * // Get one LogProjeto
     * const logProjeto = await prisma.logProjeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogProjetoFindUniqueArgs>(args: SelectSubset<T, LogProjetoFindUniqueArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogProjeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogProjetoFindUniqueOrThrowArgs} args - Arguments to find a LogProjeto
     * @example
     * // Get one LogProjeto
     * const logProjeto = await prisma.logProjeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogProjetoFindUniqueOrThrowArgs>(args: SelectSubset<T, LogProjetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogProjeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoFindFirstArgs} args - Arguments to find a LogProjeto
     * @example
     * // Get one LogProjeto
     * const logProjeto = await prisma.logProjeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogProjetoFindFirstArgs>(args?: SelectSubset<T, LogProjetoFindFirstArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogProjeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoFindFirstOrThrowArgs} args - Arguments to find a LogProjeto
     * @example
     * // Get one LogProjeto
     * const logProjeto = await prisma.logProjeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogProjetoFindFirstOrThrowArgs>(args?: SelectSubset<T, LogProjetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogProjetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogProjetos
     * const logProjetos = await prisma.logProjeto.findMany()
     * 
     * // Get first 10 LogProjetos
     * const logProjetos = await prisma.logProjeto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logProjetoWithIdOnly = await prisma.logProjeto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogProjetoFindManyArgs>(args?: SelectSubset<T, LogProjetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogProjeto.
     * @param {LogProjetoCreateArgs} args - Arguments to create a LogProjeto.
     * @example
     * // Create one LogProjeto
     * const LogProjeto = await prisma.logProjeto.create({
     *   data: {
     *     // ... data to create a LogProjeto
     *   }
     * })
     * 
     */
    create<T extends LogProjetoCreateArgs>(args: SelectSubset<T, LogProjetoCreateArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogProjetos.
     * @param {LogProjetoCreateManyArgs} args - Arguments to create many LogProjetos.
     * @example
     * // Create many LogProjetos
     * const logProjeto = await prisma.logProjeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogProjetoCreateManyArgs>(args?: SelectSubset<T, LogProjetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogProjetos and returns the data saved in the database.
     * @param {LogProjetoCreateManyAndReturnArgs} args - Arguments to create many LogProjetos.
     * @example
     * // Create many LogProjetos
     * const logProjeto = await prisma.logProjeto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogProjetos and only return the `id`
     * const logProjetoWithIdOnly = await prisma.logProjeto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogProjetoCreateManyAndReturnArgs>(args?: SelectSubset<T, LogProjetoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogProjeto.
     * @param {LogProjetoDeleteArgs} args - Arguments to delete one LogProjeto.
     * @example
     * // Delete one LogProjeto
     * const LogProjeto = await prisma.logProjeto.delete({
     *   where: {
     *     // ... filter to delete one LogProjeto
     *   }
     * })
     * 
     */
    delete<T extends LogProjetoDeleteArgs>(args: SelectSubset<T, LogProjetoDeleteArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogProjeto.
     * @param {LogProjetoUpdateArgs} args - Arguments to update one LogProjeto.
     * @example
     * // Update one LogProjeto
     * const logProjeto = await prisma.logProjeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogProjetoUpdateArgs>(args: SelectSubset<T, LogProjetoUpdateArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogProjetos.
     * @param {LogProjetoDeleteManyArgs} args - Arguments to filter LogProjetos to delete.
     * @example
     * // Delete a few LogProjetos
     * const { count } = await prisma.logProjeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogProjetoDeleteManyArgs>(args?: SelectSubset<T, LogProjetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogProjetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogProjetos
     * const logProjeto = await prisma.logProjeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogProjetoUpdateManyArgs>(args: SelectSubset<T, LogProjetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogProjeto.
     * @param {LogProjetoUpsertArgs} args - Arguments to update or create a LogProjeto.
     * @example
     * // Update or create a LogProjeto
     * const logProjeto = await prisma.logProjeto.upsert({
     *   create: {
     *     // ... data to create a LogProjeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogProjeto we want to update
     *   }
     * })
     */
    upsert<T extends LogProjetoUpsertArgs>(args: SelectSubset<T, LogProjetoUpsertArgs<ExtArgs>>): Prisma__LogProjetoClient<$Result.GetResult<Prisma.$LogProjetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogProjetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoCountArgs} args - Arguments to filter LogProjetos to count.
     * @example
     * // Count the number of LogProjetos
     * const count = await prisma.logProjeto.count({
     *   where: {
     *     // ... the filter for the LogProjetos we want to count
     *   }
     * })
    **/
    count<T extends LogProjetoCountArgs>(
      args?: Subset<T, LogProjetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogProjetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogProjeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogProjetoAggregateArgs>(args: Subset<T, LogProjetoAggregateArgs>): Prisma.PrismaPromise<GetLogProjetoAggregateType<T>>

    /**
     * Group by LogProjeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogProjetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogProjetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogProjetoGroupByArgs['orderBy'] }
        : { orderBy?: LogProjetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogProjetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogProjetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogProjeto model
   */
  readonly fields: LogProjetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogProjeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogProjetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogProjeto model
   */ 
  interface LogProjetoFieldRefs {
    readonly id: FieldRef<"LogProjeto", 'String'>
    readonly projetoId: FieldRef<"LogProjeto", 'String'>
    readonly mensagem: FieldRef<"LogProjeto", 'String'>
    readonly criadoEm: FieldRef<"LogProjeto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogProjeto findUnique
   */
  export type LogProjetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * Filter, which LogProjeto to fetch.
     */
    where: LogProjetoWhereUniqueInput
  }

  /**
   * LogProjeto findUniqueOrThrow
   */
  export type LogProjetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * Filter, which LogProjeto to fetch.
     */
    where: LogProjetoWhereUniqueInput
  }

  /**
   * LogProjeto findFirst
   */
  export type LogProjetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * Filter, which LogProjeto to fetch.
     */
    where?: LogProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogProjetos to fetch.
     */
    orderBy?: LogProjetoOrderByWithRelationInput | LogProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogProjetos.
     */
    cursor?: LogProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogProjetos.
     */
    distinct?: LogProjetoScalarFieldEnum | LogProjetoScalarFieldEnum[]
  }

  /**
   * LogProjeto findFirstOrThrow
   */
  export type LogProjetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * Filter, which LogProjeto to fetch.
     */
    where?: LogProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogProjetos to fetch.
     */
    orderBy?: LogProjetoOrderByWithRelationInput | LogProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogProjetos.
     */
    cursor?: LogProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogProjetos.
     */
    distinct?: LogProjetoScalarFieldEnum | LogProjetoScalarFieldEnum[]
  }

  /**
   * LogProjeto findMany
   */
  export type LogProjetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * Filter, which LogProjetos to fetch.
     */
    where?: LogProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogProjetos to fetch.
     */
    orderBy?: LogProjetoOrderByWithRelationInput | LogProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogProjetos.
     */
    cursor?: LogProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogProjetos.
     */
    skip?: number
    distinct?: LogProjetoScalarFieldEnum | LogProjetoScalarFieldEnum[]
  }

  /**
   * LogProjeto create
   */
  export type LogProjetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * The data needed to create a LogProjeto.
     */
    data: XOR<LogProjetoCreateInput, LogProjetoUncheckedCreateInput>
  }

  /**
   * LogProjeto createMany
   */
  export type LogProjetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogProjetos.
     */
    data: LogProjetoCreateManyInput | LogProjetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogProjeto createManyAndReturn
   */
  export type LogProjetoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogProjetos.
     */
    data: LogProjetoCreateManyInput | LogProjetoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogProjeto update
   */
  export type LogProjetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * The data needed to update a LogProjeto.
     */
    data: XOR<LogProjetoUpdateInput, LogProjetoUncheckedUpdateInput>
    /**
     * Choose, which LogProjeto to update.
     */
    where: LogProjetoWhereUniqueInput
  }

  /**
   * LogProjeto updateMany
   */
  export type LogProjetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogProjetos.
     */
    data: XOR<LogProjetoUpdateManyMutationInput, LogProjetoUncheckedUpdateManyInput>
    /**
     * Filter which LogProjetos to update
     */
    where?: LogProjetoWhereInput
  }

  /**
   * LogProjeto upsert
   */
  export type LogProjetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * The filter to search for the LogProjeto to update in case it exists.
     */
    where: LogProjetoWhereUniqueInput
    /**
     * In case the LogProjeto found by the `where` argument doesn't exist, create a new LogProjeto with this data.
     */
    create: XOR<LogProjetoCreateInput, LogProjetoUncheckedCreateInput>
    /**
     * In case the LogProjeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogProjetoUpdateInput, LogProjetoUncheckedUpdateInput>
  }

  /**
   * LogProjeto delete
   */
  export type LogProjetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
    /**
     * Filter which LogProjeto to delete.
     */
    where: LogProjetoWhereUniqueInput
  }

  /**
   * LogProjeto deleteMany
   */
  export type LogProjetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogProjetos to delete
     */
    where?: LogProjetoWhereInput
  }

  /**
   * LogProjeto without action
   */
  export type LogProjetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogProjeto
     */
    select?: LogProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogProjetoInclude<ExtArgs> | null
  }


  /**
   * Model Deployment
   */

  export type AggregateDeployment = {
    _count: DeploymentCountAggregateOutputType | null
    _min: DeploymentMinAggregateOutputType | null
    _max: DeploymentMaxAggregateOutputType | null
  }

  export type DeploymentMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    modelSelected: string | null
    licensing: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeploymentMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    modelSelected: string | null
    licensing: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeploymentCountAggregateOutputType = {
    id: number
    clientId: number
    modelSelected: number
    licensing: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeploymentMinAggregateInputType = {
    id?: true
    clientId?: true
    modelSelected?: true
    licensing?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeploymentMaxAggregateInputType = {
    id?: true
    clientId?: true
    modelSelected?: true
    licensing?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeploymentCountAggregateInputType = {
    id?: true
    clientId?: true
    modelSelected?: true
    licensing?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeploymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deployment to aggregate.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deployments
    **/
    _count?: true | DeploymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentMaxAggregateInputType
  }

  export type GetDeploymentAggregateType<T extends DeploymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDeployment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeployment[P]>
      : GetScalarType<T[P], AggregateDeployment[P]>
  }




  export type DeploymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithAggregationInput | DeploymentOrderByWithAggregationInput[]
    by: DeploymentScalarFieldEnum[] | DeploymentScalarFieldEnum
    having?: DeploymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentCountAggregateInputType | true
    _min?: DeploymentMinAggregateInputType
    _max?: DeploymentMaxAggregateInputType
  }

  export type DeploymentGroupByOutputType = {
    id: string
    clientId: string
    modelSelected: string
    licensing: string
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeploymentCountAggregateOutputType | null
    _min: DeploymentMinAggregateOutputType | null
    _max: DeploymentMaxAggregateOutputType | null
  }

  type GetDeploymentGroupByPayload<T extends DeploymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    modelSelected?: boolean
    licensing?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    decisions?: boolean | Deployment$decisionsArgs<ExtArgs>
    _count?: boolean | DeploymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deployment"]>

  export type DeploymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    modelSelected?: boolean
    licensing?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deployment"]>

  export type DeploymentSelectScalar = {
    id?: boolean
    clientId?: boolean
    modelSelected?: boolean
    licensing?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeploymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    decisions?: boolean | Deployment$decisionsArgs<ExtArgs>
    _count?: boolean | DeploymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeploymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $DeploymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deployment"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      decisions: Prisma.$DecisionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      modelSelected: string
      licensing: string
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deployment"]>
    composites: {}
  }

  type DeploymentGetPayload<S extends boolean | null | undefined | DeploymentDefaultArgs> = $Result.GetResult<Prisma.$DeploymentPayload, S>

  type DeploymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentCountAggregateInputType | true
    }

  export interface DeploymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deployment'], meta: { name: 'Deployment' } }
    /**
     * Find zero or one Deployment that matches the filter.
     * @param {DeploymentFindUniqueArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentFindUniqueArgs>(args: SelectSubset<T, DeploymentFindUniqueArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deployment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentFindUniqueOrThrowArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deployment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindFirstArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentFindFirstArgs>(args?: SelectSubset<T, DeploymentFindFirstArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deployment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindFirstOrThrowArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deployments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deployments
     * const deployments = await prisma.deployment.findMany()
     * 
     * // Get first 10 Deployments
     * const deployments = await prisma.deployment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentWithIdOnly = await prisma.deployment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentFindManyArgs>(args?: SelectSubset<T, DeploymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deployment.
     * @param {DeploymentCreateArgs} args - Arguments to create a Deployment.
     * @example
     * // Create one Deployment
     * const Deployment = await prisma.deployment.create({
     *   data: {
     *     // ... data to create a Deployment
     *   }
     * })
     * 
     */
    create<T extends DeploymentCreateArgs>(args: SelectSubset<T, DeploymentCreateArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deployments.
     * @param {DeploymentCreateManyArgs} args - Arguments to create many Deployments.
     * @example
     * // Create many Deployments
     * const deployment = await prisma.deployment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentCreateManyArgs>(args?: SelectSubset<T, DeploymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deployments and returns the data saved in the database.
     * @param {DeploymentCreateManyAndReturnArgs} args - Arguments to create many Deployments.
     * @example
     * // Create many Deployments
     * const deployment = await prisma.deployment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deployments and only return the `id`
     * const deploymentWithIdOnly = await prisma.deployment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deployment.
     * @param {DeploymentDeleteArgs} args - Arguments to delete one Deployment.
     * @example
     * // Delete one Deployment
     * const Deployment = await prisma.deployment.delete({
     *   where: {
     *     // ... filter to delete one Deployment
     *   }
     * })
     * 
     */
    delete<T extends DeploymentDeleteArgs>(args: SelectSubset<T, DeploymentDeleteArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deployment.
     * @param {DeploymentUpdateArgs} args - Arguments to update one Deployment.
     * @example
     * // Update one Deployment
     * const deployment = await prisma.deployment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentUpdateArgs>(args: SelectSubset<T, DeploymentUpdateArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deployments.
     * @param {DeploymentDeleteManyArgs} args - Arguments to filter Deployments to delete.
     * @example
     * // Delete a few Deployments
     * const { count } = await prisma.deployment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentDeleteManyArgs>(args?: SelectSubset<T, DeploymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deployments
     * const deployment = await prisma.deployment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentUpdateManyArgs>(args: SelectSubset<T, DeploymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deployment.
     * @param {DeploymentUpsertArgs} args - Arguments to update or create a Deployment.
     * @example
     * // Update or create a Deployment
     * const deployment = await prisma.deployment.upsert({
     *   create: {
     *     // ... data to create a Deployment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deployment we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentUpsertArgs>(args: SelectSubset<T, DeploymentUpsertArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentCountArgs} args - Arguments to filter Deployments to count.
     * @example
     * // Count the number of Deployments
     * const count = await prisma.deployment.count({
     *   where: {
     *     // ... the filter for the Deployments we want to count
     *   }
     * })
    **/
    count<T extends DeploymentCountArgs>(
      args?: Subset<T, DeploymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentAggregateArgs>(args: Subset<T, DeploymentAggregateArgs>): Prisma.PrismaPromise<GetDeploymentAggregateType<T>>

    /**
     * Group by Deployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deployment model
   */
  readonly fields: DeploymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deployment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    decisions<T extends Deployment$decisionsArgs<ExtArgs> = {}>(args?: Subset<T, Deployment$decisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deployment model
   */ 
  interface DeploymentFieldRefs {
    readonly id: FieldRef<"Deployment", 'String'>
    readonly clientId: FieldRef<"Deployment", 'String'>
    readonly modelSelected: FieldRef<"Deployment", 'String'>
    readonly licensing: FieldRef<"Deployment", 'String'>
    readonly status: FieldRef<"Deployment", 'String'>
    readonly notes: FieldRef<"Deployment", 'String'>
    readonly createdAt: FieldRef<"Deployment", 'DateTime'>
    readonly updatedAt: FieldRef<"Deployment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deployment findUnique
   */
  export type DeploymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment findUniqueOrThrow
   */
  export type DeploymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment findFirst
   */
  export type DeploymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deployments.
     */
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment findFirstOrThrow
   */
  export type DeploymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deployments.
     */
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment findMany
   */
  export type DeploymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployments to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment create
   */
  export type DeploymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Deployment.
     */
    data: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
  }

  /**
   * Deployment createMany
   */
  export type DeploymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deployments.
     */
    data: DeploymentCreateManyInput | DeploymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deployment createManyAndReturn
   */
  export type DeploymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deployments.
     */
    data: DeploymentCreateManyInput | DeploymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deployment update
   */
  export type DeploymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Deployment.
     */
    data: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
    /**
     * Choose, which Deployment to update.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment updateMany
   */
  export type DeploymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deployments.
     */
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyInput>
    /**
     * Filter which Deployments to update
     */
    where?: DeploymentWhereInput
  }

  /**
   * Deployment upsert
   */
  export type DeploymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Deployment to update in case it exists.
     */
    where: DeploymentWhereUniqueInput
    /**
     * In case the Deployment found by the `where` argument doesn't exist, create a new Deployment with this data.
     */
    create: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
    /**
     * In case the Deployment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
  }

  /**
   * Deployment delete
   */
  export type DeploymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter which Deployment to delete.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment deleteMany
   */
  export type DeploymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deployments to delete
     */
    where?: DeploymentWhereInput
  }

  /**
   * Deployment.decisions
   */
  export type Deployment$decisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DecisionLog
     */
    select?: DecisionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionLogInclude<ExtArgs> | null
    where?: DecisionLogWhereInput
    orderBy?: DecisionLogOrderByWithRelationInput | DecisionLogOrderByWithRelationInput[]
    cursor?: DecisionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionLogScalarFieldEnum | DecisionLogScalarFieldEnum[]
  }

  /**
   * Deployment without action
   */
  export type DeploymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
  }


  /**
   * Model Levantamento
   */

  export type AggregateLevantamento = {
    _count: LevantamentoCountAggregateOutputType | null
    _avg: LevantamentoAvgAggregateOutputType | null
    _sum: LevantamentoSumAggregateOutputType | null
    _min: LevantamentoMinAggregateOutputType | null
    _max: LevantamentoMaxAggregateOutputType | null
  }

  export type LevantamentoAvgAggregateOutputType = {
    tempoEstimado: number | null
  }

  export type LevantamentoSumAggregateOutputType = {
    tempoEstimado: number | null
  }

  export type LevantamentoMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    categoria: string | null
    criticidade: string | null
    tempoEstimado: number | null
    selecionado: boolean | null
    observacoes: string | null
  }

  export type LevantamentoMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    categoria: string | null
    criticidade: string | null
    tempoEstimado: number | null
    selecionado: boolean | null
    observacoes: string | null
  }

  export type LevantamentoCountAggregateOutputType = {
    id: number
    projetoId: number
    nome: number
    categoria: number
    criticidade: number
    tempoEstimado: number
    selecionado: number
    observacoes: number
    _all: number
  }


  export type LevantamentoAvgAggregateInputType = {
    tempoEstimado?: true
  }

  export type LevantamentoSumAggregateInputType = {
    tempoEstimado?: true
  }

  export type LevantamentoMinAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    categoria?: true
    criticidade?: true
    tempoEstimado?: true
    selecionado?: true
    observacoes?: true
  }

  export type LevantamentoMaxAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    categoria?: true
    criticidade?: true
    tempoEstimado?: true
    selecionado?: true
    observacoes?: true
  }

  export type LevantamentoCountAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    categoria?: true
    criticidade?: true
    tempoEstimado?: true
    selecionado?: true
    observacoes?: true
    _all?: true
  }

  export type LevantamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levantamento to aggregate.
     */
    where?: LevantamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levantamentos to fetch.
     */
    orderBy?: LevantamentoOrderByWithRelationInput | LevantamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevantamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levantamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levantamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levantamentos
    **/
    _count?: true | LevantamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevantamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevantamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevantamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevantamentoMaxAggregateInputType
  }

  export type GetLevantamentoAggregateType<T extends LevantamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateLevantamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevantamento[P]>
      : GetScalarType<T[P], AggregateLevantamento[P]>
  }




  export type LevantamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevantamentoWhereInput
    orderBy?: LevantamentoOrderByWithAggregationInput | LevantamentoOrderByWithAggregationInput[]
    by: LevantamentoScalarFieldEnum[] | LevantamentoScalarFieldEnum
    having?: LevantamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevantamentoCountAggregateInputType | true
    _avg?: LevantamentoAvgAggregateInputType
    _sum?: LevantamentoSumAggregateInputType
    _min?: LevantamentoMinAggregateInputType
    _max?: LevantamentoMaxAggregateInputType
  }

  export type LevantamentoGroupByOutputType = {
    id: string
    projetoId: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado: boolean
    observacoes: string | null
    _count: LevantamentoCountAggregateOutputType | null
    _avg: LevantamentoAvgAggregateOutputType | null
    _sum: LevantamentoSumAggregateOutputType | null
    _min: LevantamentoMinAggregateOutputType | null
    _max: LevantamentoMaxAggregateOutputType | null
  }

  type GetLevantamentoGroupByPayload<T extends LevantamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevantamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevantamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevantamentoGroupByOutputType[P]>
            : GetScalarType<T[P], LevantamentoGroupByOutputType[P]>
        }
      >
    >


  export type LevantamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    categoria?: boolean
    criticidade?: boolean
    tempoEstimado?: boolean
    selecionado?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levantamento"]>

  export type LevantamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    categoria?: boolean
    criticidade?: boolean
    tempoEstimado?: boolean
    selecionado?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levantamento"]>

  export type LevantamentoSelectScalar = {
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    categoria?: boolean
    criticidade?: boolean
    tempoEstimado?: boolean
    selecionado?: boolean
    observacoes?: boolean
  }

  export type LevantamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type LevantamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $LevantamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Levantamento"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      nome: string
      categoria: string
      criticidade: string
      tempoEstimado: number
      selecionado: boolean
      observacoes: string | null
    }, ExtArgs["result"]["levantamento"]>
    composites: {}
  }

  type LevantamentoGetPayload<S extends boolean | null | undefined | LevantamentoDefaultArgs> = $Result.GetResult<Prisma.$LevantamentoPayload, S>

  type LevantamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LevantamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LevantamentoCountAggregateInputType | true
    }

  export interface LevantamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Levantamento'], meta: { name: 'Levantamento' } }
    /**
     * Find zero or one Levantamento that matches the filter.
     * @param {LevantamentoFindUniqueArgs} args - Arguments to find a Levantamento
     * @example
     * // Get one Levantamento
     * const levantamento = await prisma.levantamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevantamentoFindUniqueArgs>(args: SelectSubset<T, LevantamentoFindUniqueArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Levantamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LevantamentoFindUniqueOrThrowArgs} args - Arguments to find a Levantamento
     * @example
     * // Get one Levantamento
     * const levantamento = await prisma.levantamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevantamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, LevantamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Levantamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoFindFirstArgs} args - Arguments to find a Levantamento
     * @example
     * // Get one Levantamento
     * const levantamento = await prisma.levantamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevantamentoFindFirstArgs>(args?: SelectSubset<T, LevantamentoFindFirstArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Levantamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoFindFirstOrThrowArgs} args - Arguments to find a Levantamento
     * @example
     * // Get one Levantamento
     * const levantamento = await prisma.levantamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevantamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, LevantamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Levantamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levantamentos
     * const levantamentos = await prisma.levantamento.findMany()
     * 
     * // Get first 10 Levantamentos
     * const levantamentos = await prisma.levantamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levantamentoWithIdOnly = await prisma.levantamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevantamentoFindManyArgs>(args?: SelectSubset<T, LevantamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Levantamento.
     * @param {LevantamentoCreateArgs} args - Arguments to create a Levantamento.
     * @example
     * // Create one Levantamento
     * const Levantamento = await prisma.levantamento.create({
     *   data: {
     *     // ... data to create a Levantamento
     *   }
     * })
     * 
     */
    create<T extends LevantamentoCreateArgs>(args: SelectSubset<T, LevantamentoCreateArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Levantamentos.
     * @param {LevantamentoCreateManyArgs} args - Arguments to create many Levantamentos.
     * @example
     * // Create many Levantamentos
     * const levantamento = await prisma.levantamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevantamentoCreateManyArgs>(args?: SelectSubset<T, LevantamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levantamentos and returns the data saved in the database.
     * @param {LevantamentoCreateManyAndReturnArgs} args - Arguments to create many Levantamentos.
     * @example
     * // Create many Levantamentos
     * const levantamento = await prisma.levantamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levantamentos and only return the `id`
     * const levantamentoWithIdOnly = await prisma.levantamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevantamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, LevantamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Levantamento.
     * @param {LevantamentoDeleteArgs} args - Arguments to delete one Levantamento.
     * @example
     * // Delete one Levantamento
     * const Levantamento = await prisma.levantamento.delete({
     *   where: {
     *     // ... filter to delete one Levantamento
     *   }
     * })
     * 
     */
    delete<T extends LevantamentoDeleteArgs>(args: SelectSubset<T, LevantamentoDeleteArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Levantamento.
     * @param {LevantamentoUpdateArgs} args - Arguments to update one Levantamento.
     * @example
     * // Update one Levantamento
     * const levantamento = await prisma.levantamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevantamentoUpdateArgs>(args: SelectSubset<T, LevantamentoUpdateArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Levantamentos.
     * @param {LevantamentoDeleteManyArgs} args - Arguments to filter Levantamentos to delete.
     * @example
     * // Delete a few Levantamentos
     * const { count } = await prisma.levantamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevantamentoDeleteManyArgs>(args?: SelectSubset<T, LevantamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levantamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levantamentos
     * const levantamento = await prisma.levantamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevantamentoUpdateManyArgs>(args: SelectSubset<T, LevantamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Levantamento.
     * @param {LevantamentoUpsertArgs} args - Arguments to update or create a Levantamento.
     * @example
     * // Update or create a Levantamento
     * const levantamento = await prisma.levantamento.upsert({
     *   create: {
     *     // ... data to create a Levantamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Levantamento we want to update
     *   }
     * })
     */
    upsert<T extends LevantamentoUpsertArgs>(args: SelectSubset<T, LevantamentoUpsertArgs<ExtArgs>>): Prisma__LevantamentoClient<$Result.GetResult<Prisma.$LevantamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Levantamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoCountArgs} args - Arguments to filter Levantamentos to count.
     * @example
     * // Count the number of Levantamentos
     * const count = await prisma.levantamento.count({
     *   where: {
     *     // ... the filter for the Levantamentos we want to count
     *   }
     * })
    **/
    count<T extends LevantamentoCountArgs>(
      args?: Subset<T, LevantamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevantamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Levantamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevantamentoAggregateArgs>(args: Subset<T, LevantamentoAggregateArgs>): Prisma.PrismaPromise<GetLevantamentoAggregateType<T>>

    /**
     * Group by Levantamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevantamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevantamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevantamentoGroupByArgs['orderBy'] }
        : { orderBy?: LevantamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevantamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevantamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Levantamento model
   */
  readonly fields: LevantamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Levantamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevantamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Levantamento model
   */ 
  interface LevantamentoFieldRefs {
    readonly id: FieldRef<"Levantamento", 'String'>
    readonly projetoId: FieldRef<"Levantamento", 'String'>
    readonly nome: FieldRef<"Levantamento", 'String'>
    readonly categoria: FieldRef<"Levantamento", 'String'>
    readonly criticidade: FieldRef<"Levantamento", 'String'>
    readonly tempoEstimado: FieldRef<"Levantamento", 'Int'>
    readonly selecionado: FieldRef<"Levantamento", 'Boolean'>
    readonly observacoes: FieldRef<"Levantamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Levantamento findUnique
   */
  export type LevantamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * Filter, which Levantamento to fetch.
     */
    where: LevantamentoWhereUniqueInput
  }

  /**
   * Levantamento findUniqueOrThrow
   */
  export type LevantamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * Filter, which Levantamento to fetch.
     */
    where: LevantamentoWhereUniqueInput
  }

  /**
   * Levantamento findFirst
   */
  export type LevantamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * Filter, which Levantamento to fetch.
     */
    where?: LevantamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levantamentos to fetch.
     */
    orderBy?: LevantamentoOrderByWithRelationInput | LevantamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levantamentos.
     */
    cursor?: LevantamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levantamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levantamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levantamentos.
     */
    distinct?: LevantamentoScalarFieldEnum | LevantamentoScalarFieldEnum[]
  }

  /**
   * Levantamento findFirstOrThrow
   */
  export type LevantamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * Filter, which Levantamento to fetch.
     */
    where?: LevantamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levantamentos to fetch.
     */
    orderBy?: LevantamentoOrderByWithRelationInput | LevantamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levantamentos.
     */
    cursor?: LevantamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levantamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levantamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levantamentos.
     */
    distinct?: LevantamentoScalarFieldEnum | LevantamentoScalarFieldEnum[]
  }

  /**
   * Levantamento findMany
   */
  export type LevantamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * Filter, which Levantamentos to fetch.
     */
    where?: LevantamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levantamentos to fetch.
     */
    orderBy?: LevantamentoOrderByWithRelationInput | LevantamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levantamentos.
     */
    cursor?: LevantamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levantamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levantamentos.
     */
    skip?: number
    distinct?: LevantamentoScalarFieldEnum | LevantamentoScalarFieldEnum[]
  }

  /**
   * Levantamento create
   */
  export type LevantamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Levantamento.
     */
    data: XOR<LevantamentoCreateInput, LevantamentoUncheckedCreateInput>
  }

  /**
   * Levantamento createMany
   */
  export type LevantamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levantamentos.
     */
    data: LevantamentoCreateManyInput | LevantamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Levantamento createManyAndReturn
   */
  export type LevantamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Levantamentos.
     */
    data: LevantamentoCreateManyInput | LevantamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Levantamento update
   */
  export type LevantamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Levantamento.
     */
    data: XOR<LevantamentoUpdateInput, LevantamentoUncheckedUpdateInput>
    /**
     * Choose, which Levantamento to update.
     */
    where: LevantamentoWhereUniqueInput
  }

  /**
   * Levantamento updateMany
   */
  export type LevantamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levantamentos.
     */
    data: XOR<LevantamentoUpdateManyMutationInput, LevantamentoUncheckedUpdateManyInput>
    /**
     * Filter which Levantamentos to update
     */
    where?: LevantamentoWhereInput
  }

  /**
   * Levantamento upsert
   */
  export type LevantamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Levantamento to update in case it exists.
     */
    where: LevantamentoWhereUniqueInput
    /**
     * In case the Levantamento found by the `where` argument doesn't exist, create a new Levantamento with this data.
     */
    create: XOR<LevantamentoCreateInput, LevantamentoUncheckedCreateInput>
    /**
     * In case the Levantamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevantamentoUpdateInput, LevantamentoUncheckedUpdateInput>
  }

  /**
   * Levantamento delete
   */
  export type LevantamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
    /**
     * Filter which Levantamento to delete.
     */
    where: LevantamentoWhereUniqueInput
  }

  /**
   * Levantamento deleteMany
   */
  export type LevantamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levantamentos to delete
     */
    where?: LevantamentoWhereInput
  }

  /**
   * Levantamento without action
   */
  export type LevantamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Levantamento
     */
    select?: LevantamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevantamentoInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    caixaMB: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    caixaMB: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    departamento: string | null
    cargo: string | null
    email: string | null
    caixaMB: number | null
    officeLocal: boolean | null
    migrarEmail: boolean | null
    oneDrive: boolean | null
    sharePoint: boolean | null
    teams: boolean | null
    criadoEm: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    departamento: string | null
    cargo: string | null
    email: string | null
    caixaMB: number | null
    officeLocal: boolean | null
    migrarEmail: boolean | null
    oneDrive: boolean | null
    sharePoint: boolean | null
    teams: boolean | null
    criadoEm: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    projetoId: number
    nome: number
    departamento: number
    cargo: number
    email: number
    caixaMB: number
    officeLocal: number
    migrarEmail: number
    oneDrive: number
    sharePoint: number
    teams: number
    criadoEm: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    caixaMB?: true
  }

  export type UsuarioSumAggregateInputType = {
    caixaMB?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    departamento?: true
    cargo?: true
    email?: true
    caixaMB?: true
    officeLocal?: true
    migrarEmail?: true
    oneDrive?: true
    sharePoint?: true
    teams?: true
    criadoEm?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    departamento?: true
    cargo?: true
    email?: true
    caixaMB?: true
    officeLocal?: true
    migrarEmail?: true
    oneDrive?: true
    sharePoint?: true
    teams?: true
    criadoEm?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    departamento?: true
    cargo?: true
    email?: true
    caixaMB?: true
    officeLocal?: true
    migrarEmail?: true
    oneDrive?: true
    sharePoint?: true
    teams?: true
    criadoEm?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    projetoId: string
    nome: string
    departamento: string | null
    cargo: string | null
    email: string
    caixaMB: number | null
    officeLocal: boolean
    migrarEmail: boolean
    oneDrive: boolean
    sharePoint: boolean
    teams: boolean
    criadoEm: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    departamento?: boolean
    cargo?: boolean
    email?: boolean
    caixaMB?: boolean
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    departamento?: boolean
    cargo?: boolean
    email?: boolean
    caixaMB?: boolean
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    departamento?: boolean
    cargo?: boolean
    email?: boolean
    caixaMB?: boolean
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      nome: string
      departamento: string | null
      cargo: string | null
      email: string
      caixaMB: number | null
      officeLocal: boolean
      migrarEmail: boolean
      oneDrive: boolean
      sharePoint: boolean
      teams: boolean
      criadoEm: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly projetoId: FieldRef<"Usuario", 'String'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly departamento: FieldRef<"Usuario", 'String'>
    readonly cargo: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly caixaMB: FieldRef<"Usuario", 'Int'>
    readonly officeLocal: FieldRef<"Usuario", 'Boolean'>
    readonly migrarEmail: FieldRef<"Usuario", 'Boolean'>
    readonly oneDrive: FieldRef<"Usuario", 'Boolean'>
    readonly sharePoint: FieldRef<"Usuario", 'Boolean'>
    readonly teams: FieldRef<"Usuario", 'Boolean'>
    readonly criadoEm: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model EmailConfig
   */

  export type AggregateEmailConfig = {
    _count: EmailConfigCountAggregateOutputType | null
    _avg: EmailConfigAvgAggregateOutputType | null
    _sum: EmailConfigSumAggregateOutputType | null
    _min: EmailConfigMinAggregateOutputType | null
    _max: EmailConfigMaxAggregateOutputType | null
  }

  export type EmailConfigAvgAggregateOutputType = {
    volumeTotalMB: number | null
  }

  export type EmailConfigSumAggregateOutputType = {
    volumeTotalMB: number | null
  }

  export type EmailConfigMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    plataformaOrigem: string | null
    metodologia: string | null
    janelaMigracao: string | null
    volumeTotalMB: number | null
    migrarCalendarios: boolean | null
    migrarContatos: boolean | null
    backupPst: boolean | null
    caixasCompartilhadas: string | null
    gruposDistribuicao: string | null
    observacoes: string | null
  }

  export type EmailConfigMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    plataformaOrigem: string | null
    metodologia: string | null
    janelaMigracao: string | null
    volumeTotalMB: number | null
    migrarCalendarios: boolean | null
    migrarContatos: boolean | null
    backupPst: boolean | null
    caixasCompartilhadas: string | null
    gruposDistribuicao: string | null
    observacoes: string | null
  }

  export type EmailConfigCountAggregateOutputType = {
    id: number
    projetoId: number
    plataformaOrigem: number
    metodologia: number
    janelaMigracao: number
    volumeTotalMB: number
    migrarCalendarios: number
    migrarContatos: number
    backupPst: number
    caixasCompartilhadas: number
    gruposDistribuicao: number
    observacoes: number
    _all: number
  }


  export type EmailConfigAvgAggregateInputType = {
    volumeTotalMB?: true
  }

  export type EmailConfigSumAggregateInputType = {
    volumeTotalMB?: true
  }

  export type EmailConfigMinAggregateInputType = {
    id?: true
    projetoId?: true
    plataformaOrigem?: true
    metodologia?: true
    janelaMigracao?: true
    volumeTotalMB?: true
    migrarCalendarios?: true
    migrarContatos?: true
    backupPst?: true
    caixasCompartilhadas?: true
    gruposDistribuicao?: true
    observacoes?: true
  }

  export type EmailConfigMaxAggregateInputType = {
    id?: true
    projetoId?: true
    plataformaOrigem?: true
    metodologia?: true
    janelaMigracao?: true
    volumeTotalMB?: true
    migrarCalendarios?: true
    migrarContatos?: true
    backupPst?: true
    caixasCompartilhadas?: true
    gruposDistribuicao?: true
    observacoes?: true
  }

  export type EmailConfigCountAggregateInputType = {
    id?: true
    projetoId?: true
    plataformaOrigem?: true
    metodologia?: true
    janelaMigracao?: true
    volumeTotalMB?: true
    migrarCalendarios?: true
    migrarContatos?: true
    backupPst?: true
    caixasCompartilhadas?: true
    gruposDistribuicao?: true
    observacoes?: true
    _all?: true
  }

  export type EmailConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailConfig to aggregate.
     */
    where?: EmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigs to fetch.
     */
    orderBy?: EmailConfigOrderByWithRelationInput | EmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailConfigs
    **/
    _count?: true | EmailConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailConfigMaxAggregateInputType
  }

  export type GetEmailConfigAggregateType<T extends EmailConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailConfig[P]>
      : GetScalarType<T[P], AggregateEmailConfig[P]>
  }




  export type EmailConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailConfigWhereInput
    orderBy?: EmailConfigOrderByWithAggregationInput | EmailConfigOrderByWithAggregationInput[]
    by: EmailConfigScalarFieldEnum[] | EmailConfigScalarFieldEnum
    having?: EmailConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailConfigCountAggregateInputType | true
    _avg?: EmailConfigAvgAggregateInputType
    _sum?: EmailConfigSumAggregateInputType
    _min?: EmailConfigMinAggregateInputType
    _max?: EmailConfigMaxAggregateInputType
  }

  export type EmailConfigGroupByOutputType = {
    id: string
    projetoId: string
    plataformaOrigem: string
    metodologia: string | null
    janelaMigracao: string | null
    volumeTotalMB: number | null
    migrarCalendarios: boolean
    migrarContatos: boolean
    backupPst: boolean
    caixasCompartilhadas: string | null
    gruposDistribuicao: string | null
    observacoes: string | null
    _count: EmailConfigCountAggregateOutputType | null
    _avg: EmailConfigAvgAggregateOutputType | null
    _sum: EmailConfigSumAggregateOutputType | null
    _min: EmailConfigMinAggregateOutputType | null
    _max: EmailConfigMaxAggregateOutputType | null
  }

  type GetEmailConfigGroupByPayload<T extends EmailConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailConfigGroupByOutputType[P]>
            : GetScalarType<T[P], EmailConfigGroupByOutputType[P]>
        }
      >
    >


  export type EmailConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    plataformaOrigem?: boolean
    metodologia?: boolean
    janelaMigracao?: boolean
    volumeTotalMB?: boolean
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: boolean
    gruposDistribuicao?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailConfig"]>

  export type EmailConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    plataformaOrigem?: boolean
    metodologia?: boolean
    janelaMigracao?: boolean
    volumeTotalMB?: boolean
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: boolean
    gruposDistribuicao?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailConfig"]>

  export type EmailConfigSelectScalar = {
    id?: boolean
    projetoId?: boolean
    plataformaOrigem?: boolean
    metodologia?: boolean
    janelaMigracao?: boolean
    volumeTotalMB?: boolean
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: boolean
    gruposDistribuicao?: boolean
    observacoes?: boolean
  }

  export type EmailConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type EmailConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $EmailConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailConfig"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      plataformaOrigem: string
      metodologia: string | null
      janelaMigracao: string | null
      volumeTotalMB: number | null
      migrarCalendarios: boolean
      migrarContatos: boolean
      backupPst: boolean
      caixasCompartilhadas: string | null
      gruposDistribuicao: string | null
      observacoes: string | null
    }, ExtArgs["result"]["emailConfig"]>
    composites: {}
  }

  type EmailConfigGetPayload<S extends boolean | null | undefined | EmailConfigDefaultArgs> = $Result.GetResult<Prisma.$EmailConfigPayload, S>

  type EmailConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailConfigCountAggregateInputType | true
    }

  export interface EmailConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailConfig'], meta: { name: 'EmailConfig' } }
    /**
     * Find zero or one EmailConfig that matches the filter.
     * @param {EmailConfigFindUniqueArgs} args - Arguments to find a EmailConfig
     * @example
     * // Get one EmailConfig
     * const emailConfig = await prisma.emailConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailConfigFindUniqueArgs>(args: SelectSubset<T, EmailConfigFindUniqueArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailConfigFindUniqueOrThrowArgs} args - Arguments to find a EmailConfig
     * @example
     * // Get one EmailConfig
     * const emailConfig = await prisma.emailConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigFindFirstArgs} args - Arguments to find a EmailConfig
     * @example
     * // Get one EmailConfig
     * const emailConfig = await prisma.emailConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailConfigFindFirstArgs>(args?: SelectSubset<T, EmailConfigFindFirstArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigFindFirstOrThrowArgs} args - Arguments to find a EmailConfig
     * @example
     * // Get one EmailConfig
     * const emailConfig = await prisma.emailConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailConfigs
     * const emailConfigs = await prisma.emailConfig.findMany()
     * 
     * // Get first 10 EmailConfigs
     * const emailConfigs = await prisma.emailConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailConfigWithIdOnly = await prisma.emailConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailConfigFindManyArgs>(args?: SelectSubset<T, EmailConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailConfig.
     * @param {EmailConfigCreateArgs} args - Arguments to create a EmailConfig.
     * @example
     * // Create one EmailConfig
     * const EmailConfig = await prisma.emailConfig.create({
     *   data: {
     *     // ... data to create a EmailConfig
     *   }
     * })
     * 
     */
    create<T extends EmailConfigCreateArgs>(args: SelectSubset<T, EmailConfigCreateArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailConfigs.
     * @param {EmailConfigCreateManyArgs} args - Arguments to create many EmailConfigs.
     * @example
     * // Create many EmailConfigs
     * const emailConfig = await prisma.emailConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailConfigCreateManyArgs>(args?: SelectSubset<T, EmailConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailConfigs and returns the data saved in the database.
     * @param {EmailConfigCreateManyAndReturnArgs} args - Arguments to create many EmailConfigs.
     * @example
     * // Create many EmailConfigs
     * const emailConfig = await prisma.emailConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailConfigs and only return the `id`
     * const emailConfigWithIdOnly = await prisma.emailConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailConfig.
     * @param {EmailConfigDeleteArgs} args - Arguments to delete one EmailConfig.
     * @example
     * // Delete one EmailConfig
     * const EmailConfig = await prisma.emailConfig.delete({
     *   where: {
     *     // ... filter to delete one EmailConfig
     *   }
     * })
     * 
     */
    delete<T extends EmailConfigDeleteArgs>(args: SelectSubset<T, EmailConfigDeleteArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailConfig.
     * @param {EmailConfigUpdateArgs} args - Arguments to update one EmailConfig.
     * @example
     * // Update one EmailConfig
     * const emailConfig = await prisma.emailConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailConfigUpdateArgs>(args: SelectSubset<T, EmailConfigUpdateArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailConfigs.
     * @param {EmailConfigDeleteManyArgs} args - Arguments to filter EmailConfigs to delete.
     * @example
     * // Delete a few EmailConfigs
     * const { count } = await prisma.emailConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailConfigDeleteManyArgs>(args?: SelectSubset<T, EmailConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailConfigs
     * const emailConfig = await prisma.emailConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailConfigUpdateManyArgs>(args: SelectSubset<T, EmailConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailConfig.
     * @param {EmailConfigUpsertArgs} args - Arguments to update or create a EmailConfig.
     * @example
     * // Update or create a EmailConfig
     * const emailConfig = await prisma.emailConfig.upsert({
     *   create: {
     *     // ... data to create a EmailConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailConfig we want to update
     *   }
     * })
     */
    upsert<T extends EmailConfigUpsertArgs>(args: SelectSubset<T, EmailConfigUpsertArgs<ExtArgs>>): Prisma__EmailConfigClient<$Result.GetResult<Prisma.$EmailConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigCountArgs} args - Arguments to filter EmailConfigs to count.
     * @example
     * // Count the number of EmailConfigs
     * const count = await prisma.emailConfig.count({
     *   where: {
     *     // ... the filter for the EmailConfigs we want to count
     *   }
     * })
    **/
    count<T extends EmailConfigCountArgs>(
      args?: Subset<T, EmailConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailConfigAggregateArgs>(args: Subset<T, EmailConfigAggregateArgs>): Prisma.PrismaPromise<GetEmailConfigAggregateType<T>>

    /**
     * Group by EmailConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailConfigGroupByArgs['orderBy'] }
        : { orderBy?: EmailConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailConfig model
   */
  readonly fields: EmailConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailConfig model
   */ 
  interface EmailConfigFieldRefs {
    readonly id: FieldRef<"EmailConfig", 'String'>
    readonly projetoId: FieldRef<"EmailConfig", 'String'>
    readonly plataformaOrigem: FieldRef<"EmailConfig", 'String'>
    readonly metodologia: FieldRef<"EmailConfig", 'String'>
    readonly janelaMigracao: FieldRef<"EmailConfig", 'String'>
    readonly volumeTotalMB: FieldRef<"EmailConfig", 'Int'>
    readonly migrarCalendarios: FieldRef<"EmailConfig", 'Boolean'>
    readonly migrarContatos: FieldRef<"EmailConfig", 'Boolean'>
    readonly backupPst: FieldRef<"EmailConfig", 'Boolean'>
    readonly caixasCompartilhadas: FieldRef<"EmailConfig", 'String'>
    readonly gruposDistribuicao: FieldRef<"EmailConfig", 'String'>
    readonly observacoes: FieldRef<"EmailConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailConfig findUnique
   */
  export type EmailConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * Filter, which EmailConfig to fetch.
     */
    where: EmailConfigWhereUniqueInput
  }

  /**
   * EmailConfig findUniqueOrThrow
   */
  export type EmailConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * Filter, which EmailConfig to fetch.
     */
    where: EmailConfigWhereUniqueInput
  }

  /**
   * EmailConfig findFirst
   */
  export type EmailConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * Filter, which EmailConfig to fetch.
     */
    where?: EmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigs to fetch.
     */
    orderBy?: EmailConfigOrderByWithRelationInput | EmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailConfigs.
     */
    cursor?: EmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailConfigs.
     */
    distinct?: EmailConfigScalarFieldEnum | EmailConfigScalarFieldEnum[]
  }

  /**
   * EmailConfig findFirstOrThrow
   */
  export type EmailConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * Filter, which EmailConfig to fetch.
     */
    where?: EmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigs to fetch.
     */
    orderBy?: EmailConfigOrderByWithRelationInput | EmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailConfigs.
     */
    cursor?: EmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailConfigs.
     */
    distinct?: EmailConfigScalarFieldEnum | EmailConfigScalarFieldEnum[]
  }

  /**
   * EmailConfig findMany
   */
  export type EmailConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * Filter, which EmailConfigs to fetch.
     */
    where?: EmailConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigs to fetch.
     */
    orderBy?: EmailConfigOrderByWithRelationInput | EmailConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailConfigs.
     */
    cursor?: EmailConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigs.
     */
    skip?: number
    distinct?: EmailConfigScalarFieldEnum | EmailConfigScalarFieldEnum[]
  }

  /**
   * EmailConfig create
   */
  export type EmailConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailConfig.
     */
    data: XOR<EmailConfigCreateInput, EmailConfigUncheckedCreateInput>
  }

  /**
   * EmailConfig createMany
   */
  export type EmailConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailConfigs.
     */
    data: EmailConfigCreateManyInput | EmailConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailConfig createManyAndReturn
   */
  export type EmailConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailConfigs.
     */
    data: EmailConfigCreateManyInput | EmailConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailConfig update
   */
  export type EmailConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailConfig.
     */
    data: XOR<EmailConfigUpdateInput, EmailConfigUncheckedUpdateInput>
    /**
     * Choose, which EmailConfig to update.
     */
    where: EmailConfigWhereUniqueInput
  }

  /**
   * EmailConfig updateMany
   */
  export type EmailConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailConfigs.
     */
    data: XOR<EmailConfigUpdateManyMutationInput, EmailConfigUncheckedUpdateManyInput>
    /**
     * Filter which EmailConfigs to update
     */
    where?: EmailConfigWhereInput
  }

  /**
   * EmailConfig upsert
   */
  export type EmailConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailConfig to update in case it exists.
     */
    where: EmailConfigWhereUniqueInput
    /**
     * In case the EmailConfig found by the `where` argument doesn't exist, create a new EmailConfig with this data.
     */
    create: XOR<EmailConfigCreateInput, EmailConfigUncheckedCreateInput>
    /**
     * In case the EmailConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailConfigUpdateInput, EmailConfigUncheckedUpdateInput>
  }

  /**
   * EmailConfig delete
   */
  export type EmailConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
    /**
     * Filter which EmailConfig to delete.
     */
    where: EmailConfigWhereUniqueInput
  }

  /**
   * EmailConfig deleteMany
   */
  export type EmailConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailConfigs to delete
     */
    where?: EmailConfigWhereInput
  }

  /**
   * EmailConfig without action
   */
  export type EmailConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfig
     */
    select?: EmailConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailConfigInclude<ExtArgs> | null
  }


  /**
   * Model SharePointSite
   */

  export type AggregateSharePointSite = {
    _count: SharePointSiteCountAggregateOutputType | null
    _avg: SharePointSiteAvgAggregateOutputType | null
    _sum: SharePointSiteSumAggregateOutputType | null
    _min: SharePointSiteMinAggregateOutputType | null
    _max: SharePointSiteMaxAggregateOutputType | null
  }

  export type SharePointSiteAvgAggregateOutputType = {
    volumeGB: number | null
  }

  export type SharePointSiteSumAggregateOutputType = {
    volumeGB: number | null
  }

  export type SharePointSiteMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    tipo: string | null
    proposito: string | null
    proprietarios: string | null
    membros: string | null
    nivelAcesso: string | null
    volumeGB: number | null
    pastaOrigem: string | null
  }

  export type SharePointSiteMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    tipo: string | null
    proposito: string | null
    proprietarios: string | null
    membros: string | null
    nivelAcesso: string | null
    volumeGB: number | null
    pastaOrigem: string | null
  }

  export type SharePointSiteCountAggregateOutputType = {
    id: number
    projetoId: number
    nome: number
    tipo: number
    proposito: number
    proprietarios: number
    membros: number
    nivelAcesso: number
    volumeGB: number
    pastaOrigem: number
    _all: number
  }


  export type SharePointSiteAvgAggregateInputType = {
    volumeGB?: true
  }

  export type SharePointSiteSumAggregateInputType = {
    volumeGB?: true
  }

  export type SharePointSiteMinAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    tipo?: true
    proposito?: true
    proprietarios?: true
    membros?: true
    nivelAcesso?: true
    volumeGB?: true
    pastaOrigem?: true
  }

  export type SharePointSiteMaxAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    tipo?: true
    proposito?: true
    proprietarios?: true
    membros?: true
    nivelAcesso?: true
    volumeGB?: true
    pastaOrigem?: true
  }

  export type SharePointSiteCountAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    tipo?: true
    proposito?: true
    proprietarios?: true
    membros?: true
    nivelAcesso?: true
    volumeGB?: true
    pastaOrigem?: true
    _all?: true
  }

  export type SharePointSiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharePointSite to aggregate.
     */
    where?: SharePointSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePointSites to fetch.
     */
    orderBy?: SharePointSiteOrderByWithRelationInput | SharePointSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharePointSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePointSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePointSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharePointSites
    **/
    _count?: true | SharePointSiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharePointSiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharePointSiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharePointSiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharePointSiteMaxAggregateInputType
  }

  export type GetSharePointSiteAggregateType<T extends SharePointSiteAggregateArgs> = {
        [P in keyof T & keyof AggregateSharePointSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharePointSite[P]>
      : GetScalarType<T[P], AggregateSharePointSite[P]>
  }




  export type SharePointSiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharePointSiteWhereInput
    orderBy?: SharePointSiteOrderByWithAggregationInput | SharePointSiteOrderByWithAggregationInput[]
    by: SharePointSiteScalarFieldEnum[] | SharePointSiteScalarFieldEnum
    having?: SharePointSiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharePointSiteCountAggregateInputType | true
    _avg?: SharePointSiteAvgAggregateInputType
    _sum?: SharePointSiteSumAggregateInputType
    _min?: SharePointSiteMinAggregateInputType
    _max?: SharePointSiteMaxAggregateInputType
  }

  export type SharePointSiteGroupByOutputType = {
    id: string
    projetoId: string
    nome: string
    tipo: string
    proposito: string | null
    proprietarios: string | null
    membros: string | null
    nivelAcesso: string | null
    volumeGB: number | null
    pastaOrigem: string | null
    _count: SharePointSiteCountAggregateOutputType | null
    _avg: SharePointSiteAvgAggregateOutputType | null
    _sum: SharePointSiteSumAggregateOutputType | null
    _min: SharePointSiteMinAggregateOutputType | null
    _max: SharePointSiteMaxAggregateOutputType | null
  }

  type GetSharePointSiteGroupByPayload<T extends SharePointSiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharePointSiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharePointSiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharePointSiteGroupByOutputType[P]>
            : GetScalarType<T[P], SharePointSiteGroupByOutputType[P]>
        }
      >
    >


  export type SharePointSiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    tipo?: boolean
    proposito?: boolean
    proprietarios?: boolean
    membros?: boolean
    nivelAcesso?: boolean
    volumeGB?: boolean
    pastaOrigem?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharePointSite"]>

  export type SharePointSiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    tipo?: boolean
    proposito?: boolean
    proprietarios?: boolean
    membros?: boolean
    nivelAcesso?: boolean
    volumeGB?: boolean
    pastaOrigem?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharePointSite"]>

  export type SharePointSiteSelectScalar = {
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    tipo?: boolean
    proposito?: boolean
    proprietarios?: boolean
    membros?: boolean
    nivelAcesso?: boolean
    volumeGB?: boolean
    pastaOrigem?: boolean
  }

  export type SharePointSiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type SharePointSiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $SharePointSitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharePointSite"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      nome: string
      tipo: string
      proposito: string | null
      proprietarios: string | null
      membros: string | null
      nivelAcesso: string | null
      volumeGB: number | null
      pastaOrigem: string | null
    }, ExtArgs["result"]["sharePointSite"]>
    composites: {}
  }

  type SharePointSiteGetPayload<S extends boolean | null | undefined | SharePointSiteDefaultArgs> = $Result.GetResult<Prisma.$SharePointSitePayload, S>

  type SharePointSiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SharePointSiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SharePointSiteCountAggregateInputType | true
    }

  export interface SharePointSiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharePointSite'], meta: { name: 'SharePointSite' } }
    /**
     * Find zero or one SharePointSite that matches the filter.
     * @param {SharePointSiteFindUniqueArgs} args - Arguments to find a SharePointSite
     * @example
     * // Get one SharePointSite
     * const sharePointSite = await prisma.sharePointSite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharePointSiteFindUniqueArgs>(args: SelectSubset<T, SharePointSiteFindUniqueArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SharePointSite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SharePointSiteFindUniqueOrThrowArgs} args - Arguments to find a SharePointSite
     * @example
     * // Get one SharePointSite
     * const sharePointSite = await prisma.sharePointSite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharePointSiteFindUniqueOrThrowArgs>(args: SelectSubset<T, SharePointSiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SharePointSite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteFindFirstArgs} args - Arguments to find a SharePointSite
     * @example
     * // Get one SharePointSite
     * const sharePointSite = await prisma.sharePointSite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharePointSiteFindFirstArgs>(args?: SelectSubset<T, SharePointSiteFindFirstArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SharePointSite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteFindFirstOrThrowArgs} args - Arguments to find a SharePointSite
     * @example
     * // Get one SharePointSite
     * const sharePointSite = await prisma.sharePointSite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharePointSiteFindFirstOrThrowArgs>(args?: SelectSubset<T, SharePointSiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SharePointSites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharePointSites
     * const sharePointSites = await prisma.sharePointSite.findMany()
     * 
     * // Get first 10 SharePointSites
     * const sharePointSites = await prisma.sharePointSite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharePointSiteWithIdOnly = await prisma.sharePointSite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharePointSiteFindManyArgs>(args?: SelectSubset<T, SharePointSiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SharePointSite.
     * @param {SharePointSiteCreateArgs} args - Arguments to create a SharePointSite.
     * @example
     * // Create one SharePointSite
     * const SharePointSite = await prisma.sharePointSite.create({
     *   data: {
     *     // ... data to create a SharePointSite
     *   }
     * })
     * 
     */
    create<T extends SharePointSiteCreateArgs>(args: SelectSubset<T, SharePointSiteCreateArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SharePointSites.
     * @param {SharePointSiteCreateManyArgs} args - Arguments to create many SharePointSites.
     * @example
     * // Create many SharePointSites
     * const sharePointSite = await prisma.sharePointSite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharePointSiteCreateManyArgs>(args?: SelectSubset<T, SharePointSiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharePointSites and returns the data saved in the database.
     * @param {SharePointSiteCreateManyAndReturnArgs} args - Arguments to create many SharePointSites.
     * @example
     * // Create many SharePointSites
     * const sharePointSite = await prisma.sharePointSite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharePointSites and only return the `id`
     * const sharePointSiteWithIdOnly = await prisma.sharePointSite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharePointSiteCreateManyAndReturnArgs>(args?: SelectSubset<T, SharePointSiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SharePointSite.
     * @param {SharePointSiteDeleteArgs} args - Arguments to delete one SharePointSite.
     * @example
     * // Delete one SharePointSite
     * const SharePointSite = await prisma.sharePointSite.delete({
     *   where: {
     *     // ... filter to delete one SharePointSite
     *   }
     * })
     * 
     */
    delete<T extends SharePointSiteDeleteArgs>(args: SelectSubset<T, SharePointSiteDeleteArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SharePointSite.
     * @param {SharePointSiteUpdateArgs} args - Arguments to update one SharePointSite.
     * @example
     * // Update one SharePointSite
     * const sharePointSite = await prisma.sharePointSite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharePointSiteUpdateArgs>(args: SelectSubset<T, SharePointSiteUpdateArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SharePointSites.
     * @param {SharePointSiteDeleteManyArgs} args - Arguments to filter SharePointSites to delete.
     * @example
     * // Delete a few SharePointSites
     * const { count } = await prisma.sharePointSite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharePointSiteDeleteManyArgs>(args?: SelectSubset<T, SharePointSiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharePointSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharePointSites
     * const sharePointSite = await prisma.sharePointSite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharePointSiteUpdateManyArgs>(args: SelectSubset<T, SharePointSiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SharePointSite.
     * @param {SharePointSiteUpsertArgs} args - Arguments to update or create a SharePointSite.
     * @example
     * // Update or create a SharePointSite
     * const sharePointSite = await prisma.sharePointSite.upsert({
     *   create: {
     *     // ... data to create a SharePointSite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharePointSite we want to update
     *   }
     * })
     */
    upsert<T extends SharePointSiteUpsertArgs>(args: SelectSubset<T, SharePointSiteUpsertArgs<ExtArgs>>): Prisma__SharePointSiteClient<$Result.GetResult<Prisma.$SharePointSitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SharePointSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteCountArgs} args - Arguments to filter SharePointSites to count.
     * @example
     * // Count the number of SharePointSites
     * const count = await prisma.sharePointSite.count({
     *   where: {
     *     // ... the filter for the SharePointSites we want to count
     *   }
     * })
    **/
    count<T extends SharePointSiteCountArgs>(
      args?: Subset<T, SharePointSiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharePointSiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharePointSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharePointSiteAggregateArgs>(args: Subset<T, SharePointSiteAggregateArgs>): Prisma.PrismaPromise<GetSharePointSiteAggregateType<T>>

    /**
     * Group by SharePointSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePointSiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharePointSiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharePointSiteGroupByArgs['orderBy'] }
        : { orderBy?: SharePointSiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharePointSiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharePointSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharePointSite model
   */
  readonly fields: SharePointSiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharePointSite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharePointSiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharePointSite model
   */ 
  interface SharePointSiteFieldRefs {
    readonly id: FieldRef<"SharePointSite", 'String'>
    readonly projetoId: FieldRef<"SharePointSite", 'String'>
    readonly nome: FieldRef<"SharePointSite", 'String'>
    readonly tipo: FieldRef<"SharePointSite", 'String'>
    readonly proposito: FieldRef<"SharePointSite", 'String'>
    readonly proprietarios: FieldRef<"SharePointSite", 'String'>
    readonly membros: FieldRef<"SharePointSite", 'String'>
    readonly nivelAcesso: FieldRef<"SharePointSite", 'String'>
    readonly volumeGB: FieldRef<"SharePointSite", 'Float'>
    readonly pastaOrigem: FieldRef<"SharePointSite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SharePointSite findUnique
   */
  export type SharePointSiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * Filter, which SharePointSite to fetch.
     */
    where: SharePointSiteWhereUniqueInput
  }

  /**
   * SharePointSite findUniqueOrThrow
   */
  export type SharePointSiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * Filter, which SharePointSite to fetch.
     */
    where: SharePointSiteWhereUniqueInput
  }

  /**
   * SharePointSite findFirst
   */
  export type SharePointSiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * Filter, which SharePointSite to fetch.
     */
    where?: SharePointSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePointSites to fetch.
     */
    orderBy?: SharePointSiteOrderByWithRelationInput | SharePointSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharePointSites.
     */
    cursor?: SharePointSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePointSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePointSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharePointSites.
     */
    distinct?: SharePointSiteScalarFieldEnum | SharePointSiteScalarFieldEnum[]
  }

  /**
   * SharePointSite findFirstOrThrow
   */
  export type SharePointSiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * Filter, which SharePointSite to fetch.
     */
    where?: SharePointSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePointSites to fetch.
     */
    orderBy?: SharePointSiteOrderByWithRelationInput | SharePointSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharePointSites.
     */
    cursor?: SharePointSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePointSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePointSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharePointSites.
     */
    distinct?: SharePointSiteScalarFieldEnum | SharePointSiteScalarFieldEnum[]
  }

  /**
   * SharePointSite findMany
   */
  export type SharePointSiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * Filter, which SharePointSites to fetch.
     */
    where?: SharePointSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePointSites to fetch.
     */
    orderBy?: SharePointSiteOrderByWithRelationInput | SharePointSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharePointSites.
     */
    cursor?: SharePointSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePointSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePointSites.
     */
    skip?: number
    distinct?: SharePointSiteScalarFieldEnum | SharePointSiteScalarFieldEnum[]
  }

  /**
   * SharePointSite create
   */
  export type SharePointSiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * The data needed to create a SharePointSite.
     */
    data: XOR<SharePointSiteCreateInput, SharePointSiteUncheckedCreateInput>
  }

  /**
   * SharePointSite createMany
   */
  export type SharePointSiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharePointSites.
     */
    data: SharePointSiteCreateManyInput | SharePointSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharePointSite createManyAndReturn
   */
  export type SharePointSiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SharePointSites.
     */
    data: SharePointSiteCreateManyInput | SharePointSiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharePointSite update
   */
  export type SharePointSiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * The data needed to update a SharePointSite.
     */
    data: XOR<SharePointSiteUpdateInput, SharePointSiteUncheckedUpdateInput>
    /**
     * Choose, which SharePointSite to update.
     */
    where: SharePointSiteWhereUniqueInput
  }

  /**
   * SharePointSite updateMany
   */
  export type SharePointSiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharePointSites.
     */
    data: XOR<SharePointSiteUpdateManyMutationInput, SharePointSiteUncheckedUpdateManyInput>
    /**
     * Filter which SharePointSites to update
     */
    where?: SharePointSiteWhereInput
  }

  /**
   * SharePointSite upsert
   */
  export type SharePointSiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * The filter to search for the SharePointSite to update in case it exists.
     */
    where: SharePointSiteWhereUniqueInput
    /**
     * In case the SharePointSite found by the `where` argument doesn't exist, create a new SharePointSite with this data.
     */
    create: XOR<SharePointSiteCreateInput, SharePointSiteUncheckedCreateInput>
    /**
     * In case the SharePointSite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharePointSiteUpdateInput, SharePointSiteUncheckedUpdateInput>
  }

  /**
   * SharePointSite delete
   */
  export type SharePointSiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
    /**
     * Filter which SharePointSite to delete.
     */
    where: SharePointSiteWhereUniqueInput
  }

  /**
   * SharePointSite deleteMany
   */
  export type SharePointSiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharePointSites to delete
     */
    where?: SharePointSiteWhereInput
  }

  /**
   * SharePointSite without action
   */
  export type SharePointSiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharePointSite
     */
    select?: SharePointSiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharePointSiteInclude<ExtArgs> | null
  }


  /**
   * Model TeamsConfig
   */

  export type AggregateTeamsConfig = {
    _count: TeamsConfigCountAggregateOutputType | null
    _min: TeamsConfigMinAggregateOutputType | null
    _max: TeamsConfigMaxAggregateOutputType | null
  }

  export type TeamsConfigMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nomeEquipe: string | null
    tipoEquipe: string | null
    proposito: string | null
    proprietarios: string | null
    membrosIniciais: string | null
    canais: string | null
    recursos: string | null
    observacoes: string | null
  }

  export type TeamsConfigMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nomeEquipe: string | null
    tipoEquipe: string | null
    proposito: string | null
    proprietarios: string | null
    membrosIniciais: string | null
    canais: string | null
    recursos: string | null
    observacoes: string | null
  }

  export type TeamsConfigCountAggregateOutputType = {
    id: number
    projetoId: number
    nomeEquipe: number
    tipoEquipe: number
    proposito: number
    proprietarios: number
    membrosIniciais: number
    canais: number
    recursos: number
    observacoes: number
    _all: number
  }


  export type TeamsConfigMinAggregateInputType = {
    id?: true
    projetoId?: true
    nomeEquipe?: true
    tipoEquipe?: true
    proposito?: true
    proprietarios?: true
    membrosIniciais?: true
    canais?: true
    recursos?: true
    observacoes?: true
  }

  export type TeamsConfigMaxAggregateInputType = {
    id?: true
    projetoId?: true
    nomeEquipe?: true
    tipoEquipe?: true
    proposito?: true
    proprietarios?: true
    membrosIniciais?: true
    canais?: true
    recursos?: true
    observacoes?: true
  }

  export type TeamsConfigCountAggregateInputType = {
    id?: true
    projetoId?: true
    nomeEquipe?: true
    tipoEquipe?: true
    proposito?: true
    proprietarios?: true
    membrosIniciais?: true
    canais?: true
    recursos?: true
    observacoes?: true
    _all?: true
  }

  export type TeamsConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamsConfig to aggregate.
     */
    where?: TeamsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsConfigs to fetch.
     */
    orderBy?: TeamsConfigOrderByWithRelationInput | TeamsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamsConfigs
    **/
    _count?: true | TeamsConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamsConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamsConfigMaxAggregateInputType
  }

  export type GetTeamsConfigAggregateType<T extends TeamsConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamsConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamsConfig[P]>
      : GetScalarType<T[P], AggregateTeamsConfig[P]>
  }




  export type TeamsConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsConfigWhereInput
    orderBy?: TeamsConfigOrderByWithAggregationInput | TeamsConfigOrderByWithAggregationInput[]
    by: TeamsConfigScalarFieldEnum[] | TeamsConfigScalarFieldEnum
    having?: TeamsConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamsConfigCountAggregateInputType | true
    _min?: TeamsConfigMinAggregateInputType
    _max?: TeamsConfigMaxAggregateInputType
  }

  export type TeamsConfigGroupByOutputType = {
    id: string
    projetoId: string
    nomeEquipe: string | null
    tipoEquipe: string | null
    proposito: string | null
    proprietarios: string | null
    membrosIniciais: string | null
    canais: string | null
    recursos: string | null
    observacoes: string | null
    _count: TeamsConfigCountAggregateOutputType | null
    _min: TeamsConfigMinAggregateOutputType | null
    _max: TeamsConfigMaxAggregateOutputType | null
  }

  type GetTeamsConfigGroupByPayload<T extends TeamsConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamsConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamsConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamsConfigGroupByOutputType[P]>
            : GetScalarType<T[P], TeamsConfigGroupByOutputType[P]>
        }
      >
    >


  export type TeamsConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nomeEquipe?: boolean
    tipoEquipe?: boolean
    proposito?: boolean
    proprietarios?: boolean
    membrosIniciais?: boolean
    canais?: boolean
    recursos?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamsConfig"]>

  export type TeamsConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nomeEquipe?: boolean
    tipoEquipe?: boolean
    proposito?: boolean
    proprietarios?: boolean
    membrosIniciais?: boolean
    canais?: boolean
    recursos?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamsConfig"]>

  export type TeamsConfigSelectScalar = {
    id?: boolean
    projetoId?: boolean
    nomeEquipe?: boolean
    tipoEquipe?: boolean
    proposito?: boolean
    proprietarios?: boolean
    membrosIniciais?: boolean
    canais?: boolean
    recursos?: boolean
    observacoes?: boolean
  }

  export type TeamsConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type TeamsConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $TeamsConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamsConfig"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      nomeEquipe: string | null
      tipoEquipe: string | null
      proposito: string | null
      proprietarios: string | null
      membrosIniciais: string | null
      canais: string | null
      recursos: string | null
      observacoes: string | null
    }, ExtArgs["result"]["teamsConfig"]>
    composites: {}
  }

  type TeamsConfigGetPayload<S extends boolean | null | undefined | TeamsConfigDefaultArgs> = $Result.GetResult<Prisma.$TeamsConfigPayload, S>

  type TeamsConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamsConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamsConfigCountAggregateInputType | true
    }

  export interface TeamsConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamsConfig'], meta: { name: 'TeamsConfig' } }
    /**
     * Find zero or one TeamsConfig that matches the filter.
     * @param {TeamsConfigFindUniqueArgs} args - Arguments to find a TeamsConfig
     * @example
     * // Get one TeamsConfig
     * const teamsConfig = await prisma.teamsConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamsConfigFindUniqueArgs>(args: SelectSubset<T, TeamsConfigFindUniqueArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamsConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamsConfigFindUniqueOrThrowArgs} args - Arguments to find a TeamsConfig
     * @example
     * // Get one TeamsConfig
     * const teamsConfig = await prisma.teamsConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamsConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamsConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamsConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigFindFirstArgs} args - Arguments to find a TeamsConfig
     * @example
     * // Get one TeamsConfig
     * const teamsConfig = await prisma.teamsConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamsConfigFindFirstArgs>(args?: SelectSubset<T, TeamsConfigFindFirstArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamsConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigFindFirstOrThrowArgs} args - Arguments to find a TeamsConfig
     * @example
     * // Get one TeamsConfig
     * const teamsConfig = await prisma.teamsConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamsConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamsConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamsConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamsConfigs
     * const teamsConfigs = await prisma.teamsConfig.findMany()
     * 
     * // Get first 10 TeamsConfigs
     * const teamsConfigs = await prisma.teamsConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamsConfigWithIdOnly = await prisma.teamsConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamsConfigFindManyArgs>(args?: SelectSubset<T, TeamsConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamsConfig.
     * @param {TeamsConfigCreateArgs} args - Arguments to create a TeamsConfig.
     * @example
     * // Create one TeamsConfig
     * const TeamsConfig = await prisma.teamsConfig.create({
     *   data: {
     *     // ... data to create a TeamsConfig
     *   }
     * })
     * 
     */
    create<T extends TeamsConfigCreateArgs>(args: SelectSubset<T, TeamsConfigCreateArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamsConfigs.
     * @param {TeamsConfigCreateManyArgs} args - Arguments to create many TeamsConfigs.
     * @example
     * // Create many TeamsConfigs
     * const teamsConfig = await prisma.teamsConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamsConfigCreateManyArgs>(args?: SelectSubset<T, TeamsConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamsConfigs and returns the data saved in the database.
     * @param {TeamsConfigCreateManyAndReturnArgs} args - Arguments to create many TeamsConfigs.
     * @example
     * // Create many TeamsConfigs
     * const teamsConfig = await prisma.teamsConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamsConfigs and only return the `id`
     * const teamsConfigWithIdOnly = await prisma.teamsConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamsConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamsConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamsConfig.
     * @param {TeamsConfigDeleteArgs} args - Arguments to delete one TeamsConfig.
     * @example
     * // Delete one TeamsConfig
     * const TeamsConfig = await prisma.teamsConfig.delete({
     *   where: {
     *     // ... filter to delete one TeamsConfig
     *   }
     * })
     * 
     */
    delete<T extends TeamsConfigDeleteArgs>(args: SelectSubset<T, TeamsConfigDeleteArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamsConfig.
     * @param {TeamsConfigUpdateArgs} args - Arguments to update one TeamsConfig.
     * @example
     * // Update one TeamsConfig
     * const teamsConfig = await prisma.teamsConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamsConfigUpdateArgs>(args: SelectSubset<T, TeamsConfigUpdateArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamsConfigs.
     * @param {TeamsConfigDeleteManyArgs} args - Arguments to filter TeamsConfigs to delete.
     * @example
     * // Delete a few TeamsConfigs
     * const { count } = await prisma.teamsConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamsConfigDeleteManyArgs>(args?: SelectSubset<T, TeamsConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamsConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamsConfigs
     * const teamsConfig = await prisma.teamsConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamsConfigUpdateManyArgs>(args: SelectSubset<T, TeamsConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamsConfig.
     * @param {TeamsConfigUpsertArgs} args - Arguments to update or create a TeamsConfig.
     * @example
     * // Update or create a TeamsConfig
     * const teamsConfig = await prisma.teamsConfig.upsert({
     *   create: {
     *     // ... data to create a TeamsConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamsConfig we want to update
     *   }
     * })
     */
    upsert<T extends TeamsConfigUpsertArgs>(args: SelectSubset<T, TeamsConfigUpsertArgs<ExtArgs>>): Prisma__TeamsConfigClient<$Result.GetResult<Prisma.$TeamsConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamsConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigCountArgs} args - Arguments to filter TeamsConfigs to count.
     * @example
     * // Count the number of TeamsConfigs
     * const count = await prisma.teamsConfig.count({
     *   where: {
     *     // ... the filter for the TeamsConfigs we want to count
     *   }
     * })
    **/
    count<T extends TeamsConfigCountArgs>(
      args?: Subset<T, TeamsConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamsConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamsConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamsConfigAggregateArgs>(args: Subset<T, TeamsConfigAggregateArgs>): Prisma.PrismaPromise<GetTeamsConfigAggregateType<T>>

    /**
     * Group by TeamsConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamsConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamsConfigGroupByArgs['orderBy'] }
        : { orderBy?: TeamsConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamsConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamsConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamsConfig model
   */
  readonly fields: TeamsConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamsConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamsConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamsConfig model
   */ 
  interface TeamsConfigFieldRefs {
    readonly id: FieldRef<"TeamsConfig", 'String'>
    readonly projetoId: FieldRef<"TeamsConfig", 'String'>
    readonly nomeEquipe: FieldRef<"TeamsConfig", 'String'>
    readonly tipoEquipe: FieldRef<"TeamsConfig", 'String'>
    readonly proposito: FieldRef<"TeamsConfig", 'String'>
    readonly proprietarios: FieldRef<"TeamsConfig", 'String'>
    readonly membrosIniciais: FieldRef<"TeamsConfig", 'String'>
    readonly canais: FieldRef<"TeamsConfig", 'String'>
    readonly recursos: FieldRef<"TeamsConfig", 'String'>
    readonly observacoes: FieldRef<"TeamsConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeamsConfig findUnique
   */
  export type TeamsConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * Filter, which TeamsConfig to fetch.
     */
    where: TeamsConfigWhereUniqueInput
  }

  /**
   * TeamsConfig findUniqueOrThrow
   */
  export type TeamsConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * Filter, which TeamsConfig to fetch.
     */
    where: TeamsConfigWhereUniqueInput
  }

  /**
   * TeamsConfig findFirst
   */
  export type TeamsConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * Filter, which TeamsConfig to fetch.
     */
    where?: TeamsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsConfigs to fetch.
     */
    orderBy?: TeamsConfigOrderByWithRelationInput | TeamsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamsConfigs.
     */
    cursor?: TeamsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamsConfigs.
     */
    distinct?: TeamsConfigScalarFieldEnum | TeamsConfigScalarFieldEnum[]
  }

  /**
   * TeamsConfig findFirstOrThrow
   */
  export type TeamsConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * Filter, which TeamsConfig to fetch.
     */
    where?: TeamsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsConfigs to fetch.
     */
    orderBy?: TeamsConfigOrderByWithRelationInput | TeamsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamsConfigs.
     */
    cursor?: TeamsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamsConfigs.
     */
    distinct?: TeamsConfigScalarFieldEnum | TeamsConfigScalarFieldEnum[]
  }

  /**
   * TeamsConfig findMany
   */
  export type TeamsConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * Filter, which TeamsConfigs to fetch.
     */
    where?: TeamsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsConfigs to fetch.
     */
    orderBy?: TeamsConfigOrderByWithRelationInput | TeamsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamsConfigs.
     */
    cursor?: TeamsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsConfigs.
     */
    skip?: number
    distinct?: TeamsConfigScalarFieldEnum | TeamsConfigScalarFieldEnum[]
  }

  /**
   * TeamsConfig create
   */
  export type TeamsConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamsConfig.
     */
    data: XOR<TeamsConfigCreateInput, TeamsConfigUncheckedCreateInput>
  }

  /**
   * TeamsConfig createMany
   */
  export type TeamsConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamsConfigs.
     */
    data: TeamsConfigCreateManyInput | TeamsConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamsConfig createManyAndReturn
   */
  export type TeamsConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamsConfigs.
     */
    data: TeamsConfigCreateManyInput | TeamsConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamsConfig update
   */
  export type TeamsConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamsConfig.
     */
    data: XOR<TeamsConfigUpdateInput, TeamsConfigUncheckedUpdateInput>
    /**
     * Choose, which TeamsConfig to update.
     */
    where: TeamsConfigWhereUniqueInput
  }

  /**
   * TeamsConfig updateMany
   */
  export type TeamsConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamsConfigs.
     */
    data: XOR<TeamsConfigUpdateManyMutationInput, TeamsConfigUncheckedUpdateManyInput>
    /**
     * Filter which TeamsConfigs to update
     */
    where?: TeamsConfigWhereInput
  }

  /**
   * TeamsConfig upsert
   */
  export type TeamsConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamsConfig to update in case it exists.
     */
    where: TeamsConfigWhereUniqueInput
    /**
     * In case the TeamsConfig found by the `where` argument doesn't exist, create a new TeamsConfig with this data.
     */
    create: XOR<TeamsConfigCreateInput, TeamsConfigUncheckedCreateInput>
    /**
     * In case the TeamsConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamsConfigUpdateInput, TeamsConfigUncheckedUpdateInput>
  }

  /**
   * TeamsConfig delete
   */
  export type TeamsConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
    /**
     * Filter which TeamsConfig to delete.
     */
    where: TeamsConfigWhereUniqueInput
  }

  /**
   * TeamsConfig deleteMany
   */
  export type TeamsConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamsConfigs to delete
     */
    where?: TeamsConfigWhereInput
  }

  /**
   * TeamsConfig without action
   */
  export type TeamsConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsConfig
     */
    select?: TeamsConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsConfigInclude<ExtArgs> | null
  }


  /**
   * Model CronogramaItem
   */

  export type AggregateCronogramaItem = {
    _count: CronogramaItemCountAggregateOutputType | null
    _avg: CronogramaItemAvgAggregateOutputType | null
    _sum: CronogramaItemSumAggregateOutputType | null
    _min: CronogramaItemMinAggregateOutputType | null
    _max: CronogramaItemMaxAggregateOutputType | null
  }

  export type CronogramaItemAvgAggregateOutputType = {
    ordem: number | null
  }

  export type CronogramaItemSumAggregateOutputType = {
    ordem: number | null
  }

  export type CronogramaItemMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    responsavel: string | null
    inicio: Date | null
    fim: Date | null
    status: string | null
    ordem: number | null
  }

  export type CronogramaItemMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    nome: string | null
    responsavel: string | null
    inicio: Date | null
    fim: Date | null
    status: string | null
    ordem: number | null
  }

  export type CronogramaItemCountAggregateOutputType = {
    id: number
    projetoId: number
    nome: number
    responsavel: number
    inicio: number
    fim: number
    status: number
    ordem: number
    _all: number
  }


  export type CronogramaItemAvgAggregateInputType = {
    ordem?: true
  }

  export type CronogramaItemSumAggregateInputType = {
    ordem?: true
  }

  export type CronogramaItemMinAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    responsavel?: true
    inicio?: true
    fim?: true
    status?: true
    ordem?: true
  }

  export type CronogramaItemMaxAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    responsavel?: true
    inicio?: true
    fim?: true
    status?: true
    ordem?: true
  }

  export type CronogramaItemCountAggregateInputType = {
    id?: true
    projetoId?: true
    nome?: true
    responsavel?: true
    inicio?: true
    fim?: true
    status?: true
    ordem?: true
    _all?: true
  }

  export type CronogramaItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronogramaItem to aggregate.
     */
    where?: CronogramaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronogramaItems to fetch.
     */
    orderBy?: CronogramaItemOrderByWithRelationInput | CronogramaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CronogramaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronogramaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronogramaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CronogramaItems
    **/
    _count?: true | CronogramaItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CronogramaItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CronogramaItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CronogramaItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CronogramaItemMaxAggregateInputType
  }

  export type GetCronogramaItemAggregateType<T extends CronogramaItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCronogramaItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCronogramaItem[P]>
      : GetScalarType<T[P], AggregateCronogramaItem[P]>
  }




  export type CronogramaItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CronogramaItemWhereInput
    orderBy?: CronogramaItemOrderByWithAggregationInput | CronogramaItemOrderByWithAggregationInput[]
    by: CronogramaItemScalarFieldEnum[] | CronogramaItemScalarFieldEnum
    having?: CronogramaItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CronogramaItemCountAggregateInputType | true
    _avg?: CronogramaItemAvgAggregateInputType
    _sum?: CronogramaItemSumAggregateInputType
    _min?: CronogramaItemMinAggregateInputType
    _max?: CronogramaItemMaxAggregateInputType
  }

  export type CronogramaItemGroupByOutputType = {
    id: string
    projetoId: string
    nome: string
    responsavel: string | null
    inicio: Date | null
    fim: Date | null
    status: string
    ordem: number | null
    _count: CronogramaItemCountAggregateOutputType | null
    _avg: CronogramaItemAvgAggregateOutputType | null
    _sum: CronogramaItemSumAggregateOutputType | null
    _min: CronogramaItemMinAggregateOutputType | null
    _max: CronogramaItemMaxAggregateOutputType | null
  }

  type GetCronogramaItemGroupByPayload<T extends CronogramaItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CronogramaItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CronogramaItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CronogramaItemGroupByOutputType[P]>
            : GetScalarType<T[P], CronogramaItemGroupByOutputType[P]>
        }
      >
    >


  export type CronogramaItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    responsavel?: boolean
    inicio?: boolean
    fim?: boolean
    status?: boolean
    ordem?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cronogramaItem"]>

  export type CronogramaItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    responsavel?: boolean
    inicio?: boolean
    fim?: boolean
    status?: boolean
    ordem?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cronogramaItem"]>

  export type CronogramaItemSelectScalar = {
    id?: boolean
    projetoId?: boolean
    nome?: boolean
    responsavel?: boolean
    inicio?: boolean
    fim?: boolean
    status?: boolean
    ordem?: boolean
  }

  export type CronogramaItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type CronogramaItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $CronogramaItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CronogramaItem"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      nome: string
      responsavel: string | null
      inicio: Date | null
      fim: Date | null
      status: string
      ordem: number | null
    }, ExtArgs["result"]["cronogramaItem"]>
    composites: {}
  }

  type CronogramaItemGetPayload<S extends boolean | null | undefined | CronogramaItemDefaultArgs> = $Result.GetResult<Prisma.$CronogramaItemPayload, S>

  type CronogramaItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CronogramaItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CronogramaItemCountAggregateInputType | true
    }

  export interface CronogramaItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CronogramaItem'], meta: { name: 'CronogramaItem' } }
    /**
     * Find zero or one CronogramaItem that matches the filter.
     * @param {CronogramaItemFindUniqueArgs} args - Arguments to find a CronogramaItem
     * @example
     * // Get one CronogramaItem
     * const cronogramaItem = await prisma.cronogramaItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CronogramaItemFindUniqueArgs>(args: SelectSubset<T, CronogramaItemFindUniqueArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CronogramaItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CronogramaItemFindUniqueOrThrowArgs} args - Arguments to find a CronogramaItem
     * @example
     * // Get one CronogramaItem
     * const cronogramaItem = await prisma.cronogramaItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CronogramaItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CronogramaItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CronogramaItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemFindFirstArgs} args - Arguments to find a CronogramaItem
     * @example
     * // Get one CronogramaItem
     * const cronogramaItem = await prisma.cronogramaItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CronogramaItemFindFirstArgs>(args?: SelectSubset<T, CronogramaItemFindFirstArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CronogramaItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemFindFirstOrThrowArgs} args - Arguments to find a CronogramaItem
     * @example
     * // Get one CronogramaItem
     * const cronogramaItem = await prisma.cronogramaItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CronogramaItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CronogramaItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CronogramaItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CronogramaItems
     * const cronogramaItems = await prisma.cronogramaItem.findMany()
     * 
     * // Get first 10 CronogramaItems
     * const cronogramaItems = await prisma.cronogramaItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cronogramaItemWithIdOnly = await prisma.cronogramaItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CronogramaItemFindManyArgs>(args?: SelectSubset<T, CronogramaItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CronogramaItem.
     * @param {CronogramaItemCreateArgs} args - Arguments to create a CronogramaItem.
     * @example
     * // Create one CronogramaItem
     * const CronogramaItem = await prisma.cronogramaItem.create({
     *   data: {
     *     // ... data to create a CronogramaItem
     *   }
     * })
     * 
     */
    create<T extends CronogramaItemCreateArgs>(args: SelectSubset<T, CronogramaItemCreateArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CronogramaItems.
     * @param {CronogramaItemCreateManyArgs} args - Arguments to create many CronogramaItems.
     * @example
     * // Create many CronogramaItems
     * const cronogramaItem = await prisma.cronogramaItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CronogramaItemCreateManyArgs>(args?: SelectSubset<T, CronogramaItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CronogramaItems and returns the data saved in the database.
     * @param {CronogramaItemCreateManyAndReturnArgs} args - Arguments to create many CronogramaItems.
     * @example
     * // Create many CronogramaItems
     * const cronogramaItem = await prisma.cronogramaItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CronogramaItems and only return the `id`
     * const cronogramaItemWithIdOnly = await prisma.cronogramaItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CronogramaItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CronogramaItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CronogramaItem.
     * @param {CronogramaItemDeleteArgs} args - Arguments to delete one CronogramaItem.
     * @example
     * // Delete one CronogramaItem
     * const CronogramaItem = await prisma.cronogramaItem.delete({
     *   where: {
     *     // ... filter to delete one CronogramaItem
     *   }
     * })
     * 
     */
    delete<T extends CronogramaItemDeleteArgs>(args: SelectSubset<T, CronogramaItemDeleteArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CronogramaItem.
     * @param {CronogramaItemUpdateArgs} args - Arguments to update one CronogramaItem.
     * @example
     * // Update one CronogramaItem
     * const cronogramaItem = await prisma.cronogramaItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CronogramaItemUpdateArgs>(args: SelectSubset<T, CronogramaItemUpdateArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CronogramaItems.
     * @param {CronogramaItemDeleteManyArgs} args - Arguments to filter CronogramaItems to delete.
     * @example
     * // Delete a few CronogramaItems
     * const { count } = await prisma.cronogramaItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CronogramaItemDeleteManyArgs>(args?: SelectSubset<T, CronogramaItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CronogramaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CronogramaItems
     * const cronogramaItem = await prisma.cronogramaItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CronogramaItemUpdateManyArgs>(args: SelectSubset<T, CronogramaItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CronogramaItem.
     * @param {CronogramaItemUpsertArgs} args - Arguments to update or create a CronogramaItem.
     * @example
     * // Update or create a CronogramaItem
     * const cronogramaItem = await prisma.cronogramaItem.upsert({
     *   create: {
     *     // ... data to create a CronogramaItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CronogramaItem we want to update
     *   }
     * })
     */
    upsert<T extends CronogramaItemUpsertArgs>(args: SelectSubset<T, CronogramaItemUpsertArgs<ExtArgs>>): Prisma__CronogramaItemClient<$Result.GetResult<Prisma.$CronogramaItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CronogramaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemCountArgs} args - Arguments to filter CronogramaItems to count.
     * @example
     * // Count the number of CronogramaItems
     * const count = await prisma.cronogramaItem.count({
     *   where: {
     *     // ... the filter for the CronogramaItems we want to count
     *   }
     * })
    **/
    count<T extends CronogramaItemCountArgs>(
      args?: Subset<T, CronogramaItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CronogramaItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CronogramaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CronogramaItemAggregateArgs>(args: Subset<T, CronogramaItemAggregateArgs>): Prisma.PrismaPromise<GetCronogramaItemAggregateType<T>>

    /**
     * Group by CronogramaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CronogramaItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CronogramaItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CronogramaItemGroupByArgs['orderBy'] }
        : { orderBy?: CronogramaItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CronogramaItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCronogramaItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CronogramaItem model
   */
  readonly fields: CronogramaItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CronogramaItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CronogramaItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CronogramaItem model
   */ 
  interface CronogramaItemFieldRefs {
    readonly id: FieldRef<"CronogramaItem", 'String'>
    readonly projetoId: FieldRef<"CronogramaItem", 'String'>
    readonly nome: FieldRef<"CronogramaItem", 'String'>
    readonly responsavel: FieldRef<"CronogramaItem", 'String'>
    readonly inicio: FieldRef<"CronogramaItem", 'DateTime'>
    readonly fim: FieldRef<"CronogramaItem", 'DateTime'>
    readonly status: FieldRef<"CronogramaItem", 'String'>
    readonly ordem: FieldRef<"CronogramaItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CronogramaItem findUnique
   */
  export type CronogramaItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * Filter, which CronogramaItem to fetch.
     */
    where: CronogramaItemWhereUniqueInput
  }

  /**
   * CronogramaItem findUniqueOrThrow
   */
  export type CronogramaItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * Filter, which CronogramaItem to fetch.
     */
    where: CronogramaItemWhereUniqueInput
  }

  /**
   * CronogramaItem findFirst
   */
  export type CronogramaItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * Filter, which CronogramaItem to fetch.
     */
    where?: CronogramaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronogramaItems to fetch.
     */
    orderBy?: CronogramaItemOrderByWithRelationInput | CronogramaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronogramaItems.
     */
    cursor?: CronogramaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronogramaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronogramaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronogramaItems.
     */
    distinct?: CronogramaItemScalarFieldEnum | CronogramaItemScalarFieldEnum[]
  }

  /**
   * CronogramaItem findFirstOrThrow
   */
  export type CronogramaItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * Filter, which CronogramaItem to fetch.
     */
    where?: CronogramaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronogramaItems to fetch.
     */
    orderBy?: CronogramaItemOrderByWithRelationInput | CronogramaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CronogramaItems.
     */
    cursor?: CronogramaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronogramaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronogramaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CronogramaItems.
     */
    distinct?: CronogramaItemScalarFieldEnum | CronogramaItemScalarFieldEnum[]
  }

  /**
   * CronogramaItem findMany
   */
  export type CronogramaItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * Filter, which CronogramaItems to fetch.
     */
    where?: CronogramaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CronogramaItems to fetch.
     */
    orderBy?: CronogramaItemOrderByWithRelationInput | CronogramaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CronogramaItems.
     */
    cursor?: CronogramaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CronogramaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CronogramaItems.
     */
    skip?: number
    distinct?: CronogramaItemScalarFieldEnum | CronogramaItemScalarFieldEnum[]
  }

  /**
   * CronogramaItem create
   */
  export type CronogramaItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CronogramaItem.
     */
    data: XOR<CronogramaItemCreateInput, CronogramaItemUncheckedCreateInput>
  }

  /**
   * CronogramaItem createMany
   */
  export type CronogramaItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CronogramaItems.
     */
    data: CronogramaItemCreateManyInput | CronogramaItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CronogramaItem createManyAndReturn
   */
  export type CronogramaItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CronogramaItems.
     */
    data: CronogramaItemCreateManyInput | CronogramaItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CronogramaItem update
   */
  export type CronogramaItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CronogramaItem.
     */
    data: XOR<CronogramaItemUpdateInput, CronogramaItemUncheckedUpdateInput>
    /**
     * Choose, which CronogramaItem to update.
     */
    where: CronogramaItemWhereUniqueInput
  }

  /**
   * CronogramaItem updateMany
   */
  export type CronogramaItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CronogramaItems.
     */
    data: XOR<CronogramaItemUpdateManyMutationInput, CronogramaItemUncheckedUpdateManyInput>
    /**
     * Filter which CronogramaItems to update
     */
    where?: CronogramaItemWhereInput
  }

  /**
   * CronogramaItem upsert
   */
  export type CronogramaItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CronogramaItem to update in case it exists.
     */
    where: CronogramaItemWhereUniqueInput
    /**
     * In case the CronogramaItem found by the `where` argument doesn't exist, create a new CronogramaItem with this data.
     */
    create: XOR<CronogramaItemCreateInput, CronogramaItemUncheckedCreateInput>
    /**
     * In case the CronogramaItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CronogramaItemUpdateInput, CronogramaItemUncheckedUpdateInput>
  }

  /**
   * CronogramaItem delete
   */
  export type CronogramaItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
    /**
     * Filter which CronogramaItem to delete.
     */
    where: CronogramaItemWhereUniqueInput
  }

  /**
   * CronogramaItem deleteMany
   */
  export type CronogramaItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CronogramaItems to delete
     */
    where?: CronogramaItemWhereInput
  }

  /**
   * CronogramaItem without action
   */
  export type CronogramaItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CronogramaItem
     */
    select?: CronogramaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CronogramaItemInclude<ExtArgs> | null
  }


  /**
   * Model Licenciamento
   */

  export type AggregateLicenciamento = {
    _count: LicenciamentoCountAggregateOutputType | null
    _avg: LicenciamentoAvgAggregateOutputType | null
    _sum: LicenciamentoSumAggregateOutputType | null
    _min: LicenciamentoMinAggregateOutputType | null
    _max: LicenciamentoMaxAggregateOutputType | null
  }

  export type LicenciamentoAvgAggregateOutputType = {
    m365basic: number | null
    m365standard: number | null
    appsforbusiness: number | null
    f3: number | null
    e3: number | null
    e5: number | null
  }

  export type LicenciamentoSumAggregateOutputType = {
    m365basic: number | null
    m365standard: number | null
    appsforbusiness: number | null
    f3: number | null
    e3: number | null
    e5: number | null
  }

  export type LicenciamentoMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    m365basic: number | null
    m365standard: number | null
    appsforbusiness: number | null
    f3: number | null
    e3: number | null
    e5: number | null
    observacoes: string | null
  }

  export type LicenciamentoMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    m365basic: number | null
    m365standard: number | null
    appsforbusiness: number | null
    f3: number | null
    e3: number | null
    e5: number | null
    observacoes: string | null
  }

  export type LicenciamentoCountAggregateOutputType = {
    id: number
    projetoId: number
    m365basic: number
    m365standard: number
    appsforbusiness: number
    f3: number
    e3: number
    e5: number
    observacoes: number
    _all: number
  }


  export type LicenciamentoAvgAggregateInputType = {
    m365basic?: true
    m365standard?: true
    appsforbusiness?: true
    f3?: true
    e3?: true
    e5?: true
  }

  export type LicenciamentoSumAggregateInputType = {
    m365basic?: true
    m365standard?: true
    appsforbusiness?: true
    f3?: true
    e3?: true
    e5?: true
  }

  export type LicenciamentoMinAggregateInputType = {
    id?: true
    projetoId?: true
    m365basic?: true
    m365standard?: true
    appsforbusiness?: true
    f3?: true
    e3?: true
    e5?: true
    observacoes?: true
  }

  export type LicenciamentoMaxAggregateInputType = {
    id?: true
    projetoId?: true
    m365basic?: true
    m365standard?: true
    appsforbusiness?: true
    f3?: true
    e3?: true
    e5?: true
    observacoes?: true
  }

  export type LicenciamentoCountAggregateInputType = {
    id?: true
    projetoId?: true
    m365basic?: true
    m365standard?: true
    appsforbusiness?: true
    f3?: true
    e3?: true
    e5?: true
    observacoes?: true
    _all?: true
  }

  export type LicenciamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenciamento to aggregate.
     */
    where?: LicenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenciamentos to fetch.
     */
    orderBy?: LicenciamentoOrderByWithRelationInput | LicenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenciamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenciamentos
    **/
    _count?: true | LicenciamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicenciamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicenciamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenciamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenciamentoMaxAggregateInputType
  }

  export type GetLicenciamentoAggregateType<T extends LicenciamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateLicenciamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicenciamento[P]>
      : GetScalarType<T[P], AggregateLicenciamento[P]>
  }




  export type LicenciamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenciamentoWhereInput
    orderBy?: LicenciamentoOrderByWithAggregationInput | LicenciamentoOrderByWithAggregationInput[]
    by: LicenciamentoScalarFieldEnum[] | LicenciamentoScalarFieldEnum
    having?: LicenciamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenciamentoCountAggregateInputType | true
    _avg?: LicenciamentoAvgAggregateInputType
    _sum?: LicenciamentoSumAggregateInputType
    _min?: LicenciamentoMinAggregateInputType
    _max?: LicenciamentoMaxAggregateInputType
  }

  export type LicenciamentoGroupByOutputType = {
    id: string
    projetoId: string
    m365basic: number | null
    m365standard: number | null
    appsforbusiness: number | null
    f3: number | null
    e3: number | null
    e5: number | null
    observacoes: string | null
    _count: LicenciamentoCountAggregateOutputType | null
    _avg: LicenciamentoAvgAggregateOutputType | null
    _sum: LicenciamentoSumAggregateOutputType | null
    _min: LicenciamentoMinAggregateOutputType | null
    _max: LicenciamentoMaxAggregateOutputType | null
  }

  type GetLicenciamentoGroupByPayload<T extends LicenciamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenciamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenciamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenciamentoGroupByOutputType[P]>
            : GetScalarType<T[P], LicenciamentoGroupByOutputType[P]>
        }
      >
    >


  export type LicenciamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    m365basic?: boolean
    m365standard?: boolean
    appsforbusiness?: boolean
    f3?: boolean
    e3?: boolean
    e5?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenciamento"]>

  export type LicenciamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    m365basic?: boolean
    m365standard?: boolean
    appsforbusiness?: boolean
    f3?: boolean
    e3?: boolean
    e5?: boolean
    observacoes?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenciamento"]>

  export type LicenciamentoSelectScalar = {
    id?: boolean
    projetoId?: boolean
    m365basic?: boolean
    m365standard?: boolean
    appsforbusiness?: boolean
    f3?: boolean
    e3?: boolean
    e5?: boolean
    observacoes?: boolean
  }

  export type LicenciamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type LicenciamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $LicenciamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Licenciamento"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      m365basic: number | null
      m365standard: number | null
      appsforbusiness: number | null
      f3: number | null
      e3: number | null
      e5: number | null
      observacoes: string | null
    }, ExtArgs["result"]["licenciamento"]>
    composites: {}
  }

  type LicenciamentoGetPayload<S extends boolean | null | undefined | LicenciamentoDefaultArgs> = $Result.GetResult<Prisma.$LicenciamentoPayload, S>

  type LicenciamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LicenciamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LicenciamentoCountAggregateInputType | true
    }

  export interface LicenciamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Licenciamento'], meta: { name: 'Licenciamento' } }
    /**
     * Find zero or one Licenciamento that matches the filter.
     * @param {LicenciamentoFindUniqueArgs} args - Arguments to find a Licenciamento
     * @example
     * // Get one Licenciamento
     * const licenciamento = await prisma.licenciamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenciamentoFindUniqueArgs>(args: SelectSubset<T, LicenciamentoFindUniqueArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Licenciamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LicenciamentoFindUniqueOrThrowArgs} args - Arguments to find a Licenciamento
     * @example
     * // Get one Licenciamento
     * const licenciamento = await prisma.licenciamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenciamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenciamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Licenciamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoFindFirstArgs} args - Arguments to find a Licenciamento
     * @example
     * // Get one Licenciamento
     * const licenciamento = await prisma.licenciamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenciamentoFindFirstArgs>(args?: SelectSubset<T, LicenciamentoFindFirstArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Licenciamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoFindFirstOrThrowArgs} args - Arguments to find a Licenciamento
     * @example
     * // Get one Licenciamento
     * const licenciamento = await prisma.licenciamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenciamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenciamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Licenciamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenciamentos
     * const licenciamentos = await prisma.licenciamento.findMany()
     * 
     * // Get first 10 Licenciamentos
     * const licenciamentos = await prisma.licenciamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenciamentoWithIdOnly = await prisma.licenciamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenciamentoFindManyArgs>(args?: SelectSubset<T, LicenciamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Licenciamento.
     * @param {LicenciamentoCreateArgs} args - Arguments to create a Licenciamento.
     * @example
     * // Create one Licenciamento
     * const Licenciamento = await prisma.licenciamento.create({
     *   data: {
     *     // ... data to create a Licenciamento
     *   }
     * })
     * 
     */
    create<T extends LicenciamentoCreateArgs>(args: SelectSubset<T, LicenciamentoCreateArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Licenciamentos.
     * @param {LicenciamentoCreateManyArgs} args - Arguments to create many Licenciamentos.
     * @example
     * // Create many Licenciamentos
     * const licenciamento = await prisma.licenciamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenciamentoCreateManyArgs>(args?: SelectSubset<T, LicenciamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Licenciamentos and returns the data saved in the database.
     * @param {LicenciamentoCreateManyAndReturnArgs} args - Arguments to create many Licenciamentos.
     * @example
     * // Create many Licenciamentos
     * const licenciamento = await prisma.licenciamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Licenciamentos and only return the `id`
     * const licenciamentoWithIdOnly = await prisma.licenciamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenciamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenciamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Licenciamento.
     * @param {LicenciamentoDeleteArgs} args - Arguments to delete one Licenciamento.
     * @example
     * // Delete one Licenciamento
     * const Licenciamento = await prisma.licenciamento.delete({
     *   where: {
     *     // ... filter to delete one Licenciamento
     *   }
     * })
     * 
     */
    delete<T extends LicenciamentoDeleteArgs>(args: SelectSubset<T, LicenciamentoDeleteArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Licenciamento.
     * @param {LicenciamentoUpdateArgs} args - Arguments to update one Licenciamento.
     * @example
     * // Update one Licenciamento
     * const licenciamento = await prisma.licenciamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenciamentoUpdateArgs>(args: SelectSubset<T, LicenciamentoUpdateArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Licenciamentos.
     * @param {LicenciamentoDeleteManyArgs} args - Arguments to filter Licenciamentos to delete.
     * @example
     * // Delete a few Licenciamentos
     * const { count } = await prisma.licenciamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenciamentoDeleteManyArgs>(args?: SelectSubset<T, LicenciamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenciamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenciamentos
     * const licenciamento = await prisma.licenciamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenciamentoUpdateManyArgs>(args: SelectSubset<T, LicenciamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Licenciamento.
     * @param {LicenciamentoUpsertArgs} args - Arguments to update or create a Licenciamento.
     * @example
     * // Update or create a Licenciamento
     * const licenciamento = await prisma.licenciamento.upsert({
     *   create: {
     *     // ... data to create a Licenciamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Licenciamento we want to update
     *   }
     * })
     */
    upsert<T extends LicenciamentoUpsertArgs>(args: SelectSubset<T, LicenciamentoUpsertArgs<ExtArgs>>): Prisma__LicenciamentoClient<$Result.GetResult<Prisma.$LicenciamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Licenciamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoCountArgs} args - Arguments to filter Licenciamentos to count.
     * @example
     * // Count the number of Licenciamentos
     * const count = await prisma.licenciamento.count({
     *   where: {
     *     // ... the filter for the Licenciamentos we want to count
     *   }
     * })
    **/
    count<T extends LicenciamentoCountArgs>(
      args?: Subset<T, LicenciamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenciamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Licenciamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenciamentoAggregateArgs>(args: Subset<T, LicenciamentoAggregateArgs>): Prisma.PrismaPromise<GetLicenciamentoAggregateType<T>>

    /**
     * Group by Licenciamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenciamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenciamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenciamentoGroupByArgs['orderBy'] }
        : { orderBy?: LicenciamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenciamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenciamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Licenciamento model
   */
  readonly fields: LicenciamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Licenciamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenciamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Licenciamento model
   */ 
  interface LicenciamentoFieldRefs {
    readonly id: FieldRef<"Licenciamento", 'String'>
    readonly projetoId: FieldRef<"Licenciamento", 'String'>
    readonly m365basic: FieldRef<"Licenciamento", 'Int'>
    readonly m365standard: FieldRef<"Licenciamento", 'Int'>
    readonly appsforbusiness: FieldRef<"Licenciamento", 'Int'>
    readonly f3: FieldRef<"Licenciamento", 'Int'>
    readonly e3: FieldRef<"Licenciamento", 'Int'>
    readonly e5: FieldRef<"Licenciamento", 'Int'>
    readonly observacoes: FieldRef<"Licenciamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Licenciamento findUnique
   */
  export type LicenciamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which Licenciamento to fetch.
     */
    where: LicenciamentoWhereUniqueInput
  }

  /**
   * Licenciamento findUniqueOrThrow
   */
  export type LicenciamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which Licenciamento to fetch.
     */
    where: LicenciamentoWhereUniqueInput
  }

  /**
   * Licenciamento findFirst
   */
  export type LicenciamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which Licenciamento to fetch.
     */
    where?: LicenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenciamentos to fetch.
     */
    orderBy?: LicenciamentoOrderByWithRelationInput | LicenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenciamentos.
     */
    cursor?: LicenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenciamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenciamentos.
     */
    distinct?: LicenciamentoScalarFieldEnum | LicenciamentoScalarFieldEnum[]
  }

  /**
   * Licenciamento findFirstOrThrow
   */
  export type LicenciamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which Licenciamento to fetch.
     */
    where?: LicenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenciamentos to fetch.
     */
    orderBy?: LicenciamentoOrderByWithRelationInput | LicenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenciamentos.
     */
    cursor?: LicenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenciamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenciamentos.
     */
    distinct?: LicenciamentoScalarFieldEnum | LicenciamentoScalarFieldEnum[]
  }

  /**
   * Licenciamento findMany
   */
  export type LicenciamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * Filter, which Licenciamentos to fetch.
     */
    where?: LicenciamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenciamentos to fetch.
     */
    orderBy?: LicenciamentoOrderByWithRelationInput | LicenciamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenciamentos.
     */
    cursor?: LicenciamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenciamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenciamentos.
     */
    skip?: number
    distinct?: LicenciamentoScalarFieldEnum | LicenciamentoScalarFieldEnum[]
  }

  /**
   * Licenciamento create
   */
  export type LicenciamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Licenciamento.
     */
    data: XOR<LicenciamentoCreateInput, LicenciamentoUncheckedCreateInput>
  }

  /**
   * Licenciamento createMany
   */
  export type LicenciamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenciamentos.
     */
    data: LicenciamentoCreateManyInput | LicenciamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Licenciamento createManyAndReturn
   */
  export type LicenciamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Licenciamentos.
     */
    data: LicenciamentoCreateManyInput | LicenciamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Licenciamento update
   */
  export type LicenciamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Licenciamento.
     */
    data: XOR<LicenciamentoUpdateInput, LicenciamentoUncheckedUpdateInput>
    /**
     * Choose, which Licenciamento to update.
     */
    where: LicenciamentoWhereUniqueInput
  }

  /**
   * Licenciamento updateMany
   */
  export type LicenciamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenciamentos.
     */
    data: XOR<LicenciamentoUpdateManyMutationInput, LicenciamentoUncheckedUpdateManyInput>
    /**
     * Filter which Licenciamentos to update
     */
    where?: LicenciamentoWhereInput
  }

  /**
   * Licenciamento upsert
   */
  export type LicenciamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Licenciamento to update in case it exists.
     */
    where: LicenciamentoWhereUniqueInput
    /**
     * In case the Licenciamento found by the `where` argument doesn't exist, create a new Licenciamento with this data.
     */
    create: XOR<LicenciamentoCreateInput, LicenciamentoUncheckedCreateInput>
    /**
     * In case the Licenciamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenciamentoUpdateInput, LicenciamentoUncheckedUpdateInput>
  }

  /**
   * Licenciamento delete
   */
  export type LicenciamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
    /**
     * Filter which Licenciamento to delete.
     */
    where: LicenciamentoWhereUniqueInput
  }

  /**
   * Licenciamento deleteMany
   */
  export type LicenciamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenciamentos to delete
     */
    where?: LicenciamentoWhereInput
  }

  /**
   * Licenciamento without action
   */
  export type LicenciamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenciamento
     */
    select?: LicenciamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenciamentoInclude<ExtArgs> | null
  }


  /**
   * Model Orientacao
   */

  export type AggregateOrientacao = {
    _count: OrientacaoCountAggregateOutputType | null
    _min: OrientacaoMinAggregateOutputType | null
    _max: OrientacaoMaxAggregateOutputType | null
  }

  export type OrientacaoMinAggregateOutputType = {
    id: string | null
    projetoId: string | null
    teams: string | null
    sharepoint: string | null
    emails: string | null
    licencas: string | null
    seguranca: string | null
    governance: string | null
  }

  export type OrientacaoMaxAggregateOutputType = {
    id: string | null
    projetoId: string | null
    teams: string | null
    sharepoint: string | null
    emails: string | null
    licencas: string | null
    seguranca: string | null
    governance: string | null
  }

  export type OrientacaoCountAggregateOutputType = {
    id: number
    projetoId: number
    teams: number
    sharepoint: number
    emails: number
    licencas: number
    seguranca: number
    governance: number
    _all: number
  }


  export type OrientacaoMinAggregateInputType = {
    id?: true
    projetoId?: true
    teams?: true
    sharepoint?: true
    emails?: true
    licencas?: true
    seguranca?: true
    governance?: true
  }

  export type OrientacaoMaxAggregateInputType = {
    id?: true
    projetoId?: true
    teams?: true
    sharepoint?: true
    emails?: true
    licencas?: true
    seguranca?: true
    governance?: true
  }

  export type OrientacaoCountAggregateInputType = {
    id?: true
    projetoId?: true
    teams?: true
    sharepoint?: true
    emails?: true
    licencas?: true
    seguranca?: true
    governance?: true
    _all?: true
  }

  export type OrientacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orientacao to aggregate.
     */
    where?: OrientacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orientacaos to fetch.
     */
    orderBy?: OrientacaoOrderByWithRelationInput | OrientacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrientacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orientacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orientacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orientacaos
    **/
    _count?: true | OrientacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrientacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrientacaoMaxAggregateInputType
  }

  export type GetOrientacaoAggregateType<T extends OrientacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrientacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrientacao[P]>
      : GetScalarType<T[P], AggregateOrientacao[P]>
  }




  export type OrientacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrientacaoWhereInput
    orderBy?: OrientacaoOrderByWithAggregationInput | OrientacaoOrderByWithAggregationInput[]
    by: OrientacaoScalarFieldEnum[] | OrientacaoScalarFieldEnum
    having?: OrientacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrientacaoCountAggregateInputType | true
    _min?: OrientacaoMinAggregateInputType
    _max?: OrientacaoMaxAggregateInputType
  }

  export type OrientacaoGroupByOutputType = {
    id: string
    projetoId: string
    teams: string | null
    sharepoint: string | null
    emails: string | null
    licencas: string | null
    seguranca: string | null
    governance: string | null
    _count: OrientacaoCountAggregateOutputType | null
    _min: OrientacaoMinAggregateOutputType | null
    _max: OrientacaoMaxAggregateOutputType | null
  }

  type GetOrientacaoGroupByPayload<T extends OrientacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrientacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrientacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrientacaoGroupByOutputType[P]>
            : GetScalarType<T[P], OrientacaoGroupByOutputType[P]>
        }
      >
    >


  export type OrientacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    teams?: boolean
    sharepoint?: boolean
    emails?: boolean
    licencas?: boolean
    seguranca?: boolean
    governance?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orientacao"]>

  export type OrientacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projetoId?: boolean
    teams?: boolean
    sharepoint?: boolean
    emails?: boolean
    licencas?: boolean
    seguranca?: boolean
    governance?: boolean
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orientacao"]>

  export type OrientacaoSelectScalar = {
    id?: boolean
    projetoId?: boolean
    teams?: boolean
    sharepoint?: boolean
    emails?: boolean
    licencas?: boolean
    seguranca?: boolean
    governance?: boolean
  }

  export type OrientacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }
  export type OrientacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | ProjetoDefaultArgs<ExtArgs>
  }

  export type $OrientacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orientacao"
    objects: {
      projeto: Prisma.$ProjetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projetoId: string
      teams: string | null
      sharepoint: string | null
      emails: string | null
      licencas: string | null
      seguranca: string | null
      governance: string | null
    }, ExtArgs["result"]["orientacao"]>
    composites: {}
  }

  type OrientacaoGetPayload<S extends boolean | null | undefined | OrientacaoDefaultArgs> = $Result.GetResult<Prisma.$OrientacaoPayload, S>

  type OrientacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrientacaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrientacaoCountAggregateInputType | true
    }

  export interface OrientacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orientacao'], meta: { name: 'Orientacao' } }
    /**
     * Find zero or one Orientacao that matches the filter.
     * @param {OrientacaoFindUniqueArgs} args - Arguments to find a Orientacao
     * @example
     * // Get one Orientacao
     * const orientacao = await prisma.orientacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrientacaoFindUniqueArgs>(args: SelectSubset<T, OrientacaoFindUniqueArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Orientacao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrientacaoFindUniqueOrThrowArgs} args - Arguments to find a Orientacao
     * @example
     * // Get one Orientacao
     * const orientacao = await prisma.orientacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrientacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, OrientacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Orientacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoFindFirstArgs} args - Arguments to find a Orientacao
     * @example
     * // Get one Orientacao
     * const orientacao = await prisma.orientacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrientacaoFindFirstArgs>(args?: SelectSubset<T, OrientacaoFindFirstArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Orientacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoFindFirstOrThrowArgs} args - Arguments to find a Orientacao
     * @example
     * // Get one Orientacao
     * const orientacao = await prisma.orientacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrientacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, OrientacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orientacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orientacaos
     * const orientacaos = await prisma.orientacao.findMany()
     * 
     * // Get first 10 Orientacaos
     * const orientacaos = await prisma.orientacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orientacaoWithIdOnly = await prisma.orientacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrientacaoFindManyArgs>(args?: SelectSubset<T, OrientacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Orientacao.
     * @param {OrientacaoCreateArgs} args - Arguments to create a Orientacao.
     * @example
     * // Create one Orientacao
     * const Orientacao = await prisma.orientacao.create({
     *   data: {
     *     // ... data to create a Orientacao
     *   }
     * })
     * 
     */
    create<T extends OrientacaoCreateArgs>(args: SelectSubset<T, OrientacaoCreateArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orientacaos.
     * @param {OrientacaoCreateManyArgs} args - Arguments to create many Orientacaos.
     * @example
     * // Create many Orientacaos
     * const orientacao = await prisma.orientacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrientacaoCreateManyArgs>(args?: SelectSubset<T, OrientacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orientacaos and returns the data saved in the database.
     * @param {OrientacaoCreateManyAndReturnArgs} args - Arguments to create many Orientacaos.
     * @example
     * // Create many Orientacaos
     * const orientacao = await prisma.orientacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orientacaos and only return the `id`
     * const orientacaoWithIdOnly = await prisma.orientacao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrientacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, OrientacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Orientacao.
     * @param {OrientacaoDeleteArgs} args - Arguments to delete one Orientacao.
     * @example
     * // Delete one Orientacao
     * const Orientacao = await prisma.orientacao.delete({
     *   where: {
     *     // ... filter to delete one Orientacao
     *   }
     * })
     * 
     */
    delete<T extends OrientacaoDeleteArgs>(args: SelectSubset<T, OrientacaoDeleteArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Orientacao.
     * @param {OrientacaoUpdateArgs} args - Arguments to update one Orientacao.
     * @example
     * // Update one Orientacao
     * const orientacao = await prisma.orientacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrientacaoUpdateArgs>(args: SelectSubset<T, OrientacaoUpdateArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orientacaos.
     * @param {OrientacaoDeleteManyArgs} args - Arguments to filter Orientacaos to delete.
     * @example
     * // Delete a few Orientacaos
     * const { count } = await prisma.orientacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrientacaoDeleteManyArgs>(args?: SelectSubset<T, OrientacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orientacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orientacaos
     * const orientacao = await prisma.orientacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrientacaoUpdateManyArgs>(args: SelectSubset<T, OrientacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Orientacao.
     * @param {OrientacaoUpsertArgs} args - Arguments to update or create a Orientacao.
     * @example
     * // Update or create a Orientacao
     * const orientacao = await prisma.orientacao.upsert({
     *   create: {
     *     // ... data to create a Orientacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orientacao we want to update
     *   }
     * })
     */
    upsert<T extends OrientacaoUpsertArgs>(args: SelectSubset<T, OrientacaoUpsertArgs<ExtArgs>>): Prisma__OrientacaoClient<$Result.GetResult<Prisma.$OrientacaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orientacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoCountArgs} args - Arguments to filter Orientacaos to count.
     * @example
     * // Count the number of Orientacaos
     * const count = await prisma.orientacao.count({
     *   where: {
     *     // ... the filter for the Orientacaos we want to count
     *   }
     * })
    **/
    count<T extends OrientacaoCountArgs>(
      args?: Subset<T, OrientacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrientacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orientacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrientacaoAggregateArgs>(args: Subset<T, OrientacaoAggregateArgs>): Prisma.PrismaPromise<GetOrientacaoAggregateType<T>>

    /**
     * Group by Orientacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrientacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrientacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrientacaoGroupByArgs['orderBy'] }
        : { orderBy?: OrientacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrientacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrientacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orientacao model
   */
  readonly fields: OrientacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orientacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrientacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends ProjetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjetoDefaultArgs<ExtArgs>>): Prisma__ProjetoClient<$Result.GetResult<Prisma.$ProjetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Orientacao model
   */ 
  interface OrientacaoFieldRefs {
    readonly id: FieldRef<"Orientacao", 'String'>
    readonly projetoId: FieldRef<"Orientacao", 'String'>
    readonly teams: FieldRef<"Orientacao", 'String'>
    readonly sharepoint: FieldRef<"Orientacao", 'String'>
    readonly emails: FieldRef<"Orientacao", 'String'>
    readonly licencas: FieldRef<"Orientacao", 'String'>
    readonly seguranca: FieldRef<"Orientacao", 'String'>
    readonly governance: FieldRef<"Orientacao", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Orientacao findUnique
   */
  export type OrientacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * Filter, which Orientacao to fetch.
     */
    where: OrientacaoWhereUniqueInput
  }

  /**
   * Orientacao findUniqueOrThrow
   */
  export type OrientacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * Filter, which Orientacao to fetch.
     */
    where: OrientacaoWhereUniqueInput
  }

  /**
   * Orientacao findFirst
   */
  export type OrientacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * Filter, which Orientacao to fetch.
     */
    where?: OrientacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orientacaos to fetch.
     */
    orderBy?: OrientacaoOrderByWithRelationInput | OrientacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orientacaos.
     */
    cursor?: OrientacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orientacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orientacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orientacaos.
     */
    distinct?: OrientacaoScalarFieldEnum | OrientacaoScalarFieldEnum[]
  }

  /**
   * Orientacao findFirstOrThrow
   */
  export type OrientacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * Filter, which Orientacao to fetch.
     */
    where?: OrientacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orientacaos to fetch.
     */
    orderBy?: OrientacaoOrderByWithRelationInput | OrientacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orientacaos.
     */
    cursor?: OrientacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orientacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orientacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orientacaos.
     */
    distinct?: OrientacaoScalarFieldEnum | OrientacaoScalarFieldEnum[]
  }

  /**
   * Orientacao findMany
   */
  export type OrientacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * Filter, which Orientacaos to fetch.
     */
    where?: OrientacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orientacaos to fetch.
     */
    orderBy?: OrientacaoOrderByWithRelationInput | OrientacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orientacaos.
     */
    cursor?: OrientacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orientacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orientacaos.
     */
    skip?: number
    distinct?: OrientacaoScalarFieldEnum | OrientacaoScalarFieldEnum[]
  }

  /**
   * Orientacao create
   */
  export type OrientacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Orientacao.
     */
    data: XOR<OrientacaoCreateInput, OrientacaoUncheckedCreateInput>
  }

  /**
   * Orientacao createMany
   */
  export type OrientacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orientacaos.
     */
    data: OrientacaoCreateManyInput | OrientacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Orientacao createManyAndReturn
   */
  export type OrientacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orientacaos.
     */
    data: OrientacaoCreateManyInput | OrientacaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orientacao update
   */
  export type OrientacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Orientacao.
     */
    data: XOR<OrientacaoUpdateInput, OrientacaoUncheckedUpdateInput>
    /**
     * Choose, which Orientacao to update.
     */
    where: OrientacaoWhereUniqueInput
  }

  /**
   * Orientacao updateMany
   */
  export type OrientacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orientacaos.
     */
    data: XOR<OrientacaoUpdateManyMutationInput, OrientacaoUncheckedUpdateManyInput>
    /**
     * Filter which Orientacaos to update
     */
    where?: OrientacaoWhereInput
  }

  /**
   * Orientacao upsert
   */
  export type OrientacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Orientacao to update in case it exists.
     */
    where: OrientacaoWhereUniqueInput
    /**
     * In case the Orientacao found by the `where` argument doesn't exist, create a new Orientacao with this data.
     */
    create: XOR<OrientacaoCreateInput, OrientacaoUncheckedCreateInput>
    /**
     * In case the Orientacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrientacaoUpdateInput, OrientacaoUncheckedUpdateInput>
  }

  /**
   * Orientacao delete
   */
  export type OrientacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
    /**
     * Filter which Orientacao to delete.
     */
    where: OrientacaoWhereUniqueInput
  }

  /**
   * Orientacao deleteMany
   */
  export type OrientacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orientacaos to delete
     */
    where?: OrientacaoWhereInput
  }

  /**
   * Orientacao without action
   */
  export type OrientacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orientacao
     */
    select?: OrientacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrientacaoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProjetoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    clienteId: 'clienteId',
    descricao: 'descricao',
    status: 'status',
    progresso: 'progresso',
    dataCriacao: 'dataCriacao',
    dataAtualizacao: 'dataAtualizacao'
  };

  export type ProjetoScalarFieldEnum = (typeof ProjetoScalarFieldEnum)[keyof typeof ProjetoScalarFieldEnum]


  export const AnalystScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    papel: 'papel',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type AnalystScalarFieldEnum = (typeof AnalystScalarFieldEnum)[keyof typeof AnalystScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    dominio: 'dominio',
    segmento: 'segmento',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const DecisionLogScalarFieldEnum: {
    id: 'id',
    analistaId: 'analistaId',
    deploymentId: 'deploymentId',
    descricao: 'descricao',
    criadoEm: 'criadoEm'
  };

  export type DecisionLogScalarFieldEnum = (typeof DecisionLogScalarFieldEnum)[keyof typeof DecisionLogScalarFieldEnum]


  export const LogProjetoScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    mensagem: 'mensagem',
    criadoEm: 'criadoEm'
  };

  export type LogProjetoScalarFieldEnum = (typeof LogProjetoScalarFieldEnum)[keyof typeof LogProjetoScalarFieldEnum]


  export const DeploymentScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    modelSelected: 'modelSelected',
    licensing: 'licensing',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeploymentScalarFieldEnum = (typeof DeploymentScalarFieldEnum)[keyof typeof DeploymentScalarFieldEnum]


  export const LevantamentoScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    nome: 'nome',
    categoria: 'categoria',
    criticidade: 'criticidade',
    tempoEstimado: 'tempoEstimado',
    selecionado: 'selecionado',
    observacoes: 'observacoes'
  };

  export type LevantamentoScalarFieldEnum = (typeof LevantamentoScalarFieldEnum)[keyof typeof LevantamentoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    nome: 'nome',
    departamento: 'departamento',
    cargo: 'cargo',
    email: 'email',
    caixaMB: 'caixaMB',
    officeLocal: 'officeLocal',
    migrarEmail: 'migrarEmail',
    oneDrive: 'oneDrive',
    sharePoint: 'sharePoint',
    teams: 'teams',
    criadoEm: 'criadoEm'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EmailConfigScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    plataformaOrigem: 'plataformaOrigem',
    metodologia: 'metodologia',
    janelaMigracao: 'janelaMigracao',
    volumeTotalMB: 'volumeTotalMB',
    migrarCalendarios: 'migrarCalendarios',
    migrarContatos: 'migrarContatos',
    backupPst: 'backupPst',
    caixasCompartilhadas: 'caixasCompartilhadas',
    gruposDistribuicao: 'gruposDistribuicao',
    observacoes: 'observacoes'
  };

  export type EmailConfigScalarFieldEnum = (typeof EmailConfigScalarFieldEnum)[keyof typeof EmailConfigScalarFieldEnum]


  export const SharePointSiteScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    nome: 'nome',
    tipo: 'tipo',
    proposito: 'proposito',
    proprietarios: 'proprietarios',
    membros: 'membros',
    nivelAcesso: 'nivelAcesso',
    volumeGB: 'volumeGB',
    pastaOrigem: 'pastaOrigem'
  };

  export type SharePointSiteScalarFieldEnum = (typeof SharePointSiteScalarFieldEnum)[keyof typeof SharePointSiteScalarFieldEnum]


  export const TeamsConfigScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    nomeEquipe: 'nomeEquipe',
    tipoEquipe: 'tipoEquipe',
    proposito: 'proposito',
    proprietarios: 'proprietarios',
    membrosIniciais: 'membrosIniciais',
    canais: 'canais',
    recursos: 'recursos',
    observacoes: 'observacoes'
  };

  export type TeamsConfigScalarFieldEnum = (typeof TeamsConfigScalarFieldEnum)[keyof typeof TeamsConfigScalarFieldEnum]


  export const CronogramaItemScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    nome: 'nome',
    responsavel: 'responsavel',
    inicio: 'inicio',
    fim: 'fim',
    status: 'status',
    ordem: 'ordem'
  };

  export type CronogramaItemScalarFieldEnum = (typeof CronogramaItemScalarFieldEnum)[keyof typeof CronogramaItemScalarFieldEnum]


  export const LicenciamentoScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    m365basic: 'm365basic',
    m365standard: 'm365standard',
    appsforbusiness: 'appsforbusiness',
    f3: 'f3',
    e3: 'e3',
    e5: 'e5',
    observacoes: 'observacoes'
  };

  export type LicenciamentoScalarFieldEnum = (typeof LicenciamentoScalarFieldEnum)[keyof typeof LicenciamentoScalarFieldEnum]


  export const OrientacaoScalarFieldEnum: {
    id: 'id',
    projetoId: 'projetoId',
    teams: 'teams',
    sharepoint: 'sharepoint',
    emails: 'emails',
    licencas: 'licencas',
    seguranca: 'seguranca',
    governance: 'governance'
  };

  export type OrientacaoScalarFieldEnum = (typeof OrientacaoScalarFieldEnum)[keyof typeof OrientacaoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProjetoWhereInput = {
    AND?: ProjetoWhereInput | ProjetoWhereInput[]
    OR?: ProjetoWhereInput[]
    NOT?: ProjetoWhereInput | ProjetoWhereInput[]
    id?: StringFilter<"Projeto"> | string
    nome?: StringFilter<"Projeto"> | string
    clienteId?: StringFilter<"Projeto"> | string
    descricao?: StringNullableFilter<"Projeto"> | string | null
    status?: StringFilter<"Projeto"> | string
    progresso?: IntFilter<"Projeto"> | number
    dataCriacao?: DateTimeFilter<"Projeto"> | Date | string
    dataAtualizacao?: DateTimeFilter<"Projeto"> | Date | string
    cliente?: XOR<ClientRelationFilter, ClientWhereInput>
    levantamento?: LevantamentoListRelationFilter
    usuarios?: UsuarioListRelationFilter
    emailConfig?: XOR<EmailConfigNullableRelationFilter, EmailConfigWhereInput> | null
    sharepoint?: SharePointSiteListRelationFilter
    teams?: XOR<TeamsConfigNullableRelationFilter, TeamsConfigWhereInput> | null
    cronograma?: CronogramaItemListRelationFilter
    licenciamento?: XOR<LicenciamentoNullableRelationFilter, LicenciamentoWhereInput> | null
    orientacoes?: XOR<OrientacaoNullableRelationFilter, OrientacaoWhereInput> | null
    logs?: LogProjetoListRelationFilter
  }

  export type ProjetoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    clienteId?: SortOrder
    descricao?: SortOrderInput | SortOrder
    status?: SortOrder
    progresso?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
    cliente?: ClientOrderByWithRelationInput
    levantamento?: LevantamentoOrderByRelationAggregateInput
    usuarios?: UsuarioOrderByRelationAggregateInput
    emailConfig?: EmailConfigOrderByWithRelationInput
    sharepoint?: SharePointSiteOrderByRelationAggregateInput
    teams?: TeamsConfigOrderByWithRelationInput
    cronograma?: CronogramaItemOrderByRelationAggregateInput
    licenciamento?: LicenciamentoOrderByWithRelationInput
    orientacoes?: OrientacaoOrderByWithRelationInput
    logs?: LogProjetoOrderByRelationAggregateInput
  }

  export type ProjetoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjetoWhereInput | ProjetoWhereInput[]
    OR?: ProjetoWhereInput[]
    NOT?: ProjetoWhereInput | ProjetoWhereInput[]
    nome?: StringFilter<"Projeto"> | string
    clienteId?: StringFilter<"Projeto"> | string
    descricao?: StringNullableFilter<"Projeto"> | string | null
    status?: StringFilter<"Projeto"> | string
    progresso?: IntFilter<"Projeto"> | number
    dataCriacao?: DateTimeFilter<"Projeto"> | Date | string
    dataAtualizacao?: DateTimeFilter<"Projeto"> | Date | string
    cliente?: XOR<ClientRelationFilter, ClientWhereInput>
    levantamento?: LevantamentoListRelationFilter
    usuarios?: UsuarioListRelationFilter
    emailConfig?: XOR<EmailConfigNullableRelationFilter, EmailConfigWhereInput> | null
    sharepoint?: SharePointSiteListRelationFilter
    teams?: XOR<TeamsConfigNullableRelationFilter, TeamsConfigWhereInput> | null
    cronograma?: CronogramaItemListRelationFilter
    licenciamento?: XOR<LicenciamentoNullableRelationFilter, LicenciamentoWhereInput> | null
    orientacoes?: XOR<OrientacaoNullableRelationFilter, OrientacaoWhereInput> | null
    logs?: LogProjetoListRelationFilter
  }, "id">

  export type ProjetoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    clienteId?: SortOrder
    descricao?: SortOrderInput | SortOrder
    status?: SortOrder
    progresso?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
    _count?: ProjetoCountOrderByAggregateInput
    _avg?: ProjetoAvgOrderByAggregateInput
    _max?: ProjetoMaxOrderByAggregateInput
    _min?: ProjetoMinOrderByAggregateInput
    _sum?: ProjetoSumOrderByAggregateInput
  }

  export type ProjetoScalarWhereWithAggregatesInput = {
    AND?: ProjetoScalarWhereWithAggregatesInput | ProjetoScalarWhereWithAggregatesInput[]
    OR?: ProjetoScalarWhereWithAggregatesInput[]
    NOT?: ProjetoScalarWhereWithAggregatesInput | ProjetoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Projeto"> | string
    nome?: StringWithAggregatesFilter<"Projeto"> | string
    clienteId?: StringWithAggregatesFilter<"Projeto"> | string
    descricao?: StringNullableWithAggregatesFilter<"Projeto"> | string | null
    status?: StringWithAggregatesFilter<"Projeto"> | string
    progresso?: IntWithAggregatesFilter<"Projeto"> | number
    dataCriacao?: DateTimeWithAggregatesFilter<"Projeto"> | Date | string
    dataAtualizacao?: DateTimeWithAggregatesFilter<"Projeto"> | Date | string
  }

  export type AnalystWhereInput = {
    AND?: AnalystWhereInput | AnalystWhereInput[]
    OR?: AnalystWhereInput[]
    NOT?: AnalystWhereInput | AnalystWhereInput[]
    id?: StringFilter<"Analyst"> | string
    nome?: StringFilter<"Analyst"> | string
    email?: StringFilter<"Analyst"> | string
    senha?: StringFilter<"Analyst"> | string
    papel?: StringFilter<"Analyst"> | string
    criadoEm?: DateTimeFilter<"Analyst"> | Date | string
    atualizadoEm?: DateTimeFilter<"Analyst"> | Date | string
    logs?: DecisionLogListRelationFilter
  }

  export type AnalystOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    papel?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    logs?: DecisionLogOrderByRelationAggregateInput
  }

  export type AnalystWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AnalystWhereInput | AnalystWhereInput[]
    OR?: AnalystWhereInput[]
    NOT?: AnalystWhereInput | AnalystWhereInput[]
    nome?: StringFilter<"Analyst"> | string
    senha?: StringFilter<"Analyst"> | string
    papel?: StringFilter<"Analyst"> | string
    criadoEm?: DateTimeFilter<"Analyst"> | Date | string
    atualizadoEm?: DateTimeFilter<"Analyst"> | Date | string
    logs?: DecisionLogListRelationFilter
  }, "id" | "email">

  export type AnalystOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    papel?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: AnalystCountOrderByAggregateInput
    _max?: AnalystMaxOrderByAggregateInput
    _min?: AnalystMinOrderByAggregateInput
  }

  export type AnalystScalarWhereWithAggregatesInput = {
    AND?: AnalystScalarWhereWithAggregatesInput | AnalystScalarWhereWithAggregatesInput[]
    OR?: AnalystScalarWhereWithAggregatesInput[]
    NOT?: AnalystScalarWhereWithAggregatesInput | AnalystScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analyst"> | string
    nome?: StringWithAggregatesFilter<"Analyst"> | string
    email?: StringWithAggregatesFilter<"Analyst"> | string
    senha?: StringWithAggregatesFilter<"Analyst"> | string
    papel?: StringWithAggregatesFilter<"Analyst"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Analyst"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Analyst"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    nome?: StringFilter<"Client"> | string
    dominio?: StringFilter<"Client"> | string
    segmento?: StringFilter<"Client"> | string
    criadoEm?: DateTimeFilter<"Client"> | Date | string
    atualizadoEm?: DateTimeFilter<"Client"> | Date | string
    projetos?: ProjetoListRelationFilter
    deployments?: DeploymentListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    dominio?: SortOrder
    segmento?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    projetos?: ProjetoOrderByRelationAggregateInput
    deployments?: DeploymentOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dominio?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    nome?: StringFilter<"Client"> | string
    segmento?: StringFilter<"Client"> | string
    criadoEm?: DateTimeFilter<"Client"> | Date | string
    atualizadoEm?: DateTimeFilter<"Client"> | Date | string
    projetos?: ProjetoListRelationFilter
    deployments?: DeploymentListRelationFilter
  }, "id" | "dominio">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    dominio?: SortOrder
    segmento?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    nome?: StringWithAggregatesFilter<"Client"> | string
    dominio?: StringWithAggregatesFilter<"Client"> | string
    segmento?: StringWithAggregatesFilter<"Client"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type DecisionLogWhereInput = {
    AND?: DecisionLogWhereInput | DecisionLogWhereInput[]
    OR?: DecisionLogWhereInput[]
    NOT?: DecisionLogWhereInput | DecisionLogWhereInput[]
    id?: StringFilter<"DecisionLog"> | string
    analistaId?: StringFilter<"DecisionLog"> | string
    deploymentId?: StringFilter<"DecisionLog"> | string
    descricao?: StringFilter<"DecisionLog"> | string
    criadoEm?: DateTimeFilter<"DecisionLog"> | Date | string
    analista?: XOR<AnalystRelationFilter, AnalystWhereInput>
    deployment?: XOR<DeploymentRelationFilter, DeploymentWhereInput>
  }

  export type DecisionLogOrderByWithRelationInput = {
    id?: SortOrder
    analistaId?: SortOrder
    deploymentId?: SortOrder
    descricao?: SortOrder
    criadoEm?: SortOrder
    analista?: AnalystOrderByWithRelationInput
    deployment?: DeploymentOrderByWithRelationInput
  }

  export type DecisionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DecisionLogWhereInput | DecisionLogWhereInput[]
    OR?: DecisionLogWhereInput[]
    NOT?: DecisionLogWhereInput | DecisionLogWhereInput[]
    analistaId?: StringFilter<"DecisionLog"> | string
    deploymentId?: StringFilter<"DecisionLog"> | string
    descricao?: StringFilter<"DecisionLog"> | string
    criadoEm?: DateTimeFilter<"DecisionLog"> | Date | string
    analista?: XOR<AnalystRelationFilter, AnalystWhereInput>
    deployment?: XOR<DeploymentRelationFilter, DeploymentWhereInput>
  }, "id">

  export type DecisionLogOrderByWithAggregationInput = {
    id?: SortOrder
    analistaId?: SortOrder
    deploymentId?: SortOrder
    descricao?: SortOrder
    criadoEm?: SortOrder
    _count?: DecisionLogCountOrderByAggregateInput
    _max?: DecisionLogMaxOrderByAggregateInput
    _min?: DecisionLogMinOrderByAggregateInput
  }

  export type DecisionLogScalarWhereWithAggregatesInput = {
    AND?: DecisionLogScalarWhereWithAggregatesInput | DecisionLogScalarWhereWithAggregatesInput[]
    OR?: DecisionLogScalarWhereWithAggregatesInput[]
    NOT?: DecisionLogScalarWhereWithAggregatesInput | DecisionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DecisionLog"> | string
    analistaId?: StringWithAggregatesFilter<"DecisionLog"> | string
    deploymentId?: StringWithAggregatesFilter<"DecisionLog"> | string
    descricao?: StringWithAggregatesFilter<"DecisionLog"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"DecisionLog"> | Date | string
  }

  export type LogProjetoWhereInput = {
    AND?: LogProjetoWhereInput | LogProjetoWhereInput[]
    OR?: LogProjetoWhereInput[]
    NOT?: LogProjetoWhereInput | LogProjetoWhereInput[]
    id?: StringFilter<"LogProjeto"> | string
    projetoId?: StringFilter<"LogProjeto"> | string
    mensagem?: StringFilter<"LogProjeto"> | string
    criadoEm?: DateTimeFilter<"LogProjeto"> | Date | string
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type LogProjetoOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    mensagem?: SortOrder
    criadoEm?: SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type LogProjetoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogProjetoWhereInput | LogProjetoWhereInput[]
    OR?: LogProjetoWhereInput[]
    NOT?: LogProjetoWhereInput | LogProjetoWhereInput[]
    projetoId?: StringFilter<"LogProjeto"> | string
    mensagem?: StringFilter<"LogProjeto"> | string
    criadoEm?: DateTimeFilter<"LogProjeto"> | Date | string
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id">

  export type LogProjetoOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    mensagem?: SortOrder
    criadoEm?: SortOrder
    _count?: LogProjetoCountOrderByAggregateInput
    _max?: LogProjetoMaxOrderByAggregateInput
    _min?: LogProjetoMinOrderByAggregateInput
  }

  export type LogProjetoScalarWhereWithAggregatesInput = {
    AND?: LogProjetoScalarWhereWithAggregatesInput | LogProjetoScalarWhereWithAggregatesInput[]
    OR?: LogProjetoScalarWhereWithAggregatesInput[]
    NOT?: LogProjetoScalarWhereWithAggregatesInput | LogProjetoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogProjeto"> | string
    projetoId?: StringWithAggregatesFilter<"LogProjeto"> | string
    mensagem?: StringWithAggregatesFilter<"LogProjeto"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"LogProjeto"> | Date | string
  }

  export type DeploymentWhereInput = {
    AND?: DeploymentWhereInput | DeploymentWhereInput[]
    OR?: DeploymentWhereInput[]
    NOT?: DeploymentWhereInput | DeploymentWhereInput[]
    id?: StringFilter<"Deployment"> | string
    clientId?: StringFilter<"Deployment"> | string
    modelSelected?: StringFilter<"Deployment"> | string
    licensing?: StringFilter<"Deployment"> | string
    status?: StringFilter<"Deployment"> | string
    notes?: StringNullableFilter<"Deployment"> | string | null
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    decisions?: DecisionLogListRelationFilter
  }

  export type DeploymentOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    modelSelected?: SortOrder
    licensing?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    decisions?: DecisionLogOrderByRelationAggregateInput
  }

  export type DeploymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentWhereInput | DeploymentWhereInput[]
    OR?: DeploymentWhereInput[]
    NOT?: DeploymentWhereInput | DeploymentWhereInput[]
    clientId?: StringFilter<"Deployment"> | string
    modelSelected?: StringFilter<"Deployment"> | string
    licensing?: StringFilter<"Deployment"> | string
    status?: StringFilter<"Deployment"> | string
    notes?: StringNullableFilter<"Deployment"> | string | null
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    decisions?: DecisionLogListRelationFilter
  }, "id">

  export type DeploymentOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    modelSelected?: SortOrder
    licensing?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeploymentCountOrderByAggregateInput
    _max?: DeploymentMaxOrderByAggregateInput
    _min?: DeploymentMinOrderByAggregateInput
  }

  export type DeploymentScalarWhereWithAggregatesInput = {
    AND?: DeploymentScalarWhereWithAggregatesInput | DeploymentScalarWhereWithAggregatesInput[]
    OR?: DeploymentScalarWhereWithAggregatesInput[]
    NOT?: DeploymentScalarWhereWithAggregatesInput | DeploymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deployment"> | string
    clientId?: StringWithAggregatesFilter<"Deployment"> | string
    modelSelected?: StringWithAggregatesFilter<"Deployment"> | string
    licensing?: StringWithAggregatesFilter<"Deployment"> | string
    status?: StringWithAggregatesFilter<"Deployment"> | string
    notes?: StringNullableWithAggregatesFilter<"Deployment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deployment"> | Date | string
  }

  export type LevantamentoWhereInput = {
    AND?: LevantamentoWhereInput | LevantamentoWhereInput[]
    OR?: LevantamentoWhereInput[]
    NOT?: LevantamentoWhereInput | LevantamentoWhereInput[]
    id?: StringFilter<"Levantamento"> | string
    projetoId?: StringFilter<"Levantamento"> | string
    nome?: StringFilter<"Levantamento"> | string
    categoria?: StringFilter<"Levantamento"> | string
    criticidade?: StringFilter<"Levantamento"> | string
    tempoEstimado?: IntFilter<"Levantamento"> | number
    selecionado?: BoolFilter<"Levantamento"> | boolean
    observacoes?: StringNullableFilter<"Levantamento"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type LevantamentoOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    criticidade?: SortOrder
    tempoEstimado?: SortOrder
    selecionado?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type LevantamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LevantamentoWhereInput | LevantamentoWhereInput[]
    OR?: LevantamentoWhereInput[]
    NOT?: LevantamentoWhereInput | LevantamentoWhereInput[]
    projetoId?: StringFilter<"Levantamento"> | string
    nome?: StringFilter<"Levantamento"> | string
    categoria?: StringFilter<"Levantamento"> | string
    criticidade?: StringFilter<"Levantamento"> | string
    tempoEstimado?: IntFilter<"Levantamento"> | number
    selecionado?: BoolFilter<"Levantamento"> | boolean
    observacoes?: StringNullableFilter<"Levantamento"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id">

  export type LevantamentoOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    criticidade?: SortOrder
    tempoEstimado?: SortOrder
    selecionado?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    _count?: LevantamentoCountOrderByAggregateInput
    _avg?: LevantamentoAvgOrderByAggregateInput
    _max?: LevantamentoMaxOrderByAggregateInput
    _min?: LevantamentoMinOrderByAggregateInput
    _sum?: LevantamentoSumOrderByAggregateInput
  }

  export type LevantamentoScalarWhereWithAggregatesInput = {
    AND?: LevantamentoScalarWhereWithAggregatesInput | LevantamentoScalarWhereWithAggregatesInput[]
    OR?: LevantamentoScalarWhereWithAggregatesInput[]
    NOT?: LevantamentoScalarWhereWithAggregatesInput | LevantamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Levantamento"> | string
    projetoId?: StringWithAggregatesFilter<"Levantamento"> | string
    nome?: StringWithAggregatesFilter<"Levantamento"> | string
    categoria?: StringWithAggregatesFilter<"Levantamento"> | string
    criticidade?: StringWithAggregatesFilter<"Levantamento"> | string
    tempoEstimado?: IntWithAggregatesFilter<"Levantamento"> | number
    selecionado?: BoolWithAggregatesFilter<"Levantamento"> | boolean
    observacoes?: StringNullableWithAggregatesFilter<"Levantamento"> | string | null
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    projetoId?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    departamento?: StringNullableFilter<"Usuario"> | string | null
    cargo?: StringNullableFilter<"Usuario"> | string | null
    email?: StringFilter<"Usuario"> | string
    caixaMB?: IntNullableFilter<"Usuario"> | number | null
    officeLocal?: BoolFilter<"Usuario"> | boolean
    migrarEmail?: BoolFilter<"Usuario"> | boolean
    oneDrive?: BoolFilter<"Usuario"> | boolean
    sharePoint?: BoolFilter<"Usuario"> | boolean
    teams?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    departamento?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    email?: SortOrder
    caixaMB?: SortOrderInput | SortOrder
    officeLocal?: SortOrder
    migrarEmail?: SortOrder
    oneDrive?: SortOrder
    sharePoint?: SortOrder
    teams?: SortOrder
    criadoEm?: SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    projetoId?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    departamento?: StringNullableFilter<"Usuario"> | string | null
    cargo?: StringNullableFilter<"Usuario"> | string | null
    email?: StringFilter<"Usuario"> | string
    caixaMB?: IntNullableFilter<"Usuario"> | number | null
    officeLocal?: BoolFilter<"Usuario"> | boolean
    migrarEmail?: BoolFilter<"Usuario"> | boolean
    oneDrive?: BoolFilter<"Usuario"> | boolean
    sharePoint?: BoolFilter<"Usuario"> | boolean
    teams?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    departamento?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    email?: SortOrder
    caixaMB?: SortOrderInput | SortOrder
    officeLocal?: SortOrder
    migrarEmail?: SortOrder
    oneDrive?: SortOrder
    sharePoint?: SortOrder
    teams?: SortOrder
    criadoEm?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    projetoId?: StringWithAggregatesFilter<"Usuario"> | string
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    departamento?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    cargo?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    email?: StringWithAggregatesFilter<"Usuario"> | string
    caixaMB?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
    officeLocal?: BoolWithAggregatesFilter<"Usuario"> | boolean
    migrarEmail?: BoolWithAggregatesFilter<"Usuario"> | boolean
    oneDrive?: BoolWithAggregatesFilter<"Usuario"> | boolean
    sharePoint?: BoolWithAggregatesFilter<"Usuario"> | boolean
    teams?: BoolWithAggregatesFilter<"Usuario"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type EmailConfigWhereInput = {
    AND?: EmailConfigWhereInput | EmailConfigWhereInput[]
    OR?: EmailConfigWhereInput[]
    NOT?: EmailConfigWhereInput | EmailConfigWhereInput[]
    id?: StringFilter<"EmailConfig"> | string
    projetoId?: StringFilter<"EmailConfig"> | string
    plataformaOrigem?: StringFilter<"EmailConfig"> | string
    metodologia?: StringNullableFilter<"EmailConfig"> | string | null
    janelaMigracao?: StringNullableFilter<"EmailConfig"> | string | null
    volumeTotalMB?: IntNullableFilter<"EmailConfig"> | number | null
    migrarCalendarios?: BoolFilter<"EmailConfig"> | boolean
    migrarContatos?: BoolFilter<"EmailConfig"> | boolean
    backupPst?: BoolFilter<"EmailConfig"> | boolean
    caixasCompartilhadas?: StringNullableFilter<"EmailConfig"> | string | null
    gruposDistribuicao?: StringNullableFilter<"EmailConfig"> | string | null
    observacoes?: StringNullableFilter<"EmailConfig"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type EmailConfigOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    plataformaOrigem?: SortOrder
    metodologia?: SortOrderInput | SortOrder
    janelaMigracao?: SortOrderInput | SortOrder
    volumeTotalMB?: SortOrderInput | SortOrder
    migrarCalendarios?: SortOrder
    migrarContatos?: SortOrder
    backupPst?: SortOrder
    caixasCompartilhadas?: SortOrderInput | SortOrder
    gruposDistribuicao?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type EmailConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projetoId?: string
    AND?: EmailConfigWhereInput | EmailConfigWhereInput[]
    OR?: EmailConfigWhereInput[]
    NOT?: EmailConfigWhereInput | EmailConfigWhereInput[]
    plataformaOrigem?: StringFilter<"EmailConfig"> | string
    metodologia?: StringNullableFilter<"EmailConfig"> | string | null
    janelaMigracao?: StringNullableFilter<"EmailConfig"> | string | null
    volumeTotalMB?: IntNullableFilter<"EmailConfig"> | number | null
    migrarCalendarios?: BoolFilter<"EmailConfig"> | boolean
    migrarContatos?: BoolFilter<"EmailConfig"> | boolean
    backupPst?: BoolFilter<"EmailConfig"> | boolean
    caixasCompartilhadas?: StringNullableFilter<"EmailConfig"> | string | null
    gruposDistribuicao?: StringNullableFilter<"EmailConfig"> | string | null
    observacoes?: StringNullableFilter<"EmailConfig"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id" | "projetoId">

  export type EmailConfigOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    plataformaOrigem?: SortOrder
    metodologia?: SortOrderInput | SortOrder
    janelaMigracao?: SortOrderInput | SortOrder
    volumeTotalMB?: SortOrderInput | SortOrder
    migrarCalendarios?: SortOrder
    migrarContatos?: SortOrder
    backupPst?: SortOrder
    caixasCompartilhadas?: SortOrderInput | SortOrder
    gruposDistribuicao?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    _count?: EmailConfigCountOrderByAggregateInput
    _avg?: EmailConfigAvgOrderByAggregateInput
    _max?: EmailConfigMaxOrderByAggregateInput
    _min?: EmailConfigMinOrderByAggregateInput
    _sum?: EmailConfigSumOrderByAggregateInput
  }

  export type EmailConfigScalarWhereWithAggregatesInput = {
    AND?: EmailConfigScalarWhereWithAggregatesInput | EmailConfigScalarWhereWithAggregatesInput[]
    OR?: EmailConfigScalarWhereWithAggregatesInput[]
    NOT?: EmailConfigScalarWhereWithAggregatesInput | EmailConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailConfig"> | string
    projetoId?: StringWithAggregatesFilter<"EmailConfig"> | string
    plataformaOrigem?: StringWithAggregatesFilter<"EmailConfig"> | string
    metodologia?: StringNullableWithAggregatesFilter<"EmailConfig"> | string | null
    janelaMigracao?: StringNullableWithAggregatesFilter<"EmailConfig"> | string | null
    volumeTotalMB?: IntNullableWithAggregatesFilter<"EmailConfig"> | number | null
    migrarCalendarios?: BoolWithAggregatesFilter<"EmailConfig"> | boolean
    migrarContatos?: BoolWithAggregatesFilter<"EmailConfig"> | boolean
    backupPst?: BoolWithAggregatesFilter<"EmailConfig"> | boolean
    caixasCompartilhadas?: StringNullableWithAggregatesFilter<"EmailConfig"> | string | null
    gruposDistribuicao?: StringNullableWithAggregatesFilter<"EmailConfig"> | string | null
    observacoes?: StringNullableWithAggregatesFilter<"EmailConfig"> | string | null
  }

  export type SharePointSiteWhereInput = {
    AND?: SharePointSiteWhereInput | SharePointSiteWhereInput[]
    OR?: SharePointSiteWhereInput[]
    NOT?: SharePointSiteWhereInput | SharePointSiteWhereInput[]
    id?: StringFilter<"SharePointSite"> | string
    projetoId?: StringFilter<"SharePointSite"> | string
    nome?: StringFilter<"SharePointSite"> | string
    tipo?: StringFilter<"SharePointSite"> | string
    proposito?: StringNullableFilter<"SharePointSite"> | string | null
    proprietarios?: StringNullableFilter<"SharePointSite"> | string | null
    membros?: StringNullableFilter<"SharePointSite"> | string | null
    nivelAcesso?: StringNullableFilter<"SharePointSite"> | string | null
    volumeGB?: FloatNullableFilter<"SharePointSite"> | number | null
    pastaOrigem?: StringNullableFilter<"SharePointSite"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type SharePointSiteOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    proposito?: SortOrderInput | SortOrder
    proprietarios?: SortOrderInput | SortOrder
    membros?: SortOrderInput | SortOrder
    nivelAcesso?: SortOrderInput | SortOrder
    volumeGB?: SortOrderInput | SortOrder
    pastaOrigem?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type SharePointSiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharePointSiteWhereInput | SharePointSiteWhereInput[]
    OR?: SharePointSiteWhereInput[]
    NOT?: SharePointSiteWhereInput | SharePointSiteWhereInput[]
    projetoId?: StringFilter<"SharePointSite"> | string
    nome?: StringFilter<"SharePointSite"> | string
    tipo?: StringFilter<"SharePointSite"> | string
    proposito?: StringNullableFilter<"SharePointSite"> | string | null
    proprietarios?: StringNullableFilter<"SharePointSite"> | string | null
    membros?: StringNullableFilter<"SharePointSite"> | string | null
    nivelAcesso?: StringNullableFilter<"SharePointSite"> | string | null
    volumeGB?: FloatNullableFilter<"SharePointSite"> | number | null
    pastaOrigem?: StringNullableFilter<"SharePointSite"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id">

  export type SharePointSiteOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    proposito?: SortOrderInput | SortOrder
    proprietarios?: SortOrderInput | SortOrder
    membros?: SortOrderInput | SortOrder
    nivelAcesso?: SortOrderInput | SortOrder
    volumeGB?: SortOrderInput | SortOrder
    pastaOrigem?: SortOrderInput | SortOrder
    _count?: SharePointSiteCountOrderByAggregateInput
    _avg?: SharePointSiteAvgOrderByAggregateInput
    _max?: SharePointSiteMaxOrderByAggregateInput
    _min?: SharePointSiteMinOrderByAggregateInput
    _sum?: SharePointSiteSumOrderByAggregateInput
  }

  export type SharePointSiteScalarWhereWithAggregatesInput = {
    AND?: SharePointSiteScalarWhereWithAggregatesInput | SharePointSiteScalarWhereWithAggregatesInput[]
    OR?: SharePointSiteScalarWhereWithAggregatesInput[]
    NOT?: SharePointSiteScalarWhereWithAggregatesInput | SharePointSiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharePointSite"> | string
    projetoId?: StringWithAggregatesFilter<"SharePointSite"> | string
    nome?: StringWithAggregatesFilter<"SharePointSite"> | string
    tipo?: StringWithAggregatesFilter<"SharePointSite"> | string
    proposito?: StringNullableWithAggregatesFilter<"SharePointSite"> | string | null
    proprietarios?: StringNullableWithAggregatesFilter<"SharePointSite"> | string | null
    membros?: StringNullableWithAggregatesFilter<"SharePointSite"> | string | null
    nivelAcesso?: StringNullableWithAggregatesFilter<"SharePointSite"> | string | null
    volumeGB?: FloatNullableWithAggregatesFilter<"SharePointSite"> | number | null
    pastaOrigem?: StringNullableWithAggregatesFilter<"SharePointSite"> | string | null
  }

  export type TeamsConfigWhereInput = {
    AND?: TeamsConfigWhereInput | TeamsConfigWhereInput[]
    OR?: TeamsConfigWhereInput[]
    NOT?: TeamsConfigWhereInput | TeamsConfigWhereInput[]
    id?: StringFilter<"TeamsConfig"> | string
    projetoId?: StringFilter<"TeamsConfig"> | string
    nomeEquipe?: StringNullableFilter<"TeamsConfig"> | string | null
    tipoEquipe?: StringNullableFilter<"TeamsConfig"> | string | null
    proposito?: StringNullableFilter<"TeamsConfig"> | string | null
    proprietarios?: StringNullableFilter<"TeamsConfig"> | string | null
    membrosIniciais?: StringNullableFilter<"TeamsConfig"> | string | null
    canais?: StringNullableFilter<"TeamsConfig"> | string | null
    recursos?: StringNullableFilter<"TeamsConfig"> | string | null
    observacoes?: StringNullableFilter<"TeamsConfig"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type TeamsConfigOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nomeEquipe?: SortOrderInput | SortOrder
    tipoEquipe?: SortOrderInput | SortOrder
    proposito?: SortOrderInput | SortOrder
    proprietarios?: SortOrderInput | SortOrder
    membrosIniciais?: SortOrderInput | SortOrder
    canais?: SortOrderInput | SortOrder
    recursos?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type TeamsConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projetoId?: string
    AND?: TeamsConfigWhereInput | TeamsConfigWhereInput[]
    OR?: TeamsConfigWhereInput[]
    NOT?: TeamsConfigWhereInput | TeamsConfigWhereInput[]
    nomeEquipe?: StringNullableFilter<"TeamsConfig"> | string | null
    tipoEquipe?: StringNullableFilter<"TeamsConfig"> | string | null
    proposito?: StringNullableFilter<"TeamsConfig"> | string | null
    proprietarios?: StringNullableFilter<"TeamsConfig"> | string | null
    membrosIniciais?: StringNullableFilter<"TeamsConfig"> | string | null
    canais?: StringNullableFilter<"TeamsConfig"> | string | null
    recursos?: StringNullableFilter<"TeamsConfig"> | string | null
    observacoes?: StringNullableFilter<"TeamsConfig"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id" | "projetoId">

  export type TeamsConfigOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nomeEquipe?: SortOrderInput | SortOrder
    tipoEquipe?: SortOrderInput | SortOrder
    proposito?: SortOrderInput | SortOrder
    proprietarios?: SortOrderInput | SortOrder
    membrosIniciais?: SortOrderInput | SortOrder
    canais?: SortOrderInput | SortOrder
    recursos?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    _count?: TeamsConfigCountOrderByAggregateInput
    _max?: TeamsConfigMaxOrderByAggregateInput
    _min?: TeamsConfigMinOrderByAggregateInput
  }

  export type TeamsConfigScalarWhereWithAggregatesInput = {
    AND?: TeamsConfigScalarWhereWithAggregatesInput | TeamsConfigScalarWhereWithAggregatesInput[]
    OR?: TeamsConfigScalarWhereWithAggregatesInput[]
    NOT?: TeamsConfigScalarWhereWithAggregatesInput | TeamsConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamsConfig"> | string
    projetoId?: StringWithAggregatesFilter<"TeamsConfig"> | string
    nomeEquipe?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    tipoEquipe?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    proposito?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    proprietarios?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    membrosIniciais?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    canais?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    recursos?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
    observacoes?: StringNullableWithAggregatesFilter<"TeamsConfig"> | string | null
  }

  export type CronogramaItemWhereInput = {
    AND?: CronogramaItemWhereInput | CronogramaItemWhereInput[]
    OR?: CronogramaItemWhereInput[]
    NOT?: CronogramaItemWhereInput | CronogramaItemWhereInput[]
    id?: StringFilter<"CronogramaItem"> | string
    projetoId?: StringFilter<"CronogramaItem"> | string
    nome?: StringFilter<"CronogramaItem"> | string
    responsavel?: StringNullableFilter<"CronogramaItem"> | string | null
    inicio?: DateTimeNullableFilter<"CronogramaItem"> | Date | string | null
    fim?: DateTimeNullableFilter<"CronogramaItem"> | Date | string | null
    status?: StringFilter<"CronogramaItem"> | string
    ordem?: IntNullableFilter<"CronogramaItem"> | number | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type CronogramaItemOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fim?: SortOrderInput | SortOrder
    status?: SortOrder
    ordem?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type CronogramaItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CronogramaItemWhereInput | CronogramaItemWhereInput[]
    OR?: CronogramaItemWhereInput[]
    NOT?: CronogramaItemWhereInput | CronogramaItemWhereInput[]
    projetoId?: StringFilter<"CronogramaItem"> | string
    nome?: StringFilter<"CronogramaItem"> | string
    responsavel?: StringNullableFilter<"CronogramaItem"> | string | null
    inicio?: DateTimeNullableFilter<"CronogramaItem"> | Date | string | null
    fim?: DateTimeNullableFilter<"CronogramaItem"> | Date | string | null
    status?: StringFilter<"CronogramaItem"> | string
    ordem?: IntNullableFilter<"CronogramaItem"> | number | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id">

  export type CronogramaItemOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fim?: SortOrderInput | SortOrder
    status?: SortOrder
    ordem?: SortOrderInput | SortOrder
    _count?: CronogramaItemCountOrderByAggregateInput
    _avg?: CronogramaItemAvgOrderByAggregateInput
    _max?: CronogramaItemMaxOrderByAggregateInput
    _min?: CronogramaItemMinOrderByAggregateInput
    _sum?: CronogramaItemSumOrderByAggregateInput
  }

  export type CronogramaItemScalarWhereWithAggregatesInput = {
    AND?: CronogramaItemScalarWhereWithAggregatesInput | CronogramaItemScalarWhereWithAggregatesInput[]
    OR?: CronogramaItemScalarWhereWithAggregatesInput[]
    NOT?: CronogramaItemScalarWhereWithAggregatesInput | CronogramaItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CronogramaItem"> | string
    projetoId?: StringWithAggregatesFilter<"CronogramaItem"> | string
    nome?: StringWithAggregatesFilter<"CronogramaItem"> | string
    responsavel?: StringNullableWithAggregatesFilter<"CronogramaItem"> | string | null
    inicio?: DateTimeNullableWithAggregatesFilter<"CronogramaItem"> | Date | string | null
    fim?: DateTimeNullableWithAggregatesFilter<"CronogramaItem"> | Date | string | null
    status?: StringWithAggregatesFilter<"CronogramaItem"> | string
    ordem?: IntNullableWithAggregatesFilter<"CronogramaItem"> | number | null
  }

  export type LicenciamentoWhereInput = {
    AND?: LicenciamentoWhereInput | LicenciamentoWhereInput[]
    OR?: LicenciamentoWhereInput[]
    NOT?: LicenciamentoWhereInput | LicenciamentoWhereInput[]
    id?: StringFilter<"Licenciamento"> | string
    projetoId?: StringFilter<"Licenciamento"> | string
    m365basic?: IntNullableFilter<"Licenciamento"> | number | null
    m365standard?: IntNullableFilter<"Licenciamento"> | number | null
    appsforbusiness?: IntNullableFilter<"Licenciamento"> | number | null
    f3?: IntNullableFilter<"Licenciamento"> | number | null
    e3?: IntNullableFilter<"Licenciamento"> | number | null
    e5?: IntNullableFilter<"Licenciamento"> | number | null
    observacoes?: StringNullableFilter<"Licenciamento"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type LicenciamentoOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    m365basic?: SortOrderInput | SortOrder
    m365standard?: SortOrderInput | SortOrder
    appsforbusiness?: SortOrderInput | SortOrder
    f3?: SortOrderInput | SortOrder
    e3?: SortOrderInput | SortOrder
    e5?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type LicenciamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projetoId?: string
    AND?: LicenciamentoWhereInput | LicenciamentoWhereInput[]
    OR?: LicenciamentoWhereInput[]
    NOT?: LicenciamentoWhereInput | LicenciamentoWhereInput[]
    m365basic?: IntNullableFilter<"Licenciamento"> | number | null
    m365standard?: IntNullableFilter<"Licenciamento"> | number | null
    appsforbusiness?: IntNullableFilter<"Licenciamento"> | number | null
    f3?: IntNullableFilter<"Licenciamento"> | number | null
    e3?: IntNullableFilter<"Licenciamento"> | number | null
    e5?: IntNullableFilter<"Licenciamento"> | number | null
    observacoes?: StringNullableFilter<"Licenciamento"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id" | "projetoId">

  export type LicenciamentoOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    m365basic?: SortOrderInput | SortOrder
    m365standard?: SortOrderInput | SortOrder
    appsforbusiness?: SortOrderInput | SortOrder
    f3?: SortOrderInput | SortOrder
    e3?: SortOrderInput | SortOrder
    e5?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    _count?: LicenciamentoCountOrderByAggregateInput
    _avg?: LicenciamentoAvgOrderByAggregateInput
    _max?: LicenciamentoMaxOrderByAggregateInput
    _min?: LicenciamentoMinOrderByAggregateInput
    _sum?: LicenciamentoSumOrderByAggregateInput
  }

  export type LicenciamentoScalarWhereWithAggregatesInput = {
    AND?: LicenciamentoScalarWhereWithAggregatesInput | LicenciamentoScalarWhereWithAggregatesInput[]
    OR?: LicenciamentoScalarWhereWithAggregatesInput[]
    NOT?: LicenciamentoScalarWhereWithAggregatesInput | LicenciamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Licenciamento"> | string
    projetoId?: StringWithAggregatesFilter<"Licenciamento"> | string
    m365basic?: IntNullableWithAggregatesFilter<"Licenciamento"> | number | null
    m365standard?: IntNullableWithAggregatesFilter<"Licenciamento"> | number | null
    appsforbusiness?: IntNullableWithAggregatesFilter<"Licenciamento"> | number | null
    f3?: IntNullableWithAggregatesFilter<"Licenciamento"> | number | null
    e3?: IntNullableWithAggregatesFilter<"Licenciamento"> | number | null
    e5?: IntNullableWithAggregatesFilter<"Licenciamento"> | number | null
    observacoes?: StringNullableWithAggregatesFilter<"Licenciamento"> | string | null
  }

  export type OrientacaoWhereInput = {
    AND?: OrientacaoWhereInput | OrientacaoWhereInput[]
    OR?: OrientacaoWhereInput[]
    NOT?: OrientacaoWhereInput | OrientacaoWhereInput[]
    id?: StringFilter<"Orientacao"> | string
    projetoId?: StringFilter<"Orientacao"> | string
    teams?: StringNullableFilter<"Orientacao"> | string | null
    sharepoint?: StringNullableFilter<"Orientacao"> | string | null
    emails?: StringNullableFilter<"Orientacao"> | string | null
    licencas?: StringNullableFilter<"Orientacao"> | string | null
    seguranca?: StringNullableFilter<"Orientacao"> | string | null
    governance?: StringNullableFilter<"Orientacao"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }

  export type OrientacaoOrderByWithRelationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    teams?: SortOrderInput | SortOrder
    sharepoint?: SortOrderInput | SortOrder
    emails?: SortOrderInput | SortOrder
    licencas?: SortOrderInput | SortOrder
    seguranca?: SortOrderInput | SortOrder
    governance?: SortOrderInput | SortOrder
    projeto?: ProjetoOrderByWithRelationInput
  }

  export type OrientacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projetoId?: string
    AND?: OrientacaoWhereInput | OrientacaoWhereInput[]
    OR?: OrientacaoWhereInput[]
    NOT?: OrientacaoWhereInput | OrientacaoWhereInput[]
    teams?: StringNullableFilter<"Orientacao"> | string | null
    sharepoint?: StringNullableFilter<"Orientacao"> | string | null
    emails?: StringNullableFilter<"Orientacao"> | string | null
    licencas?: StringNullableFilter<"Orientacao"> | string | null
    seguranca?: StringNullableFilter<"Orientacao"> | string | null
    governance?: StringNullableFilter<"Orientacao"> | string | null
    projeto?: XOR<ProjetoRelationFilter, ProjetoWhereInput>
  }, "id" | "projetoId">

  export type OrientacaoOrderByWithAggregationInput = {
    id?: SortOrder
    projetoId?: SortOrder
    teams?: SortOrderInput | SortOrder
    sharepoint?: SortOrderInput | SortOrder
    emails?: SortOrderInput | SortOrder
    licencas?: SortOrderInput | SortOrder
    seguranca?: SortOrderInput | SortOrder
    governance?: SortOrderInput | SortOrder
    _count?: OrientacaoCountOrderByAggregateInput
    _max?: OrientacaoMaxOrderByAggregateInput
    _min?: OrientacaoMinOrderByAggregateInput
  }

  export type OrientacaoScalarWhereWithAggregatesInput = {
    AND?: OrientacaoScalarWhereWithAggregatesInput | OrientacaoScalarWhereWithAggregatesInput[]
    OR?: OrientacaoScalarWhereWithAggregatesInput[]
    NOT?: OrientacaoScalarWhereWithAggregatesInput | OrientacaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Orientacao"> | string
    projetoId?: StringWithAggregatesFilter<"Orientacao"> | string
    teams?: StringNullableWithAggregatesFilter<"Orientacao"> | string | null
    sharepoint?: StringNullableWithAggregatesFilter<"Orientacao"> | string | null
    emails?: StringNullableWithAggregatesFilter<"Orientacao"> | string | null
    licencas?: StringNullableWithAggregatesFilter<"Orientacao"> | string | null
    seguranca?: StringNullableWithAggregatesFilter<"Orientacao"> | string | null
    governance?: StringNullableWithAggregatesFilter<"Orientacao"> | string | null
  }

  export type ProjetoCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateManyInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
  }

  export type ProjetoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjetoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalystCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    papel?: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    logs?: DecisionLogCreateNestedManyWithoutAnalistaInput
  }

  export type AnalystUncheckedCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    papel?: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    logs?: DecisionLogUncheckedCreateNestedManyWithoutAnalistaInput
  }

  export type AnalystUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: DecisionLogUpdateManyWithoutAnalistaNestedInput
  }

  export type AnalystUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: DecisionLogUncheckedUpdateManyWithoutAnalistaNestedInput
  }

  export type AnalystCreateManyInput = {
    id?: string
    nome: string
    email: string
    senha: string
    papel?: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AnalystUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalystUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    projetos?: ProjetoCreateNestedManyWithoutClienteInput
    deployments?: DeploymentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    projetos?: ProjetoUncheckedCreateNestedManyWithoutClienteInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    projetos?: ProjetoUpdateManyWithoutClienteNestedInput
    deployments?: DeploymentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    projetos?: ProjetoUncheckedUpdateManyWithoutClienteNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogCreateInput = {
    id?: string
    descricao: string
    criadoEm?: Date | string
    analista: AnalystCreateNestedOneWithoutLogsInput
    deployment: DeploymentCreateNestedOneWithoutDecisionsInput
  }

  export type DecisionLogUncheckedCreateInput = {
    id?: string
    analistaId: string
    deploymentId: string
    descricao: string
    criadoEm?: Date | string
  }

  export type DecisionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    analista?: AnalystUpdateOneRequiredWithoutLogsNestedInput
    deployment?: DeploymentUpdateOneRequiredWithoutDecisionsNestedInput
  }

  export type DecisionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    analistaId?: StringFieldUpdateOperationsInput | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogCreateManyInput = {
    id?: string
    analistaId: string
    deploymentId: string
    descricao: string
    criadoEm?: Date | string
  }

  export type DecisionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    analistaId?: StringFieldUpdateOperationsInput | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogProjetoCreateInput = {
    id?: string
    mensagem: string
    criadoEm?: Date | string
    projeto: ProjetoCreateNestedOneWithoutLogsInput
  }

  export type LogProjetoUncheckedCreateInput = {
    id?: string
    projetoId: string
    mensagem: string
    criadoEm?: Date | string
  }

  export type LogProjetoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    projeto?: ProjetoUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogProjetoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogProjetoCreateManyInput = {
    id?: string
    projetoId: string
    mensagem: string
    criadoEm?: Date | string
  }

  export type LogProjetoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogProjetoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentCreateInput = {
    id?: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutDeploymentsInput
    decisions?: DecisionLogCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateInput = {
    id?: string
    clientId: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    decisions?: DecisionLogUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutDeploymentsNestedInput
    decisions?: DecisionLogUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decisions?: DecisionLogUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentCreateManyInput = {
    id?: string
    clientId: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevantamentoCreateInput = {
    id?: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado?: boolean
    observacoes?: string | null
    projeto: ProjetoCreateNestedOneWithoutLevantamentoInput
  }

  export type LevantamentoUncheckedCreateInput = {
    id?: string
    projetoId: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado?: boolean
    observacoes?: string | null
  }

  export type LevantamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: ProjetoUpdateOneRequiredWithoutLevantamentoNestedInput
  }

  export type LevantamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LevantamentoCreateManyInput = {
    id?: string
    projetoId: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado?: boolean
    observacoes?: string | null
  }

  export type LevantamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LevantamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioCreateInput = {
    id?: string
    nome: string
    departamento?: string | null
    cargo?: string | null
    email: string
    caixaMB?: number | null
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: Date | string
    projeto: ProjetoCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    projetoId: string
    nome: string
    departamento?: string | null
    cargo?: string | null
    email: string
    caixaMB?: number | null
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: Date | string
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    projeto?: ProjetoUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateManyInput = {
    id?: string
    projetoId: string
    nome: string
    departamento?: string | null
    cargo?: string | null
    email: string
    caixaMB?: number | null
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailConfigCreateInput = {
    id?: string
    plataformaOrigem: string
    metodologia?: string | null
    janelaMigracao?: string | null
    volumeTotalMB?: number | null
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: string | null
    gruposDistribuicao?: string | null
    observacoes?: string | null
    projeto: ProjetoCreateNestedOneWithoutEmailConfigInput
  }

  export type EmailConfigUncheckedCreateInput = {
    id?: string
    projetoId: string
    plataformaOrigem: string
    metodologia?: string | null
    janelaMigracao?: string | null
    volumeTotalMB?: number | null
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: string | null
    gruposDistribuicao?: string | null
    observacoes?: string | null
  }

  export type EmailConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plataformaOrigem?: StringFieldUpdateOperationsInput | string
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    janelaMigracao?: NullableStringFieldUpdateOperationsInput | string | null
    volumeTotalMB?: NullableIntFieldUpdateOperationsInput | number | null
    migrarCalendarios?: BoolFieldUpdateOperationsInput | boolean
    migrarContatos?: BoolFieldUpdateOperationsInput | boolean
    backupPst?: BoolFieldUpdateOperationsInput | boolean
    caixasCompartilhadas?: NullableStringFieldUpdateOperationsInput | string | null
    gruposDistribuicao?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: ProjetoUpdateOneRequiredWithoutEmailConfigNestedInput
  }

  export type EmailConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    plataformaOrigem?: StringFieldUpdateOperationsInput | string
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    janelaMigracao?: NullableStringFieldUpdateOperationsInput | string | null
    volumeTotalMB?: NullableIntFieldUpdateOperationsInput | number | null
    migrarCalendarios?: BoolFieldUpdateOperationsInput | boolean
    migrarContatos?: BoolFieldUpdateOperationsInput | boolean
    backupPst?: BoolFieldUpdateOperationsInput | boolean
    caixasCompartilhadas?: NullableStringFieldUpdateOperationsInput | string | null
    gruposDistribuicao?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailConfigCreateManyInput = {
    id?: string
    projetoId: string
    plataformaOrigem: string
    metodologia?: string | null
    janelaMigracao?: string | null
    volumeTotalMB?: number | null
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: string | null
    gruposDistribuicao?: string | null
    observacoes?: string | null
  }

  export type EmailConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plataformaOrigem?: StringFieldUpdateOperationsInput | string
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    janelaMigracao?: NullableStringFieldUpdateOperationsInput | string | null
    volumeTotalMB?: NullableIntFieldUpdateOperationsInput | number | null
    migrarCalendarios?: BoolFieldUpdateOperationsInput | boolean
    migrarContatos?: BoolFieldUpdateOperationsInput | boolean
    backupPst?: BoolFieldUpdateOperationsInput | boolean
    caixasCompartilhadas?: NullableStringFieldUpdateOperationsInput | string | null
    gruposDistribuicao?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    plataformaOrigem?: StringFieldUpdateOperationsInput | string
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    janelaMigracao?: NullableStringFieldUpdateOperationsInput | string | null
    volumeTotalMB?: NullableIntFieldUpdateOperationsInput | number | null
    migrarCalendarios?: BoolFieldUpdateOperationsInput | boolean
    migrarContatos?: BoolFieldUpdateOperationsInput | boolean
    backupPst?: BoolFieldUpdateOperationsInput | boolean
    caixasCompartilhadas?: NullableStringFieldUpdateOperationsInput | string | null
    gruposDistribuicao?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharePointSiteCreateInput = {
    id?: string
    nome: string
    tipo: string
    proposito?: string | null
    proprietarios?: string | null
    membros?: string | null
    nivelAcesso?: string | null
    volumeGB?: number | null
    pastaOrigem?: string | null
    projeto: ProjetoCreateNestedOneWithoutSharepointInput
  }

  export type SharePointSiteUncheckedCreateInput = {
    id?: string
    projetoId: string
    nome: string
    tipo: string
    proposito?: string | null
    proprietarios?: string | null
    membros?: string | null
    nivelAcesso?: string | null
    volumeGB?: number | null
    pastaOrigem?: string | null
  }

  export type SharePointSiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: ProjetoUpdateOneRequiredWithoutSharepointNestedInput
  }

  export type SharePointSiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharePointSiteCreateManyInput = {
    id?: string
    projetoId: string
    nome: string
    tipo: string
    proposito?: string | null
    proprietarios?: string | null
    membros?: string | null
    nivelAcesso?: string | null
    volumeGB?: number | null
    pastaOrigem?: string | null
  }

  export type SharePointSiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharePointSiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamsConfigCreateInput = {
    id?: string
    nomeEquipe?: string | null
    tipoEquipe?: string | null
    proposito?: string | null
    proprietarios?: string | null
    membrosIniciais?: string | null
    canais?: string | null
    recursos?: string | null
    observacoes?: string | null
    projeto: ProjetoCreateNestedOneWithoutTeamsInput
  }

  export type TeamsConfigUncheckedCreateInput = {
    id?: string
    projetoId: string
    nomeEquipe?: string | null
    tipoEquipe?: string | null
    proposito?: string | null
    proprietarios?: string | null
    membrosIniciais?: string | null
    canais?: string | null
    recursos?: string | null
    observacoes?: string | null
  }

  export type TeamsConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    tipoEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membrosIniciais?: NullableStringFieldUpdateOperationsInput | string | null
    canais?: NullableStringFieldUpdateOperationsInput | string | null
    recursos?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: ProjetoUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamsConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nomeEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    tipoEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membrosIniciais?: NullableStringFieldUpdateOperationsInput | string | null
    canais?: NullableStringFieldUpdateOperationsInput | string | null
    recursos?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamsConfigCreateManyInput = {
    id?: string
    projetoId: string
    nomeEquipe?: string | null
    tipoEquipe?: string | null
    proposito?: string | null
    proprietarios?: string | null
    membrosIniciais?: string | null
    canais?: string | null
    recursos?: string | null
    observacoes?: string | null
  }

  export type TeamsConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    tipoEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membrosIniciais?: NullableStringFieldUpdateOperationsInput | string | null
    canais?: NullableStringFieldUpdateOperationsInput | string | null
    recursos?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamsConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nomeEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    tipoEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membrosIniciais?: NullableStringFieldUpdateOperationsInput | string | null
    canais?: NullableStringFieldUpdateOperationsInput | string | null
    recursos?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronogramaItemCreateInput = {
    id?: string
    nome: string
    responsavel?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    status?: string
    ordem?: number | null
    projeto: ProjetoCreateNestedOneWithoutCronogramaInput
  }

  export type CronogramaItemUncheckedCreateInput = {
    id?: string
    projetoId: string
    nome: string
    responsavel?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    status?: string
    ordem?: number | null
  }

  export type CronogramaItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
    projeto?: ProjetoUpdateOneRequiredWithoutCronogramaNestedInput
  }

  export type CronogramaItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CronogramaItemCreateManyInput = {
    id?: string
    projetoId: string
    nome: string
    responsavel?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    status?: string
    ordem?: number | null
  }

  export type CronogramaItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CronogramaItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LicenciamentoCreateInput = {
    id?: string
    m365basic?: number | null
    m365standard?: number | null
    appsforbusiness?: number | null
    f3?: number | null
    e3?: number | null
    e5?: number | null
    observacoes?: string | null
    projeto: ProjetoCreateNestedOneWithoutLicenciamentoInput
  }

  export type LicenciamentoUncheckedCreateInput = {
    id?: string
    projetoId: string
    m365basic?: number | null
    m365standard?: number | null
    appsforbusiness?: number | null
    f3?: number | null
    e3?: number | null
    e5?: number | null
    observacoes?: string | null
  }

  export type LicenciamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    m365basic?: NullableIntFieldUpdateOperationsInput | number | null
    m365standard?: NullableIntFieldUpdateOperationsInput | number | null
    appsforbusiness?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    e3?: NullableIntFieldUpdateOperationsInput | number | null
    e5?: NullableIntFieldUpdateOperationsInput | number | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: ProjetoUpdateOneRequiredWithoutLicenciamentoNestedInput
  }

  export type LicenciamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    m365basic?: NullableIntFieldUpdateOperationsInput | number | null
    m365standard?: NullableIntFieldUpdateOperationsInput | number | null
    appsforbusiness?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    e3?: NullableIntFieldUpdateOperationsInput | number | null
    e5?: NullableIntFieldUpdateOperationsInput | number | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenciamentoCreateManyInput = {
    id?: string
    projetoId: string
    m365basic?: number | null
    m365standard?: number | null
    appsforbusiness?: number | null
    f3?: number | null
    e3?: number | null
    e5?: number | null
    observacoes?: string | null
  }

  export type LicenciamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    m365basic?: NullableIntFieldUpdateOperationsInput | number | null
    m365standard?: NullableIntFieldUpdateOperationsInput | number | null
    appsforbusiness?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    e3?: NullableIntFieldUpdateOperationsInput | number | null
    e5?: NullableIntFieldUpdateOperationsInput | number | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenciamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    m365basic?: NullableIntFieldUpdateOperationsInput | number | null
    m365standard?: NullableIntFieldUpdateOperationsInput | number | null
    appsforbusiness?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    e3?: NullableIntFieldUpdateOperationsInput | number | null
    e5?: NullableIntFieldUpdateOperationsInput | number | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrientacaoCreateInput = {
    id?: string
    teams?: string | null
    sharepoint?: string | null
    emails?: string | null
    licencas?: string | null
    seguranca?: string | null
    governance?: string | null
    projeto: ProjetoCreateNestedOneWithoutOrientacoesInput
  }

  export type OrientacaoUncheckedCreateInput = {
    id?: string
    projetoId: string
    teams?: string | null
    sharepoint?: string | null
    emails?: string | null
    licencas?: string | null
    seguranca?: string | null
    governance?: string | null
  }

  export type OrientacaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teams?: NullableStringFieldUpdateOperationsInput | string | null
    sharepoint?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    licencas?: NullableStringFieldUpdateOperationsInput | string | null
    seguranca?: NullableStringFieldUpdateOperationsInput | string | null
    governance?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: ProjetoUpdateOneRequiredWithoutOrientacoesNestedInput
  }

  export type OrientacaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    teams?: NullableStringFieldUpdateOperationsInput | string | null
    sharepoint?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    licencas?: NullableStringFieldUpdateOperationsInput | string | null
    seguranca?: NullableStringFieldUpdateOperationsInput | string | null
    governance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrientacaoCreateManyInput = {
    id?: string
    projetoId: string
    teams?: string | null
    sharepoint?: string | null
    emails?: string | null
    licencas?: string | null
    seguranca?: string | null
    governance?: string | null
  }

  export type OrientacaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teams?: NullableStringFieldUpdateOperationsInput | string | null
    sharepoint?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    licencas?: NullableStringFieldUpdateOperationsInput | string | null
    seguranca?: NullableStringFieldUpdateOperationsInput | string | null
    governance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrientacaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projetoId?: StringFieldUpdateOperationsInput | string
    teams?: NullableStringFieldUpdateOperationsInput | string | null
    sharepoint?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    licencas?: NullableStringFieldUpdateOperationsInput | string | null
    seguranca?: NullableStringFieldUpdateOperationsInput | string | null
    governance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type LevantamentoListRelationFilter = {
    every?: LevantamentoWhereInput
    some?: LevantamentoWhereInput
    none?: LevantamentoWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type EmailConfigNullableRelationFilter = {
    is?: EmailConfigWhereInput | null
    isNot?: EmailConfigWhereInput | null
  }

  export type SharePointSiteListRelationFilter = {
    every?: SharePointSiteWhereInput
    some?: SharePointSiteWhereInput
    none?: SharePointSiteWhereInput
  }

  export type TeamsConfigNullableRelationFilter = {
    is?: TeamsConfigWhereInput | null
    isNot?: TeamsConfigWhereInput | null
  }

  export type CronogramaItemListRelationFilter = {
    every?: CronogramaItemWhereInput
    some?: CronogramaItemWhereInput
    none?: CronogramaItemWhereInput
  }

  export type LicenciamentoNullableRelationFilter = {
    is?: LicenciamentoWhereInput | null
    isNot?: LicenciamentoWhereInput | null
  }

  export type OrientacaoNullableRelationFilter = {
    is?: OrientacaoWhereInput | null
    isNot?: OrientacaoWhereInput | null
  }

  export type LogProjetoListRelationFilter = {
    every?: LogProjetoWhereInput
    some?: LogProjetoWhereInput
    none?: LogProjetoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LevantamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharePointSiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CronogramaItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogProjetoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjetoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    clienteId?: SortOrder
    descricao?: SortOrder
    status?: SortOrder
    progresso?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
  }

  export type ProjetoAvgOrderByAggregateInput = {
    progresso?: SortOrder
  }

  export type ProjetoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    clienteId?: SortOrder
    descricao?: SortOrder
    status?: SortOrder
    progresso?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
  }

  export type ProjetoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    clienteId?: SortOrder
    descricao?: SortOrder
    status?: SortOrder
    progresso?: SortOrder
    dataCriacao?: SortOrder
    dataAtualizacao?: SortOrder
  }

  export type ProjetoSumOrderByAggregateInput = {
    progresso?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecisionLogListRelationFilter = {
    every?: DecisionLogWhereInput
    some?: DecisionLogWhereInput
    none?: DecisionLogWhereInput
  }

  export type DecisionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalystCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    papel?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AnalystMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    papel?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AnalystMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    papel?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ProjetoListRelationFilter = {
    every?: ProjetoWhereInput
    some?: ProjetoWhereInput
    none?: ProjetoWhereInput
  }

  export type DeploymentListRelationFilter = {
    every?: DeploymentWhereInput
    some?: DeploymentWhereInput
    none?: DeploymentWhereInput
  }

  export type ProjetoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dominio?: SortOrder
    segmento?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dominio?: SortOrder
    segmento?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dominio?: SortOrder
    segmento?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AnalystRelationFilter = {
    is?: AnalystWhereInput
    isNot?: AnalystWhereInput
  }

  export type DeploymentRelationFilter = {
    is?: DeploymentWhereInput
    isNot?: DeploymentWhereInput
  }

  export type DecisionLogCountOrderByAggregateInput = {
    id?: SortOrder
    analistaId?: SortOrder
    deploymentId?: SortOrder
    descricao?: SortOrder
    criadoEm?: SortOrder
  }

  export type DecisionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    analistaId?: SortOrder
    deploymentId?: SortOrder
    descricao?: SortOrder
    criadoEm?: SortOrder
  }

  export type DecisionLogMinOrderByAggregateInput = {
    id?: SortOrder
    analistaId?: SortOrder
    deploymentId?: SortOrder
    descricao?: SortOrder
    criadoEm?: SortOrder
  }

  export type ProjetoRelationFilter = {
    is?: ProjetoWhereInput
    isNot?: ProjetoWhereInput
  }

  export type LogProjetoCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    mensagem?: SortOrder
    criadoEm?: SortOrder
  }

  export type LogProjetoMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    mensagem?: SortOrder
    criadoEm?: SortOrder
  }

  export type LogProjetoMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    mensagem?: SortOrder
    criadoEm?: SortOrder
  }

  export type DeploymentCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    modelSelected?: SortOrder
    licensing?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeploymentMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    modelSelected?: SortOrder
    licensing?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeploymentMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    modelSelected?: SortOrder
    licensing?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LevantamentoCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    criticidade?: SortOrder
    tempoEstimado?: SortOrder
    selecionado?: SortOrder
    observacoes?: SortOrder
  }

  export type LevantamentoAvgOrderByAggregateInput = {
    tempoEstimado?: SortOrder
  }

  export type LevantamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    criticidade?: SortOrder
    tempoEstimado?: SortOrder
    selecionado?: SortOrder
    observacoes?: SortOrder
  }

  export type LevantamentoMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    criticidade?: SortOrder
    tempoEstimado?: SortOrder
    selecionado?: SortOrder
    observacoes?: SortOrder
  }

  export type LevantamentoSumOrderByAggregateInput = {
    tempoEstimado?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    departamento?: SortOrder
    cargo?: SortOrder
    email?: SortOrder
    caixaMB?: SortOrder
    officeLocal?: SortOrder
    migrarEmail?: SortOrder
    oneDrive?: SortOrder
    sharePoint?: SortOrder
    teams?: SortOrder
    criadoEm?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    caixaMB?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    departamento?: SortOrder
    cargo?: SortOrder
    email?: SortOrder
    caixaMB?: SortOrder
    officeLocal?: SortOrder
    migrarEmail?: SortOrder
    oneDrive?: SortOrder
    sharePoint?: SortOrder
    teams?: SortOrder
    criadoEm?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    departamento?: SortOrder
    cargo?: SortOrder
    email?: SortOrder
    caixaMB?: SortOrder
    officeLocal?: SortOrder
    migrarEmail?: SortOrder
    oneDrive?: SortOrder
    sharePoint?: SortOrder
    teams?: SortOrder
    criadoEm?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    caixaMB?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EmailConfigCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    plataformaOrigem?: SortOrder
    metodologia?: SortOrder
    janelaMigracao?: SortOrder
    volumeTotalMB?: SortOrder
    migrarCalendarios?: SortOrder
    migrarContatos?: SortOrder
    backupPst?: SortOrder
    caixasCompartilhadas?: SortOrder
    gruposDistribuicao?: SortOrder
    observacoes?: SortOrder
  }

  export type EmailConfigAvgOrderByAggregateInput = {
    volumeTotalMB?: SortOrder
  }

  export type EmailConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    plataformaOrigem?: SortOrder
    metodologia?: SortOrder
    janelaMigracao?: SortOrder
    volumeTotalMB?: SortOrder
    migrarCalendarios?: SortOrder
    migrarContatos?: SortOrder
    backupPst?: SortOrder
    caixasCompartilhadas?: SortOrder
    gruposDistribuicao?: SortOrder
    observacoes?: SortOrder
  }

  export type EmailConfigMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    plataformaOrigem?: SortOrder
    metodologia?: SortOrder
    janelaMigracao?: SortOrder
    volumeTotalMB?: SortOrder
    migrarCalendarios?: SortOrder
    migrarContatos?: SortOrder
    backupPst?: SortOrder
    caixasCompartilhadas?: SortOrder
    gruposDistribuicao?: SortOrder
    observacoes?: SortOrder
  }

  export type EmailConfigSumOrderByAggregateInput = {
    volumeTotalMB?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SharePointSiteCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    proposito?: SortOrder
    proprietarios?: SortOrder
    membros?: SortOrder
    nivelAcesso?: SortOrder
    volumeGB?: SortOrder
    pastaOrigem?: SortOrder
  }

  export type SharePointSiteAvgOrderByAggregateInput = {
    volumeGB?: SortOrder
  }

  export type SharePointSiteMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    proposito?: SortOrder
    proprietarios?: SortOrder
    membros?: SortOrder
    nivelAcesso?: SortOrder
    volumeGB?: SortOrder
    pastaOrigem?: SortOrder
  }

  export type SharePointSiteMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    proposito?: SortOrder
    proprietarios?: SortOrder
    membros?: SortOrder
    nivelAcesso?: SortOrder
    volumeGB?: SortOrder
    pastaOrigem?: SortOrder
  }

  export type SharePointSiteSumOrderByAggregateInput = {
    volumeGB?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TeamsConfigCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nomeEquipe?: SortOrder
    tipoEquipe?: SortOrder
    proposito?: SortOrder
    proprietarios?: SortOrder
    membrosIniciais?: SortOrder
    canais?: SortOrder
    recursos?: SortOrder
    observacoes?: SortOrder
  }

  export type TeamsConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nomeEquipe?: SortOrder
    tipoEquipe?: SortOrder
    proposito?: SortOrder
    proprietarios?: SortOrder
    membrosIniciais?: SortOrder
    canais?: SortOrder
    recursos?: SortOrder
    observacoes?: SortOrder
  }

  export type TeamsConfigMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nomeEquipe?: SortOrder
    tipoEquipe?: SortOrder
    proposito?: SortOrder
    proprietarios?: SortOrder
    membrosIniciais?: SortOrder
    canais?: SortOrder
    recursos?: SortOrder
    observacoes?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CronogramaItemCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    status?: SortOrder
    ordem?: SortOrder
  }

  export type CronogramaItemAvgOrderByAggregateInput = {
    ordem?: SortOrder
  }

  export type CronogramaItemMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    status?: SortOrder
    ordem?: SortOrder
  }

  export type CronogramaItemMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    nome?: SortOrder
    responsavel?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    status?: SortOrder
    ordem?: SortOrder
  }

  export type CronogramaItemSumOrderByAggregateInput = {
    ordem?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type LicenciamentoCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    m365basic?: SortOrder
    m365standard?: SortOrder
    appsforbusiness?: SortOrder
    f3?: SortOrder
    e3?: SortOrder
    e5?: SortOrder
    observacoes?: SortOrder
  }

  export type LicenciamentoAvgOrderByAggregateInput = {
    m365basic?: SortOrder
    m365standard?: SortOrder
    appsforbusiness?: SortOrder
    f3?: SortOrder
    e3?: SortOrder
    e5?: SortOrder
  }

  export type LicenciamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    m365basic?: SortOrder
    m365standard?: SortOrder
    appsforbusiness?: SortOrder
    f3?: SortOrder
    e3?: SortOrder
    e5?: SortOrder
    observacoes?: SortOrder
  }

  export type LicenciamentoMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    m365basic?: SortOrder
    m365standard?: SortOrder
    appsforbusiness?: SortOrder
    f3?: SortOrder
    e3?: SortOrder
    e5?: SortOrder
    observacoes?: SortOrder
  }

  export type LicenciamentoSumOrderByAggregateInput = {
    m365basic?: SortOrder
    m365standard?: SortOrder
    appsforbusiness?: SortOrder
    f3?: SortOrder
    e3?: SortOrder
    e5?: SortOrder
  }

  export type OrientacaoCountOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    teams?: SortOrder
    sharepoint?: SortOrder
    emails?: SortOrder
    licencas?: SortOrder
    seguranca?: SortOrder
    governance?: SortOrder
  }

  export type OrientacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    teams?: SortOrder
    sharepoint?: SortOrder
    emails?: SortOrder
    licencas?: SortOrder
    seguranca?: SortOrder
    governance?: SortOrder
  }

  export type OrientacaoMinOrderByAggregateInput = {
    id?: SortOrder
    projetoId?: SortOrder
    teams?: SortOrder
    sharepoint?: SortOrder
    emails?: SortOrder
    licencas?: SortOrder
    seguranca?: SortOrder
    governance?: SortOrder
  }

  export type ClientCreateNestedOneWithoutProjetosInput = {
    create?: XOR<ClientCreateWithoutProjetosInput, ClientUncheckedCreateWithoutProjetosInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjetosInput
    connect?: ClientWhereUniqueInput
  }

  export type LevantamentoCreateNestedManyWithoutProjetoInput = {
    create?: XOR<LevantamentoCreateWithoutProjetoInput, LevantamentoUncheckedCreateWithoutProjetoInput> | LevantamentoCreateWithoutProjetoInput[] | LevantamentoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LevantamentoCreateOrConnectWithoutProjetoInput | LevantamentoCreateOrConnectWithoutProjetoInput[]
    createMany?: LevantamentoCreateManyProjetoInputEnvelope
    connect?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
  }

  export type UsuarioCreateNestedManyWithoutProjetoInput = {
    create?: XOR<UsuarioCreateWithoutProjetoInput, UsuarioUncheckedCreateWithoutProjetoInput> | UsuarioCreateWithoutProjetoInput[] | UsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutProjetoInput | UsuarioCreateOrConnectWithoutProjetoInput[]
    createMany?: UsuarioCreateManyProjetoInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EmailConfigCreateNestedOneWithoutProjetoInput = {
    create?: XOR<EmailConfigCreateWithoutProjetoInput, EmailConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: EmailConfigCreateOrConnectWithoutProjetoInput
    connect?: EmailConfigWhereUniqueInput
  }

  export type SharePointSiteCreateNestedManyWithoutProjetoInput = {
    create?: XOR<SharePointSiteCreateWithoutProjetoInput, SharePointSiteUncheckedCreateWithoutProjetoInput> | SharePointSiteCreateWithoutProjetoInput[] | SharePointSiteUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: SharePointSiteCreateOrConnectWithoutProjetoInput | SharePointSiteCreateOrConnectWithoutProjetoInput[]
    createMany?: SharePointSiteCreateManyProjetoInputEnvelope
    connect?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
  }

  export type TeamsConfigCreateNestedOneWithoutProjetoInput = {
    create?: XOR<TeamsConfigCreateWithoutProjetoInput, TeamsConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: TeamsConfigCreateOrConnectWithoutProjetoInput
    connect?: TeamsConfigWhereUniqueInput
  }

  export type CronogramaItemCreateNestedManyWithoutProjetoInput = {
    create?: XOR<CronogramaItemCreateWithoutProjetoInput, CronogramaItemUncheckedCreateWithoutProjetoInput> | CronogramaItemCreateWithoutProjetoInput[] | CronogramaItemUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: CronogramaItemCreateOrConnectWithoutProjetoInput | CronogramaItemCreateOrConnectWithoutProjetoInput[]
    createMany?: CronogramaItemCreateManyProjetoInputEnvelope
    connect?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
  }

  export type LicenciamentoCreateNestedOneWithoutProjetoInput = {
    create?: XOR<LicenciamentoCreateWithoutProjetoInput, LicenciamentoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: LicenciamentoCreateOrConnectWithoutProjetoInput
    connect?: LicenciamentoWhereUniqueInput
  }

  export type OrientacaoCreateNestedOneWithoutProjetoInput = {
    create?: XOR<OrientacaoCreateWithoutProjetoInput, OrientacaoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: OrientacaoCreateOrConnectWithoutProjetoInput
    connect?: OrientacaoWhereUniqueInput
  }

  export type LogProjetoCreateNestedManyWithoutProjetoInput = {
    create?: XOR<LogProjetoCreateWithoutProjetoInput, LogProjetoUncheckedCreateWithoutProjetoInput> | LogProjetoCreateWithoutProjetoInput[] | LogProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LogProjetoCreateOrConnectWithoutProjetoInput | LogProjetoCreateOrConnectWithoutProjetoInput[]
    createMany?: LogProjetoCreateManyProjetoInputEnvelope
    connect?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
  }

  export type LevantamentoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<LevantamentoCreateWithoutProjetoInput, LevantamentoUncheckedCreateWithoutProjetoInput> | LevantamentoCreateWithoutProjetoInput[] | LevantamentoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LevantamentoCreateOrConnectWithoutProjetoInput | LevantamentoCreateOrConnectWithoutProjetoInput[]
    createMany?: LevantamentoCreateManyProjetoInputEnvelope
    connect?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<UsuarioCreateWithoutProjetoInput, UsuarioUncheckedCreateWithoutProjetoInput> | UsuarioCreateWithoutProjetoInput[] | UsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutProjetoInput | UsuarioCreateOrConnectWithoutProjetoInput[]
    createMany?: UsuarioCreateManyProjetoInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EmailConfigUncheckedCreateNestedOneWithoutProjetoInput = {
    create?: XOR<EmailConfigCreateWithoutProjetoInput, EmailConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: EmailConfigCreateOrConnectWithoutProjetoInput
    connect?: EmailConfigWhereUniqueInput
  }

  export type SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<SharePointSiteCreateWithoutProjetoInput, SharePointSiteUncheckedCreateWithoutProjetoInput> | SharePointSiteCreateWithoutProjetoInput[] | SharePointSiteUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: SharePointSiteCreateOrConnectWithoutProjetoInput | SharePointSiteCreateOrConnectWithoutProjetoInput[]
    createMany?: SharePointSiteCreateManyProjetoInputEnvelope
    connect?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
  }

  export type TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput = {
    create?: XOR<TeamsConfigCreateWithoutProjetoInput, TeamsConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: TeamsConfigCreateOrConnectWithoutProjetoInput
    connect?: TeamsConfigWhereUniqueInput
  }

  export type CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<CronogramaItemCreateWithoutProjetoInput, CronogramaItemUncheckedCreateWithoutProjetoInput> | CronogramaItemCreateWithoutProjetoInput[] | CronogramaItemUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: CronogramaItemCreateOrConnectWithoutProjetoInput | CronogramaItemCreateOrConnectWithoutProjetoInput[]
    createMany?: CronogramaItemCreateManyProjetoInputEnvelope
    connect?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
  }

  export type LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput = {
    create?: XOR<LicenciamentoCreateWithoutProjetoInput, LicenciamentoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: LicenciamentoCreateOrConnectWithoutProjetoInput
    connect?: LicenciamentoWhereUniqueInput
  }

  export type OrientacaoUncheckedCreateNestedOneWithoutProjetoInput = {
    create?: XOR<OrientacaoCreateWithoutProjetoInput, OrientacaoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: OrientacaoCreateOrConnectWithoutProjetoInput
    connect?: OrientacaoWhereUniqueInput
  }

  export type LogProjetoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<LogProjetoCreateWithoutProjetoInput, LogProjetoUncheckedCreateWithoutProjetoInput> | LogProjetoCreateWithoutProjetoInput[] | LogProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LogProjetoCreateOrConnectWithoutProjetoInput | LogProjetoCreateOrConnectWithoutProjetoInput[]
    createMany?: LogProjetoCreateManyProjetoInputEnvelope
    connect?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientUpdateOneRequiredWithoutProjetosNestedInput = {
    create?: XOR<ClientCreateWithoutProjetosInput, ClientUncheckedCreateWithoutProjetosInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProjetosInput
    upsert?: ClientUpsertWithoutProjetosInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProjetosInput, ClientUpdateWithoutProjetosInput>, ClientUncheckedUpdateWithoutProjetosInput>
  }

  export type LevantamentoUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<LevantamentoCreateWithoutProjetoInput, LevantamentoUncheckedCreateWithoutProjetoInput> | LevantamentoCreateWithoutProjetoInput[] | LevantamentoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LevantamentoCreateOrConnectWithoutProjetoInput | LevantamentoCreateOrConnectWithoutProjetoInput[]
    upsert?: LevantamentoUpsertWithWhereUniqueWithoutProjetoInput | LevantamentoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: LevantamentoCreateManyProjetoInputEnvelope
    set?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    disconnect?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    delete?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    connect?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    update?: LevantamentoUpdateWithWhereUniqueWithoutProjetoInput | LevantamentoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: LevantamentoUpdateManyWithWhereWithoutProjetoInput | LevantamentoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: LevantamentoScalarWhereInput | LevantamentoScalarWhereInput[]
  }

  export type UsuarioUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<UsuarioCreateWithoutProjetoInput, UsuarioUncheckedCreateWithoutProjetoInput> | UsuarioCreateWithoutProjetoInput[] | UsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutProjetoInput | UsuarioCreateOrConnectWithoutProjetoInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutProjetoInput | UsuarioUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: UsuarioCreateManyProjetoInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutProjetoInput | UsuarioUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutProjetoInput | UsuarioUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmailConfigUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<EmailConfigCreateWithoutProjetoInput, EmailConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: EmailConfigCreateOrConnectWithoutProjetoInput
    upsert?: EmailConfigUpsertWithoutProjetoInput
    disconnect?: EmailConfigWhereInput | boolean
    delete?: EmailConfigWhereInput | boolean
    connect?: EmailConfigWhereUniqueInput
    update?: XOR<XOR<EmailConfigUpdateToOneWithWhereWithoutProjetoInput, EmailConfigUpdateWithoutProjetoInput>, EmailConfigUncheckedUpdateWithoutProjetoInput>
  }

  export type SharePointSiteUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<SharePointSiteCreateWithoutProjetoInput, SharePointSiteUncheckedCreateWithoutProjetoInput> | SharePointSiteCreateWithoutProjetoInput[] | SharePointSiteUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: SharePointSiteCreateOrConnectWithoutProjetoInput | SharePointSiteCreateOrConnectWithoutProjetoInput[]
    upsert?: SharePointSiteUpsertWithWhereUniqueWithoutProjetoInput | SharePointSiteUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: SharePointSiteCreateManyProjetoInputEnvelope
    set?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    disconnect?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    delete?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    connect?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    update?: SharePointSiteUpdateWithWhereUniqueWithoutProjetoInput | SharePointSiteUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: SharePointSiteUpdateManyWithWhereWithoutProjetoInput | SharePointSiteUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: SharePointSiteScalarWhereInput | SharePointSiteScalarWhereInput[]
  }

  export type TeamsConfigUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<TeamsConfigCreateWithoutProjetoInput, TeamsConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: TeamsConfigCreateOrConnectWithoutProjetoInput
    upsert?: TeamsConfigUpsertWithoutProjetoInput
    disconnect?: TeamsConfigWhereInput | boolean
    delete?: TeamsConfigWhereInput | boolean
    connect?: TeamsConfigWhereUniqueInput
    update?: XOR<XOR<TeamsConfigUpdateToOneWithWhereWithoutProjetoInput, TeamsConfigUpdateWithoutProjetoInput>, TeamsConfigUncheckedUpdateWithoutProjetoInput>
  }

  export type CronogramaItemUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<CronogramaItemCreateWithoutProjetoInput, CronogramaItemUncheckedCreateWithoutProjetoInput> | CronogramaItemCreateWithoutProjetoInput[] | CronogramaItemUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: CronogramaItemCreateOrConnectWithoutProjetoInput | CronogramaItemCreateOrConnectWithoutProjetoInput[]
    upsert?: CronogramaItemUpsertWithWhereUniqueWithoutProjetoInput | CronogramaItemUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: CronogramaItemCreateManyProjetoInputEnvelope
    set?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    disconnect?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    delete?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    connect?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    update?: CronogramaItemUpdateWithWhereUniqueWithoutProjetoInput | CronogramaItemUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: CronogramaItemUpdateManyWithWhereWithoutProjetoInput | CronogramaItemUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: CronogramaItemScalarWhereInput | CronogramaItemScalarWhereInput[]
  }

  export type LicenciamentoUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<LicenciamentoCreateWithoutProjetoInput, LicenciamentoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: LicenciamentoCreateOrConnectWithoutProjetoInput
    upsert?: LicenciamentoUpsertWithoutProjetoInput
    disconnect?: LicenciamentoWhereInput | boolean
    delete?: LicenciamentoWhereInput | boolean
    connect?: LicenciamentoWhereUniqueInput
    update?: XOR<XOR<LicenciamentoUpdateToOneWithWhereWithoutProjetoInput, LicenciamentoUpdateWithoutProjetoInput>, LicenciamentoUncheckedUpdateWithoutProjetoInput>
  }

  export type OrientacaoUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<OrientacaoCreateWithoutProjetoInput, OrientacaoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: OrientacaoCreateOrConnectWithoutProjetoInput
    upsert?: OrientacaoUpsertWithoutProjetoInput
    disconnect?: OrientacaoWhereInput | boolean
    delete?: OrientacaoWhereInput | boolean
    connect?: OrientacaoWhereUniqueInput
    update?: XOR<XOR<OrientacaoUpdateToOneWithWhereWithoutProjetoInput, OrientacaoUpdateWithoutProjetoInput>, OrientacaoUncheckedUpdateWithoutProjetoInput>
  }

  export type LogProjetoUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<LogProjetoCreateWithoutProjetoInput, LogProjetoUncheckedCreateWithoutProjetoInput> | LogProjetoCreateWithoutProjetoInput[] | LogProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LogProjetoCreateOrConnectWithoutProjetoInput | LogProjetoCreateOrConnectWithoutProjetoInput[]
    upsert?: LogProjetoUpsertWithWhereUniqueWithoutProjetoInput | LogProjetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: LogProjetoCreateManyProjetoInputEnvelope
    set?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    disconnect?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    delete?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    connect?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    update?: LogProjetoUpdateWithWhereUniqueWithoutProjetoInput | LogProjetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: LogProjetoUpdateManyWithWhereWithoutProjetoInput | LogProjetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: LogProjetoScalarWhereInput | LogProjetoScalarWhereInput[]
  }

  export type LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<LevantamentoCreateWithoutProjetoInput, LevantamentoUncheckedCreateWithoutProjetoInput> | LevantamentoCreateWithoutProjetoInput[] | LevantamentoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LevantamentoCreateOrConnectWithoutProjetoInput | LevantamentoCreateOrConnectWithoutProjetoInput[]
    upsert?: LevantamentoUpsertWithWhereUniqueWithoutProjetoInput | LevantamentoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: LevantamentoCreateManyProjetoInputEnvelope
    set?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    disconnect?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    delete?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    connect?: LevantamentoWhereUniqueInput | LevantamentoWhereUniqueInput[]
    update?: LevantamentoUpdateWithWhereUniqueWithoutProjetoInput | LevantamentoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: LevantamentoUpdateManyWithWhereWithoutProjetoInput | LevantamentoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: LevantamentoScalarWhereInput | LevantamentoScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<UsuarioCreateWithoutProjetoInput, UsuarioUncheckedCreateWithoutProjetoInput> | UsuarioCreateWithoutProjetoInput[] | UsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutProjetoInput | UsuarioCreateOrConnectWithoutProjetoInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutProjetoInput | UsuarioUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: UsuarioCreateManyProjetoInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutProjetoInput | UsuarioUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutProjetoInput | UsuarioUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<EmailConfigCreateWithoutProjetoInput, EmailConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: EmailConfigCreateOrConnectWithoutProjetoInput
    upsert?: EmailConfigUpsertWithoutProjetoInput
    disconnect?: EmailConfigWhereInput | boolean
    delete?: EmailConfigWhereInput | boolean
    connect?: EmailConfigWhereUniqueInput
    update?: XOR<XOR<EmailConfigUpdateToOneWithWhereWithoutProjetoInput, EmailConfigUpdateWithoutProjetoInput>, EmailConfigUncheckedUpdateWithoutProjetoInput>
  }

  export type SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<SharePointSiteCreateWithoutProjetoInput, SharePointSiteUncheckedCreateWithoutProjetoInput> | SharePointSiteCreateWithoutProjetoInput[] | SharePointSiteUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: SharePointSiteCreateOrConnectWithoutProjetoInput | SharePointSiteCreateOrConnectWithoutProjetoInput[]
    upsert?: SharePointSiteUpsertWithWhereUniqueWithoutProjetoInput | SharePointSiteUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: SharePointSiteCreateManyProjetoInputEnvelope
    set?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    disconnect?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    delete?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    connect?: SharePointSiteWhereUniqueInput | SharePointSiteWhereUniqueInput[]
    update?: SharePointSiteUpdateWithWhereUniqueWithoutProjetoInput | SharePointSiteUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: SharePointSiteUpdateManyWithWhereWithoutProjetoInput | SharePointSiteUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: SharePointSiteScalarWhereInput | SharePointSiteScalarWhereInput[]
  }

  export type TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<TeamsConfigCreateWithoutProjetoInput, TeamsConfigUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: TeamsConfigCreateOrConnectWithoutProjetoInput
    upsert?: TeamsConfigUpsertWithoutProjetoInput
    disconnect?: TeamsConfigWhereInput | boolean
    delete?: TeamsConfigWhereInput | boolean
    connect?: TeamsConfigWhereUniqueInput
    update?: XOR<XOR<TeamsConfigUpdateToOneWithWhereWithoutProjetoInput, TeamsConfigUpdateWithoutProjetoInput>, TeamsConfigUncheckedUpdateWithoutProjetoInput>
  }

  export type CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<CronogramaItemCreateWithoutProjetoInput, CronogramaItemUncheckedCreateWithoutProjetoInput> | CronogramaItemCreateWithoutProjetoInput[] | CronogramaItemUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: CronogramaItemCreateOrConnectWithoutProjetoInput | CronogramaItemCreateOrConnectWithoutProjetoInput[]
    upsert?: CronogramaItemUpsertWithWhereUniqueWithoutProjetoInput | CronogramaItemUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: CronogramaItemCreateManyProjetoInputEnvelope
    set?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    disconnect?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    delete?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    connect?: CronogramaItemWhereUniqueInput | CronogramaItemWhereUniqueInput[]
    update?: CronogramaItemUpdateWithWhereUniqueWithoutProjetoInput | CronogramaItemUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: CronogramaItemUpdateManyWithWhereWithoutProjetoInput | CronogramaItemUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: CronogramaItemScalarWhereInput | CronogramaItemScalarWhereInput[]
  }

  export type LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<LicenciamentoCreateWithoutProjetoInput, LicenciamentoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: LicenciamentoCreateOrConnectWithoutProjetoInput
    upsert?: LicenciamentoUpsertWithoutProjetoInput
    disconnect?: LicenciamentoWhereInput | boolean
    delete?: LicenciamentoWhereInput | boolean
    connect?: LicenciamentoWhereUniqueInput
    update?: XOR<XOR<LicenciamentoUpdateToOneWithWhereWithoutProjetoInput, LicenciamentoUpdateWithoutProjetoInput>, LicenciamentoUncheckedUpdateWithoutProjetoInput>
  }

  export type OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput = {
    create?: XOR<OrientacaoCreateWithoutProjetoInput, OrientacaoUncheckedCreateWithoutProjetoInput>
    connectOrCreate?: OrientacaoCreateOrConnectWithoutProjetoInput
    upsert?: OrientacaoUpsertWithoutProjetoInput
    disconnect?: OrientacaoWhereInput | boolean
    delete?: OrientacaoWhereInput | boolean
    connect?: OrientacaoWhereUniqueInput
    update?: XOR<XOR<OrientacaoUpdateToOneWithWhereWithoutProjetoInput, OrientacaoUpdateWithoutProjetoInput>, OrientacaoUncheckedUpdateWithoutProjetoInput>
  }

  export type LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<LogProjetoCreateWithoutProjetoInput, LogProjetoUncheckedCreateWithoutProjetoInput> | LogProjetoCreateWithoutProjetoInput[] | LogProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: LogProjetoCreateOrConnectWithoutProjetoInput | LogProjetoCreateOrConnectWithoutProjetoInput[]
    upsert?: LogProjetoUpsertWithWhereUniqueWithoutProjetoInput | LogProjetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: LogProjetoCreateManyProjetoInputEnvelope
    set?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    disconnect?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    delete?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    connect?: LogProjetoWhereUniqueInput | LogProjetoWhereUniqueInput[]
    update?: LogProjetoUpdateWithWhereUniqueWithoutProjetoInput | LogProjetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: LogProjetoUpdateManyWithWhereWithoutProjetoInput | LogProjetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: LogProjetoScalarWhereInput | LogProjetoScalarWhereInput[]
  }

  export type DecisionLogCreateNestedManyWithoutAnalistaInput = {
    create?: XOR<DecisionLogCreateWithoutAnalistaInput, DecisionLogUncheckedCreateWithoutAnalistaInput> | DecisionLogCreateWithoutAnalistaInput[] | DecisionLogUncheckedCreateWithoutAnalistaInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAnalistaInput | DecisionLogCreateOrConnectWithoutAnalistaInput[]
    createMany?: DecisionLogCreateManyAnalistaInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type DecisionLogUncheckedCreateNestedManyWithoutAnalistaInput = {
    create?: XOR<DecisionLogCreateWithoutAnalistaInput, DecisionLogUncheckedCreateWithoutAnalistaInput> | DecisionLogCreateWithoutAnalistaInput[] | DecisionLogUncheckedCreateWithoutAnalistaInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAnalistaInput | DecisionLogCreateOrConnectWithoutAnalistaInput[]
    createMany?: DecisionLogCreateManyAnalistaInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type DecisionLogUpdateManyWithoutAnalistaNestedInput = {
    create?: XOR<DecisionLogCreateWithoutAnalistaInput, DecisionLogUncheckedCreateWithoutAnalistaInput> | DecisionLogCreateWithoutAnalistaInput[] | DecisionLogUncheckedCreateWithoutAnalistaInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAnalistaInput | DecisionLogCreateOrConnectWithoutAnalistaInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutAnalistaInput | DecisionLogUpsertWithWhereUniqueWithoutAnalistaInput[]
    createMany?: DecisionLogCreateManyAnalistaInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutAnalistaInput | DecisionLogUpdateWithWhereUniqueWithoutAnalistaInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutAnalistaInput | DecisionLogUpdateManyWithWhereWithoutAnalistaInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutAnalistaNestedInput = {
    create?: XOR<DecisionLogCreateWithoutAnalistaInput, DecisionLogUncheckedCreateWithoutAnalistaInput> | DecisionLogCreateWithoutAnalistaInput[] | DecisionLogUncheckedCreateWithoutAnalistaInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutAnalistaInput | DecisionLogCreateOrConnectWithoutAnalistaInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutAnalistaInput | DecisionLogUpsertWithWhereUniqueWithoutAnalistaInput[]
    createMany?: DecisionLogCreateManyAnalistaInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutAnalistaInput | DecisionLogUpdateWithWhereUniqueWithoutAnalistaInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutAnalistaInput | DecisionLogUpdateManyWithWhereWithoutAnalistaInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type ProjetoCreateNestedManyWithoutClienteInput = {
    create?: XOR<ProjetoCreateWithoutClienteInput, ProjetoUncheckedCreateWithoutClienteInput> | ProjetoCreateWithoutClienteInput[] | ProjetoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ProjetoCreateOrConnectWithoutClienteInput | ProjetoCreateOrConnectWithoutClienteInput[]
    createMany?: ProjetoCreateManyClienteInputEnvelope
    connect?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
  }

  export type DeploymentCreateNestedManyWithoutClientInput = {
    create?: XOR<DeploymentCreateWithoutClientInput, DeploymentUncheckedCreateWithoutClientInput> | DeploymentCreateWithoutClientInput[] | DeploymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutClientInput | DeploymentCreateOrConnectWithoutClientInput[]
    createMany?: DeploymentCreateManyClientInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type ProjetoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ProjetoCreateWithoutClienteInput, ProjetoUncheckedCreateWithoutClienteInput> | ProjetoCreateWithoutClienteInput[] | ProjetoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ProjetoCreateOrConnectWithoutClienteInput | ProjetoCreateOrConnectWithoutClienteInput[]
    createMany?: ProjetoCreateManyClienteInputEnvelope
    connect?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
  }

  export type DeploymentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DeploymentCreateWithoutClientInput, DeploymentUncheckedCreateWithoutClientInput> | DeploymentCreateWithoutClientInput[] | DeploymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutClientInput | DeploymentCreateOrConnectWithoutClientInput[]
    createMany?: DeploymentCreateManyClientInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type ProjetoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ProjetoCreateWithoutClienteInput, ProjetoUncheckedCreateWithoutClienteInput> | ProjetoCreateWithoutClienteInput[] | ProjetoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ProjetoCreateOrConnectWithoutClienteInput | ProjetoCreateOrConnectWithoutClienteInput[]
    upsert?: ProjetoUpsertWithWhereUniqueWithoutClienteInput | ProjetoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ProjetoCreateManyClienteInputEnvelope
    set?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    disconnect?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    delete?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    connect?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    update?: ProjetoUpdateWithWhereUniqueWithoutClienteInput | ProjetoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ProjetoUpdateManyWithWhereWithoutClienteInput | ProjetoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ProjetoScalarWhereInput | ProjetoScalarWhereInput[]
  }

  export type DeploymentUpdateManyWithoutClientNestedInput = {
    create?: XOR<DeploymentCreateWithoutClientInput, DeploymentUncheckedCreateWithoutClientInput> | DeploymentCreateWithoutClientInput[] | DeploymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutClientInput | DeploymentCreateOrConnectWithoutClientInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutClientInput | DeploymentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DeploymentCreateManyClientInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutClientInput | DeploymentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutClientInput | DeploymentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type ProjetoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ProjetoCreateWithoutClienteInput, ProjetoUncheckedCreateWithoutClienteInput> | ProjetoCreateWithoutClienteInput[] | ProjetoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ProjetoCreateOrConnectWithoutClienteInput | ProjetoCreateOrConnectWithoutClienteInput[]
    upsert?: ProjetoUpsertWithWhereUniqueWithoutClienteInput | ProjetoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ProjetoCreateManyClienteInputEnvelope
    set?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    disconnect?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    delete?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    connect?: ProjetoWhereUniqueInput | ProjetoWhereUniqueInput[]
    update?: ProjetoUpdateWithWhereUniqueWithoutClienteInput | ProjetoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ProjetoUpdateManyWithWhereWithoutClienteInput | ProjetoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ProjetoScalarWhereInput | ProjetoScalarWhereInput[]
  }

  export type DeploymentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DeploymentCreateWithoutClientInput, DeploymentUncheckedCreateWithoutClientInput> | DeploymentCreateWithoutClientInput[] | DeploymentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutClientInput | DeploymentCreateOrConnectWithoutClientInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutClientInput | DeploymentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DeploymentCreateManyClientInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutClientInput | DeploymentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutClientInput | DeploymentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type AnalystCreateNestedOneWithoutLogsInput = {
    create?: XOR<AnalystCreateWithoutLogsInput, AnalystUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AnalystCreateOrConnectWithoutLogsInput
    connect?: AnalystWhereUniqueInput
  }

  export type DeploymentCreateNestedOneWithoutDecisionsInput = {
    create?: XOR<DeploymentCreateWithoutDecisionsInput, DeploymentUncheckedCreateWithoutDecisionsInput>
    connectOrCreate?: DeploymentCreateOrConnectWithoutDecisionsInput
    connect?: DeploymentWhereUniqueInput
  }

  export type AnalystUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<AnalystCreateWithoutLogsInput, AnalystUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AnalystCreateOrConnectWithoutLogsInput
    upsert?: AnalystUpsertWithoutLogsInput
    connect?: AnalystWhereUniqueInput
    update?: XOR<XOR<AnalystUpdateToOneWithWhereWithoutLogsInput, AnalystUpdateWithoutLogsInput>, AnalystUncheckedUpdateWithoutLogsInput>
  }

  export type DeploymentUpdateOneRequiredWithoutDecisionsNestedInput = {
    create?: XOR<DeploymentCreateWithoutDecisionsInput, DeploymentUncheckedCreateWithoutDecisionsInput>
    connectOrCreate?: DeploymentCreateOrConnectWithoutDecisionsInput
    upsert?: DeploymentUpsertWithoutDecisionsInput
    connect?: DeploymentWhereUniqueInput
    update?: XOR<XOR<DeploymentUpdateToOneWithWhereWithoutDecisionsInput, DeploymentUpdateWithoutDecisionsInput>, DeploymentUncheckedUpdateWithoutDecisionsInput>
  }

  export type ProjetoCreateNestedOneWithoutLogsInput = {
    create?: XOR<ProjetoCreateWithoutLogsInput, ProjetoUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutLogsInput
    connect?: ProjetoWhereUniqueInput
  }

  export type ProjetoUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ProjetoCreateWithoutLogsInput, ProjetoUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutLogsInput
    upsert?: ProjetoUpsertWithoutLogsInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutLogsInput, ProjetoUpdateWithoutLogsInput>, ProjetoUncheckedUpdateWithoutLogsInput>
  }

  export type ClientCreateNestedOneWithoutDeploymentsInput = {
    create?: XOR<ClientCreateWithoutDeploymentsInput, ClientUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDeploymentsInput
    connect?: ClientWhereUniqueInput
  }

  export type DecisionLogCreateNestedManyWithoutDeploymentInput = {
    create?: XOR<DecisionLogCreateWithoutDeploymentInput, DecisionLogUncheckedCreateWithoutDeploymentInput> | DecisionLogCreateWithoutDeploymentInput[] | DecisionLogUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutDeploymentInput | DecisionLogCreateOrConnectWithoutDeploymentInput[]
    createMany?: DecisionLogCreateManyDeploymentInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type DecisionLogUncheckedCreateNestedManyWithoutDeploymentInput = {
    create?: XOR<DecisionLogCreateWithoutDeploymentInput, DecisionLogUncheckedCreateWithoutDeploymentInput> | DecisionLogCreateWithoutDeploymentInput[] | DecisionLogUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutDeploymentInput | DecisionLogCreateOrConnectWithoutDeploymentInput[]
    createMany?: DecisionLogCreateManyDeploymentInputEnvelope
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutDeploymentsNestedInput = {
    create?: XOR<ClientCreateWithoutDeploymentsInput, ClientUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDeploymentsInput
    upsert?: ClientUpsertWithoutDeploymentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDeploymentsInput, ClientUpdateWithoutDeploymentsInput>, ClientUncheckedUpdateWithoutDeploymentsInput>
  }

  export type DecisionLogUpdateManyWithoutDeploymentNestedInput = {
    create?: XOR<DecisionLogCreateWithoutDeploymentInput, DecisionLogUncheckedCreateWithoutDeploymentInput> | DecisionLogCreateWithoutDeploymentInput[] | DecisionLogUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutDeploymentInput | DecisionLogCreateOrConnectWithoutDeploymentInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutDeploymentInput | DecisionLogUpsertWithWhereUniqueWithoutDeploymentInput[]
    createMany?: DecisionLogCreateManyDeploymentInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutDeploymentInput | DecisionLogUpdateWithWhereUniqueWithoutDeploymentInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutDeploymentInput | DecisionLogUpdateManyWithWhereWithoutDeploymentInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type DecisionLogUncheckedUpdateManyWithoutDeploymentNestedInput = {
    create?: XOR<DecisionLogCreateWithoutDeploymentInput, DecisionLogUncheckedCreateWithoutDeploymentInput> | DecisionLogCreateWithoutDeploymentInput[] | DecisionLogUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DecisionLogCreateOrConnectWithoutDeploymentInput | DecisionLogCreateOrConnectWithoutDeploymentInput[]
    upsert?: DecisionLogUpsertWithWhereUniqueWithoutDeploymentInput | DecisionLogUpsertWithWhereUniqueWithoutDeploymentInput[]
    createMany?: DecisionLogCreateManyDeploymentInputEnvelope
    set?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    disconnect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    delete?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    connect?: DecisionLogWhereUniqueInput | DecisionLogWhereUniqueInput[]
    update?: DecisionLogUpdateWithWhereUniqueWithoutDeploymentInput | DecisionLogUpdateWithWhereUniqueWithoutDeploymentInput[]
    updateMany?: DecisionLogUpdateManyWithWhereWithoutDeploymentInput | DecisionLogUpdateManyWithWhereWithoutDeploymentInput[]
    deleteMany?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
  }

  export type ProjetoCreateNestedOneWithoutLevantamentoInput = {
    create?: XOR<ProjetoCreateWithoutLevantamentoInput, ProjetoUncheckedCreateWithoutLevantamentoInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutLevantamentoInput
    connect?: ProjetoWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProjetoUpdateOneRequiredWithoutLevantamentoNestedInput = {
    create?: XOR<ProjetoCreateWithoutLevantamentoInput, ProjetoUncheckedCreateWithoutLevantamentoInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutLevantamentoInput
    upsert?: ProjetoUpsertWithoutLevantamentoInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutLevantamentoInput, ProjetoUpdateWithoutLevantamentoInput>, ProjetoUncheckedUpdateWithoutLevantamentoInput>
  }

  export type ProjetoCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<ProjetoCreateWithoutUsuariosInput, ProjetoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutUsuariosInput
    connect?: ProjetoWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjetoUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<ProjetoCreateWithoutUsuariosInput, ProjetoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutUsuariosInput
    upsert?: ProjetoUpsertWithoutUsuariosInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutUsuariosInput, ProjetoUpdateWithoutUsuariosInput>, ProjetoUncheckedUpdateWithoutUsuariosInput>
  }

  export type ProjetoCreateNestedOneWithoutEmailConfigInput = {
    create?: XOR<ProjetoCreateWithoutEmailConfigInput, ProjetoUncheckedCreateWithoutEmailConfigInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutEmailConfigInput
    connect?: ProjetoWhereUniqueInput
  }

  export type ProjetoUpdateOneRequiredWithoutEmailConfigNestedInput = {
    create?: XOR<ProjetoCreateWithoutEmailConfigInput, ProjetoUncheckedCreateWithoutEmailConfigInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutEmailConfigInput
    upsert?: ProjetoUpsertWithoutEmailConfigInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutEmailConfigInput, ProjetoUpdateWithoutEmailConfigInput>, ProjetoUncheckedUpdateWithoutEmailConfigInput>
  }

  export type ProjetoCreateNestedOneWithoutSharepointInput = {
    create?: XOR<ProjetoCreateWithoutSharepointInput, ProjetoUncheckedCreateWithoutSharepointInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutSharepointInput
    connect?: ProjetoWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjetoUpdateOneRequiredWithoutSharepointNestedInput = {
    create?: XOR<ProjetoCreateWithoutSharepointInput, ProjetoUncheckedCreateWithoutSharepointInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutSharepointInput
    upsert?: ProjetoUpsertWithoutSharepointInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutSharepointInput, ProjetoUpdateWithoutSharepointInput>, ProjetoUncheckedUpdateWithoutSharepointInput>
  }

  export type ProjetoCreateNestedOneWithoutTeamsInput = {
    create?: XOR<ProjetoCreateWithoutTeamsInput, ProjetoUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutTeamsInput
    connect?: ProjetoWhereUniqueInput
  }

  export type ProjetoUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<ProjetoCreateWithoutTeamsInput, ProjetoUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutTeamsInput
    upsert?: ProjetoUpsertWithoutTeamsInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutTeamsInput, ProjetoUpdateWithoutTeamsInput>, ProjetoUncheckedUpdateWithoutTeamsInput>
  }

  export type ProjetoCreateNestedOneWithoutCronogramaInput = {
    create?: XOR<ProjetoCreateWithoutCronogramaInput, ProjetoUncheckedCreateWithoutCronogramaInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutCronogramaInput
    connect?: ProjetoWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjetoUpdateOneRequiredWithoutCronogramaNestedInput = {
    create?: XOR<ProjetoCreateWithoutCronogramaInput, ProjetoUncheckedCreateWithoutCronogramaInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutCronogramaInput
    upsert?: ProjetoUpsertWithoutCronogramaInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutCronogramaInput, ProjetoUpdateWithoutCronogramaInput>, ProjetoUncheckedUpdateWithoutCronogramaInput>
  }

  export type ProjetoCreateNestedOneWithoutLicenciamentoInput = {
    create?: XOR<ProjetoCreateWithoutLicenciamentoInput, ProjetoUncheckedCreateWithoutLicenciamentoInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutLicenciamentoInput
    connect?: ProjetoWhereUniqueInput
  }

  export type ProjetoUpdateOneRequiredWithoutLicenciamentoNestedInput = {
    create?: XOR<ProjetoCreateWithoutLicenciamentoInput, ProjetoUncheckedCreateWithoutLicenciamentoInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutLicenciamentoInput
    upsert?: ProjetoUpsertWithoutLicenciamentoInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutLicenciamentoInput, ProjetoUpdateWithoutLicenciamentoInput>, ProjetoUncheckedUpdateWithoutLicenciamentoInput>
  }

  export type ProjetoCreateNestedOneWithoutOrientacoesInput = {
    create?: XOR<ProjetoCreateWithoutOrientacoesInput, ProjetoUncheckedCreateWithoutOrientacoesInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutOrientacoesInput
    connect?: ProjetoWhereUniqueInput
  }

  export type ProjetoUpdateOneRequiredWithoutOrientacoesNestedInput = {
    create?: XOR<ProjetoCreateWithoutOrientacoesInput, ProjetoUncheckedCreateWithoutOrientacoesInput>
    connectOrCreate?: ProjetoCreateOrConnectWithoutOrientacoesInput
    upsert?: ProjetoUpsertWithoutOrientacoesInput
    connect?: ProjetoWhereUniqueInput
    update?: XOR<XOR<ProjetoUpdateToOneWithWhereWithoutOrientacoesInput, ProjetoUpdateWithoutOrientacoesInput>, ProjetoUncheckedUpdateWithoutOrientacoesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClientCreateWithoutProjetosInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    deployments?: DeploymentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProjetosInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    deployments?: DeploymentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProjetosInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProjetosInput, ClientUncheckedCreateWithoutProjetosInput>
  }

  export type LevantamentoCreateWithoutProjetoInput = {
    id?: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado?: boolean
    observacoes?: string | null
  }

  export type LevantamentoUncheckedCreateWithoutProjetoInput = {
    id?: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado?: boolean
    observacoes?: string | null
  }

  export type LevantamentoCreateOrConnectWithoutProjetoInput = {
    where: LevantamentoWhereUniqueInput
    create: XOR<LevantamentoCreateWithoutProjetoInput, LevantamentoUncheckedCreateWithoutProjetoInput>
  }

  export type LevantamentoCreateManyProjetoInputEnvelope = {
    data: LevantamentoCreateManyProjetoInput | LevantamentoCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutProjetoInput = {
    id?: string
    nome: string
    departamento?: string | null
    cargo?: string | null
    email: string
    caixaMB?: number | null
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: Date | string
  }

  export type UsuarioUncheckedCreateWithoutProjetoInput = {
    id?: string
    nome: string
    departamento?: string | null
    cargo?: string | null
    email: string
    caixaMB?: number | null
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: Date | string
  }

  export type UsuarioCreateOrConnectWithoutProjetoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProjetoInput, UsuarioUncheckedCreateWithoutProjetoInput>
  }

  export type UsuarioCreateManyProjetoInputEnvelope = {
    data: UsuarioCreateManyProjetoInput | UsuarioCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type EmailConfigCreateWithoutProjetoInput = {
    id?: string
    plataformaOrigem: string
    metodologia?: string | null
    janelaMigracao?: string | null
    volumeTotalMB?: number | null
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: string | null
    gruposDistribuicao?: string | null
    observacoes?: string | null
  }

  export type EmailConfigUncheckedCreateWithoutProjetoInput = {
    id?: string
    plataformaOrigem: string
    metodologia?: string | null
    janelaMigracao?: string | null
    volumeTotalMB?: number | null
    migrarCalendarios?: boolean
    migrarContatos?: boolean
    backupPst?: boolean
    caixasCompartilhadas?: string | null
    gruposDistribuicao?: string | null
    observacoes?: string | null
  }

  export type EmailConfigCreateOrConnectWithoutProjetoInput = {
    where: EmailConfigWhereUniqueInput
    create: XOR<EmailConfigCreateWithoutProjetoInput, EmailConfigUncheckedCreateWithoutProjetoInput>
  }

  export type SharePointSiteCreateWithoutProjetoInput = {
    id?: string
    nome: string
    tipo: string
    proposito?: string | null
    proprietarios?: string | null
    membros?: string | null
    nivelAcesso?: string | null
    volumeGB?: number | null
    pastaOrigem?: string | null
  }

  export type SharePointSiteUncheckedCreateWithoutProjetoInput = {
    id?: string
    nome: string
    tipo: string
    proposito?: string | null
    proprietarios?: string | null
    membros?: string | null
    nivelAcesso?: string | null
    volumeGB?: number | null
    pastaOrigem?: string | null
  }

  export type SharePointSiteCreateOrConnectWithoutProjetoInput = {
    where: SharePointSiteWhereUniqueInput
    create: XOR<SharePointSiteCreateWithoutProjetoInput, SharePointSiteUncheckedCreateWithoutProjetoInput>
  }

  export type SharePointSiteCreateManyProjetoInputEnvelope = {
    data: SharePointSiteCreateManyProjetoInput | SharePointSiteCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type TeamsConfigCreateWithoutProjetoInput = {
    id?: string
    nomeEquipe?: string | null
    tipoEquipe?: string | null
    proposito?: string | null
    proprietarios?: string | null
    membrosIniciais?: string | null
    canais?: string | null
    recursos?: string | null
    observacoes?: string | null
  }

  export type TeamsConfigUncheckedCreateWithoutProjetoInput = {
    id?: string
    nomeEquipe?: string | null
    tipoEquipe?: string | null
    proposito?: string | null
    proprietarios?: string | null
    membrosIniciais?: string | null
    canais?: string | null
    recursos?: string | null
    observacoes?: string | null
  }

  export type TeamsConfigCreateOrConnectWithoutProjetoInput = {
    where: TeamsConfigWhereUniqueInput
    create: XOR<TeamsConfigCreateWithoutProjetoInput, TeamsConfigUncheckedCreateWithoutProjetoInput>
  }

  export type CronogramaItemCreateWithoutProjetoInput = {
    id?: string
    nome: string
    responsavel?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    status?: string
    ordem?: number | null
  }

  export type CronogramaItemUncheckedCreateWithoutProjetoInput = {
    id?: string
    nome: string
    responsavel?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    status?: string
    ordem?: number | null
  }

  export type CronogramaItemCreateOrConnectWithoutProjetoInput = {
    where: CronogramaItemWhereUniqueInput
    create: XOR<CronogramaItemCreateWithoutProjetoInput, CronogramaItemUncheckedCreateWithoutProjetoInput>
  }

  export type CronogramaItemCreateManyProjetoInputEnvelope = {
    data: CronogramaItemCreateManyProjetoInput | CronogramaItemCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type LicenciamentoCreateWithoutProjetoInput = {
    id?: string
    m365basic?: number | null
    m365standard?: number | null
    appsforbusiness?: number | null
    f3?: number | null
    e3?: number | null
    e5?: number | null
    observacoes?: string | null
  }

  export type LicenciamentoUncheckedCreateWithoutProjetoInput = {
    id?: string
    m365basic?: number | null
    m365standard?: number | null
    appsforbusiness?: number | null
    f3?: number | null
    e3?: number | null
    e5?: number | null
    observacoes?: string | null
  }

  export type LicenciamentoCreateOrConnectWithoutProjetoInput = {
    where: LicenciamentoWhereUniqueInput
    create: XOR<LicenciamentoCreateWithoutProjetoInput, LicenciamentoUncheckedCreateWithoutProjetoInput>
  }

  export type OrientacaoCreateWithoutProjetoInput = {
    id?: string
    teams?: string | null
    sharepoint?: string | null
    emails?: string | null
    licencas?: string | null
    seguranca?: string | null
    governance?: string | null
  }

  export type OrientacaoUncheckedCreateWithoutProjetoInput = {
    id?: string
    teams?: string | null
    sharepoint?: string | null
    emails?: string | null
    licencas?: string | null
    seguranca?: string | null
    governance?: string | null
  }

  export type OrientacaoCreateOrConnectWithoutProjetoInput = {
    where: OrientacaoWhereUniqueInput
    create: XOR<OrientacaoCreateWithoutProjetoInput, OrientacaoUncheckedCreateWithoutProjetoInput>
  }

  export type LogProjetoCreateWithoutProjetoInput = {
    id?: string
    mensagem: string
    criadoEm?: Date | string
  }

  export type LogProjetoUncheckedCreateWithoutProjetoInput = {
    id?: string
    mensagem: string
    criadoEm?: Date | string
  }

  export type LogProjetoCreateOrConnectWithoutProjetoInput = {
    where: LogProjetoWhereUniqueInput
    create: XOR<LogProjetoCreateWithoutProjetoInput, LogProjetoUncheckedCreateWithoutProjetoInput>
  }

  export type LogProjetoCreateManyProjetoInputEnvelope = {
    data: LogProjetoCreateManyProjetoInput | LogProjetoCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutProjetosInput = {
    update: XOR<ClientUpdateWithoutProjetosInput, ClientUncheckedUpdateWithoutProjetosInput>
    create: XOR<ClientCreateWithoutProjetosInput, ClientUncheckedCreateWithoutProjetosInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProjetosInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProjetosInput, ClientUncheckedUpdateWithoutProjetosInput>
  }

  export type ClientUpdateWithoutProjetosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProjetosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LevantamentoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: LevantamentoWhereUniqueInput
    update: XOR<LevantamentoUpdateWithoutProjetoInput, LevantamentoUncheckedUpdateWithoutProjetoInput>
    create: XOR<LevantamentoCreateWithoutProjetoInput, LevantamentoUncheckedCreateWithoutProjetoInput>
  }

  export type LevantamentoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: LevantamentoWhereUniqueInput
    data: XOR<LevantamentoUpdateWithoutProjetoInput, LevantamentoUncheckedUpdateWithoutProjetoInput>
  }

  export type LevantamentoUpdateManyWithWhereWithoutProjetoInput = {
    where: LevantamentoScalarWhereInput
    data: XOR<LevantamentoUpdateManyMutationInput, LevantamentoUncheckedUpdateManyWithoutProjetoInput>
  }

  export type LevantamentoScalarWhereInput = {
    AND?: LevantamentoScalarWhereInput | LevantamentoScalarWhereInput[]
    OR?: LevantamentoScalarWhereInput[]
    NOT?: LevantamentoScalarWhereInput | LevantamentoScalarWhereInput[]
    id?: StringFilter<"Levantamento"> | string
    projetoId?: StringFilter<"Levantamento"> | string
    nome?: StringFilter<"Levantamento"> | string
    categoria?: StringFilter<"Levantamento"> | string
    criticidade?: StringFilter<"Levantamento"> | string
    tempoEstimado?: IntFilter<"Levantamento"> | number
    selecionado?: BoolFilter<"Levantamento"> | boolean
    observacoes?: StringNullableFilter<"Levantamento"> | string | null
  }

  export type UsuarioUpsertWithWhereUniqueWithoutProjetoInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutProjetoInput, UsuarioUncheckedUpdateWithoutProjetoInput>
    create: XOR<UsuarioCreateWithoutProjetoInput, UsuarioUncheckedCreateWithoutProjetoInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutProjetoInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutProjetoInput, UsuarioUncheckedUpdateWithoutProjetoInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutProjetoInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutProjetoInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: StringFilter<"Usuario"> | string
    projetoId?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    departamento?: StringNullableFilter<"Usuario"> | string | null
    cargo?: StringNullableFilter<"Usuario"> | string | null
    email?: StringFilter<"Usuario"> | string
    caixaMB?: IntNullableFilter<"Usuario"> | number | null
    officeLocal?: BoolFilter<"Usuario"> | boolean
    migrarEmail?: BoolFilter<"Usuario"> | boolean
    oneDrive?: BoolFilter<"Usuario"> | boolean
    sharePoint?: BoolFilter<"Usuario"> | boolean
    teams?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
  }

  export type EmailConfigUpsertWithoutProjetoInput = {
    update: XOR<EmailConfigUpdateWithoutProjetoInput, EmailConfigUncheckedUpdateWithoutProjetoInput>
    create: XOR<EmailConfigCreateWithoutProjetoInput, EmailConfigUncheckedCreateWithoutProjetoInput>
    where?: EmailConfigWhereInput
  }

  export type EmailConfigUpdateToOneWithWhereWithoutProjetoInput = {
    where?: EmailConfigWhereInput
    data: XOR<EmailConfigUpdateWithoutProjetoInput, EmailConfigUncheckedUpdateWithoutProjetoInput>
  }

  export type EmailConfigUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    plataformaOrigem?: StringFieldUpdateOperationsInput | string
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    janelaMigracao?: NullableStringFieldUpdateOperationsInput | string | null
    volumeTotalMB?: NullableIntFieldUpdateOperationsInput | number | null
    migrarCalendarios?: BoolFieldUpdateOperationsInput | boolean
    migrarContatos?: BoolFieldUpdateOperationsInput | boolean
    backupPst?: BoolFieldUpdateOperationsInput | boolean
    caixasCompartilhadas?: NullableStringFieldUpdateOperationsInput | string | null
    gruposDistribuicao?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailConfigUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    plataformaOrigem?: StringFieldUpdateOperationsInput | string
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    janelaMigracao?: NullableStringFieldUpdateOperationsInput | string | null
    volumeTotalMB?: NullableIntFieldUpdateOperationsInput | number | null
    migrarCalendarios?: BoolFieldUpdateOperationsInput | boolean
    migrarContatos?: BoolFieldUpdateOperationsInput | boolean
    backupPst?: BoolFieldUpdateOperationsInput | boolean
    caixasCompartilhadas?: NullableStringFieldUpdateOperationsInput | string | null
    gruposDistribuicao?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharePointSiteUpsertWithWhereUniqueWithoutProjetoInput = {
    where: SharePointSiteWhereUniqueInput
    update: XOR<SharePointSiteUpdateWithoutProjetoInput, SharePointSiteUncheckedUpdateWithoutProjetoInput>
    create: XOR<SharePointSiteCreateWithoutProjetoInput, SharePointSiteUncheckedCreateWithoutProjetoInput>
  }

  export type SharePointSiteUpdateWithWhereUniqueWithoutProjetoInput = {
    where: SharePointSiteWhereUniqueInput
    data: XOR<SharePointSiteUpdateWithoutProjetoInput, SharePointSiteUncheckedUpdateWithoutProjetoInput>
  }

  export type SharePointSiteUpdateManyWithWhereWithoutProjetoInput = {
    where: SharePointSiteScalarWhereInput
    data: XOR<SharePointSiteUpdateManyMutationInput, SharePointSiteUncheckedUpdateManyWithoutProjetoInput>
  }

  export type SharePointSiteScalarWhereInput = {
    AND?: SharePointSiteScalarWhereInput | SharePointSiteScalarWhereInput[]
    OR?: SharePointSiteScalarWhereInput[]
    NOT?: SharePointSiteScalarWhereInput | SharePointSiteScalarWhereInput[]
    id?: StringFilter<"SharePointSite"> | string
    projetoId?: StringFilter<"SharePointSite"> | string
    nome?: StringFilter<"SharePointSite"> | string
    tipo?: StringFilter<"SharePointSite"> | string
    proposito?: StringNullableFilter<"SharePointSite"> | string | null
    proprietarios?: StringNullableFilter<"SharePointSite"> | string | null
    membros?: StringNullableFilter<"SharePointSite"> | string | null
    nivelAcesso?: StringNullableFilter<"SharePointSite"> | string | null
    volumeGB?: FloatNullableFilter<"SharePointSite"> | number | null
    pastaOrigem?: StringNullableFilter<"SharePointSite"> | string | null
  }

  export type TeamsConfigUpsertWithoutProjetoInput = {
    update: XOR<TeamsConfigUpdateWithoutProjetoInput, TeamsConfigUncheckedUpdateWithoutProjetoInput>
    create: XOR<TeamsConfigCreateWithoutProjetoInput, TeamsConfigUncheckedCreateWithoutProjetoInput>
    where?: TeamsConfigWhereInput
  }

  export type TeamsConfigUpdateToOneWithWhereWithoutProjetoInput = {
    where?: TeamsConfigWhereInput
    data: XOR<TeamsConfigUpdateWithoutProjetoInput, TeamsConfigUncheckedUpdateWithoutProjetoInput>
  }

  export type TeamsConfigUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    tipoEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membrosIniciais?: NullableStringFieldUpdateOperationsInput | string | null
    canais?: NullableStringFieldUpdateOperationsInput | string | null
    recursos?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamsConfigUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    tipoEquipe?: NullableStringFieldUpdateOperationsInput | string | null
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membrosIniciais?: NullableStringFieldUpdateOperationsInput | string | null
    canais?: NullableStringFieldUpdateOperationsInput | string | null
    recursos?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronogramaItemUpsertWithWhereUniqueWithoutProjetoInput = {
    where: CronogramaItemWhereUniqueInput
    update: XOR<CronogramaItemUpdateWithoutProjetoInput, CronogramaItemUncheckedUpdateWithoutProjetoInput>
    create: XOR<CronogramaItemCreateWithoutProjetoInput, CronogramaItemUncheckedCreateWithoutProjetoInput>
  }

  export type CronogramaItemUpdateWithWhereUniqueWithoutProjetoInput = {
    where: CronogramaItemWhereUniqueInput
    data: XOR<CronogramaItemUpdateWithoutProjetoInput, CronogramaItemUncheckedUpdateWithoutProjetoInput>
  }

  export type CronogramaItemUpdateManyWithWhereWithoutProjetoInput = {
    where: CronogramaItemScalarWhereInput
    data: XOR<CronogramaItemUpdateManyMutationInput, CronogramaItemUncheckedUpdateManyWithoutProjetoInput>
  }

  export type CronogramaItemScalarWhereInput = {
    AND?: CronogramaItemScalarWhereInput | CronogramaItemScalarWhereInput[]
    OR?: CronogramaItemScalarWhereInput[]
    NOT?: CronogramaItemScalarWhereInput | CronogramaItemScalarWhereInput[]
    id?: StringFilter<"CronogramaItem"> | string
    projetoId?: StringFilter<"CronogramaItem"> | string
    nome?: StringFilter<"CronogramaItem"> | string
    responsavel?: StringNullableFilter<"CronogramaItem"> | string | null
    inicio?: DateTimeNullableFilter<"CronogramaItem"> | Date | string | null
    fim?: DateTimeNullableFilter<"CronogramaItem"> | Date | string | null
    status?: StringFilter<"CronogramaItem"> | string
    ordem?: IntNullableFilter<"CronogramaItem"> | number | null
  }

  export type LicenciamentoUpsertWithoutProjetoInput = {
    update: XOR<LicenciamentoUpdateWithoutProjetoInput, LicenciamentoUncheckedUpdateWithoutProjetoInput>
    create: XOR<LicenciamentoCreateWithoutProjetoInput, LicenciamentoUncheckedCreateWithoutProjetoInput>
    where?: LicenciamentoWhereInput
  }

  export type LicenciamentoUpdateToOneWithWhereWithoutProjetoInput = {
    where?: LicenciamentoWhereInput
    data: XOR<LicenciamentoUpdateWithoutProjetoInput, LicenciamentoUncheckedUpdateWithoutProjetoInput>
  }

  export type LicenciamentoUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    m365basic?: NullableIntFieldUpdateOperationsInput | number | null
    m365standard?: NullableIntFieldUpdateOperationsInput | number | null
    appsforbusiness?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    e3?: NullableIntFieldUpdateOperationsInput | number | null
    e5?: NullableIntFieldUpdateOperationsInput | number | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenciamentoUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    m365basic?: NullableIntFieldUpdateOperationsInput | number | null
    m365standard?: NullableIntFieldUpdateOperationsInput | number | null
    appsforbusiness?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    e3?: NullableIntFieldUpdateOperationsInput | number | null
    e5?: NullableIntFieldUpdateOperationsInput | number | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrientacaoUpsertWithoutProjetoInput = {
    update: XOR<OrientacaoUpdateWithoutProjetoInput, OrientacaoUncheckedUpdateWithoutProjetoInput>
    create: XOR<OrientacaoCreateWithoutProjetoInput, OrientacaoUncheckedCreateWithoutProjetoInput>
    where?: OrientacaoWhereInput
  }

  export type OrientacaoUpdateToOneWithWhereWithoutProjetoInput = {
    where?: OrientacaoWhereInput
    data: XOR<OrientacaoUpdateWithoutProjetoInput, OrientacaoUncheckedUpdateWithoutProjetoInput>
  }

  export type OrientacaoUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    teams?: NullableStringFieldUpdateOperationsInput | string | null
    sharepoint?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    licencas?: NullableStringFieldUpdateOperationsInput | string | null
    seguranca?: NullableStringFieldUpdateOperationsInput | string | null
    governance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrientacaoUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    teams?: NullableStringFieldUpdateOperationsInput | string | null
    sharepoint?: NullableStringFieldUpdateOperationsInput | string | null
    emails?: NullableStringFieldUpdateOperationsInput | string | null
    licencas?: NullableStringFieldUpdateOperationsInput | string | null
    seguranca?: NullableStringFieldUpdateOperationsInput | string | null
    governance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogProjetoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: LogProjetoWhereUniqueInput
    update: XOR<LogProjetoUpdateWithoutProjetoInput, LogProjetoUncheckedUpdateWithoutProjetoInput>
    create: XOR<LogProjetoCreateWithoutProjetoInput, LogProjetoUncheckedCreateWithoutProjetoInput>
  }

  export type LogProjetoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: LogProjetoWhereUniqueInput
    data: XOR<LogProjetoUpdateWithoutProjetoInput, LogProjetoUncheckedUpdateWithoutProjetoInput>
  }

  export type LogProjetoUpdateManyWithWhereWithoutProjetoInput = {
    where: LogProjetoScalarWhereInput
    data: XOR<LogProjetoUpdateManyMutationInput, LogProjetoUncheckedUpdateManyWithoutProjetoInput>
  }

  export type LogProjetoScalarWhereInput = {
    AND?: LogProjetoScalarWhereInput | LogProjetoScalarWhereInput[]
    OR?: LogProjetoScalarWhereInput[]
    NOT?: LogProjetoScalarWhereInput | LogProjetoScalarWhereInput[]
    id?: StringFilter<"LogProjeto"> | string
    projetoId?: StringFilter<"LogProjeto"> | string
    mensagem?: StringFilter<"LogProjeto"> | string
    criadoEm?: DateTimeFilter<"LogProjeto"> | Date | string
  }

  export type DecisionLogCreateWithoutAnalistaInput = {
    id?: string
    descricao: string
    criadoEm?: Date | string
    deployment: DeploymentCreateNestedOneWithoutDecisionsInput
  }

  export type DecisionLogUncheckedCreateWithoutAnalistaInput = {
    id?: string
    deploymentId: string
    descricao: string
    criadoEm?: Date | string
  }

  export type DecisionLogCreateOrConnectWithoutAnalistaInput = {
    where: DecisionLogWhereUniqueInput
    create: XOR<DecisionLogCreateWithoutAnalistaInput, DecisionLogUncheckedCreateWithoutAnalistaInput>
  }

  export type DecisionLogCreateManyAnalistaInputEnvelope = {
    data: DecisionLogCreateManyAnalistaInput | DecisionLogCreateManyAnalistaInput[]
    skipDuplicates?: boolean
  }

  export type DecisionLogUpsertWithWhereUniqueWithoutAnalistaInput = {
    where: DecisionLogWhereUniqueInput
    update: XOR<DecisionLogUpdateWithoutAnalistaInput, DecisionLogUncheckedUpdateWithoutAnalistaInput>
    create: XOR<DecisionLogCreateWithoutAnalistaInput, DecisionLogUncheckedCreateWithoutAnalistaInput>
  }

  export type DecisionLogUpdateWithWhereUniqueWithoutAnalistaInput = {
    where: DecisionLogWhereUniqueInput
    data: XOR<DecisionLogUpdateWithoutAnalistaInput, DecisionLogUncheckedUpdateWithoutAnalistaInput>
  }

  export type DecisionLogUpdateManyWithWhereWithoutAnalistaInput = {
    where: DecisionLogScalarWhereInput
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyWithoutAnalistaInput>
  }

  export type DecisionLogScalarWhereInput = {
    AND?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
    OR?: DecisionLogScalarWhereInput[]
    NOT?: DecisionLogScalarWhereInput | DecisionLogScalarWhereInput[]
    id?: StringFilter<"DecisionLog"> | string
    analistaId?: StringFilter<"DecisionLog"> | string
    deploymentId?: StringFilter<"DecisionLog"> | string
    descricao?: StringFilter<"DecisionLog"> | string
    criadoEm?: DateTimeFilter<"DecisionLog"> | Date | string
  }

  export type ProjetoCreateWithoutClienteInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutClienteInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutClienteInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutClienteInput, ProjetoUncheckedCreateWithoutClienteInput>
  }

  export type ProjetoCreateManyClienteInputEnvelope = {
    data: ProjetoCreateManyClienteInput | ProjetoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type DeploymentCreateWithoutClientInput = {
    id?: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    decisions?: DecisionLogCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateWithoutClientInput = {
    id?: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    decisions?: DecisionLogUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentCreateOrConnectWithoutClientInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutClientInput, DeploymentUncheckedCreateWithoutClientInput>
  }

  export type DeploymentCreateManyClientInputEnvelope = {
    data: DeploymentCreateManyClientInput | DeploymentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjetoUpsertWithWhereUniqueWithoutClienteInput = {
    where: ProjetoWhereUniqueInput
    update: XOR<ProjetoUpdateWithoutClienteInput, ProjetoUncheckedUpdateWithoutClienteInput>
    create: XOR<ProjetoCreateWithoutClienteInput, ProjetoUncheckedCreateWithoutClienteInput>
  }

  export type ProjetoUpdateWithWhereUniqueWithoutClienteInput = {
    where: ProjetoWhereUniqueInput
    data: XOR<ProjetoUpdateWithoutClienteInput, ProjetoUncheckedUpdateWithoutClienteInput>
  }

  export type ProjetoUpdateManyWithWhereWithoutClienteInput = {
    where: ProjetoScalarWhereInput
    data: XOR<ProjetoUpdateManyMutationInput, ProjetoUncheckedUpdateManyWithoutClienteInput>
  }

  export type ProjetoScalarWhereInput = {
    AND?: ProjetoScalarWhereInput | ProjetoScalarWhereInput[]
    OR?: ProjetoScalarWhereInput[]
    NOT?: ProjetoScalarWhereInput | ProjetoScalarWhereInput[]
    id?: StringFilter<"Projeto"> | string
    nome?: StringFilter<"Projeto"> | string
    clienteId?: StringFilter<"Projeto"> | string
    descricao?: StringNullableFilter<"Projeto"> | string | null
    status?: StringFilter<"Projeto"> | string
    progresso?: IntFilter<"Projeto"> | number
    dataCriacao?: DateTimeFilter<"Projeto"> | Date | string
    dataAtualizacao?: DateTimeFilter<"Projeto"> | Date | string
  }

  export type DeploymentUpsertWithWhereUniqueWithoutClientInput = {
    where: DeploymentWhereUniqueInput
    update: XOR<DeploymentUpdateWithoutClientInput, DeploymentUncheckedUpdateWithoutClientInput>
    create: XOR<DeploymentCreateWithoutClientInput, DeploymentUncheckedCreateWithoutClientInput>
  }

  export type DeploymentUpdateWithWhereUniqueWithoutClientInput = {
    where: DeploymentWhereUniqueInput
    data: XOR<DeploymentUpdateWithoutClientInput, DeploymentUncheckedUpdateWithoutClientInput>
  }

  export type DeploymentUpdateManyWithWhereWithoutClientInput = {
    where: DeploymentScalarWhereInput
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutClientInput>
  }

  export type DeploymentScalarWhereInput = {
    AND?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
    OR?: DeploymentScalarWhereInput[]
    NOT?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
    id?: StringFilter<"Deployment"> | string
    clientId?: StringFilter<"Deployment"> | string
    modelSelected?: StringFilter<"Deployment"> | string
    licensing?: StringFilter<"Deployment"> | string
    status?: StringFilter<"Deployment"> | string
    notes?: StringNullableFilter<"Deployment"> | string | null
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
  }

  export type AnalystCreateWithoutLogsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    papel?: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AnalystUncheckedCreateWithoutLogsInput = {
    id?: string
    nome: string
    email: string
    senha: string
    papel?: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AnalystCreateOrConnectWithoutLogsInput = {
    where: AnalystWhereUniqueInput
    create: XOR<AnalystCreateWithoutLogsInput, AnalystUncheckedCreateWithoutLogsInput>
  }

  export type DeploymentCreateWithoutDecisionsInput = {
    id?: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutDeploymentsInput
  }

  export type DeploymentUncheckedCreateWithoutDecisionsInput = {
    id?: string
    clientId: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentCreateOrConnectWithoutDecisionsInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutDecisionsInput, DeploymentUncheckedCreateWithoutDecisionsInput>
  }

  export type AnalystUpsertWithoutLogsInput = {
    update: XOR<AnalystUpdateWithoutLogsInput, AnalystUncheckedUpdateWithoutLogsInput>
    create: XOR<AnalystCreateWithoutLogsInput, AnalystUncheckedCreateWithoutLogsInput>
    where?: AnalystWhereInput
  }

  export type AnalystUpdateToOneWithWhereWithoutLogsInput = {
    where?: AnalystWhereInput
    data: XOR<AnalystUpdateWithoutLogsInput, AnalystUncheckedUpdateWithoutLogsInput>
  }

  export type AnalystUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalystUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUpsertWithoutDecisionsInput = {
    update: XOR<DeploymentUpdateWithoutDecisionsInput, DeploymentUncheckedUpdateWithoutDecisionsInput>
    create: XOR<DeploymentCreateWithoutDecisionsInput, DeploymentUncheckedCreateWithoutDecisionsInput>
    where?: DeploymentWhereInput
  }

  export type DeploymentUpdateToOneWithWhereWithoutDecisionsInput = {
    where?: DeploymentWhereInput
    data: XOR<DeploymentUpdateWithoutDecisionsInput, DeploymentUncheckedUpdateWithoutDecisionsInput>
  }

  export type DeploymentUpdateWithoutDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutDeploymentsNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjetoCreateWithoutLogsInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutLogsInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutLogsInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutLogsInput, ProjetoUncheckedCreateWithoutLogsInput>
  }

  export type ProjetoUpsertWithoutLogsInput = {
    update: XOR<ProjetoUpdateWithoutLogsInput, ProjetoUncheckedUpdateWithoutLogsInput>
    create: XOR<ProjetoCreateWithoutLogsInput, ProjetoUncheckedCreateWithoutLogsInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutLogsInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutLogsInput, ProjetoUncheckedUpdateWithoutLogsInput>
  }

  export type ProjetoUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
  }

  export type ClientCreateWithoutDeploymentsInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    projetos?: ProjetoCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutDeploymentsInput = {
    id?: string
    nome: string
    dominio: string
    segmento: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    projetos?: ProjetoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutDeploymentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDeploymentsInput, ClientUncheckedCreateWithoutDeploymentsInput>
  }

  export type DecisionLogCreateWithoutDeploymentInput = {
    id?: string
    descricao: string
    criadoEm?: Date | string
    analista: AnalystCreateNestedOneWithoutLogsInput
  }

  export type DecisionLogUncheckedCreateWithoutDeploymentInput = {
    id?: string
    analistaId: string
    descricao: string
    criadoEm?: Date | string
  }

  export type DecisionLogCreateOrConnectWithoutDeploymentInput = {
    where: DecisionLogWhereUniqueInput
    create: XOR<DecisionLogCreateWithoutDeploymentInput, DecisionLogUncheckedCreateWithoutDeploymentInput>
  }

  export type DecisionLogCreateManyDeploymentInputEnvelope = {
    data: DecisionLogCreateManyDeploymentInput | DecisionLogCreateManyDeploymentInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutDeploymentsInput = {
    update: XOR<ClientUpdateWithoutDeploymentsInput, ClientUncheckedUpdateWithoutDeploymentsInput>
    create: XOR<ClientCreateWithoutDeploymentsInput, ClientUncheckedCreateWithoutDeploymentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDeploymentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDeploymentsInput, ClientUncheckedUpdateWithoutDeploymentsInput>
  }

  export type ClientUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    projetos?: ProjetoUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    projetos?: ProjetoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type DecisionLogUpsertWithWhereUniqueWithoutDeploymentInput = {
    where: DecisionLogWhereUniqueInput
    update: XOR<DecisionLogUpdateWithoutDeploymentInput, DecisionLogUncheckedUpdateWithoutDeploymentInput>
    create: XOR<DecisionLogCreateWithoutDeploymentInput, DecisionLogUncheckedCreateWithoutDeploymentInput>
  }

  export type DecisionLogUpdateWithWhereUniqueWithoutDeploymentInput = {
    where: DecisionLogWhereUniqueInput
    data: XOR<DecisionLogUpdateWithoutDeploymentInput, DecisionLogUncheckedUpdateWithoutDeploymentInput>
  }

  export type DecisionLogUpdateManyWithWhereWithoutDeploymentInput = {
    where: DecisionLogScalarWhereInput
    data: XOR<DecisionLogUpdateManyMutationInput, DecisionLogUncheckedUpdateManyWithoutDeploymentInput>
  }

  export type ProjetoCreateWithoutLevantamentoInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutLevantamentoInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutLevantamentoInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutLevantamentoInput, ProjetoUncheckedCreateWithoutLevantamentoInput>
  }

  export type ProjetoUpsertWithoutLevantamentoInput = {
    update: XOR<ProjetoUpdateWithoutLevantamentoInput, ProjetoUncheckedUpdateWithoutLevantamentoInput>
    create: XOR<ProjetoCreateWithoutLevantamentoInput, ProjetoUncheckedCreateWithoutLevantamentoInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutLevantamentoInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutLevantamentoInput, ProjetoUncheckedUpdateWithoutLevantamentoInput>
  }

  export type ProjetoUpdateWithoutLevantamentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutLevantamentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutUsuariosInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutUsuariosInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutUsuariosInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutUsuariosInput, ProjetoUncheckedCreateWithoutUsuariosInput>
  }

  export type ProjetoUpsertWithoutUsuariosInput = {
    update: XOR<ProjetoUpdateWithoutUsuariosInput, ProjetoUncheckedUpdateWithoutUsuariosInput>
    create: XOR<ProjetoCreateWithoutUsuariosInput, ProjetoUncheckedCreateWithoutUsuariosInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutUsuariosInput, ProjetoUncheckedUpdateWithoutUsuariosInput>
  }

  export type ProjetoUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutUsuariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutEmailConfigInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutEmailConfigInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutEmailConfigInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutEmailConfigInput, ProjetoUncheckedCreateWithoutEmailConfigInput>
  }

  export type ProjetoUpsertWithoutEmailConfigInput = {
    update: XOR<ProjetoUpdateWithoutEmailConfigInput, ProjetoUncheckedUpdateWithoutEmailConfigInput>
    create: XOR<ProjetoCreateWithoutEmailConfigInput, ProjetoUncheckedCreateWithoutEmailConfigInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutEmailConfigInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutEmailConfigInput, ProjetoUncheckedUpdateWithoutEmailConfigInput>
  }

  export type ProjetoUpdateWithoutEmailConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutEmailConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutSharepointInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutSharepointInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutSharepointInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutSharepointInput, ProjetoUncheckedCreateWithoutSharepointInput>
  }

  export type ProjetoUpsertWithoutSharepointInput = {
    update: XOR<ProjetoUpdateWithoutSharepointInput, ProjetoUncheckedUpdateWithoutSharepointInput>
    create: XOR<ProjetoCreateWithoutSharepointInput, ProjetoUncheckedCreateWithoutSharepointInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutSharepointInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutSharepointInput, ProjetoUncheckedUpdateWithoutSharepointInput>
  }

  export type ProjetoUpdateWithoutSharepointInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutSharepointInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutTeamsInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutTeamsInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutTeamsInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutTeamsInput, ProjetoUncheckedCreateWithoutTeamsInput>
  }

  export type ProjetoUpsertWithoutTeamsInput = {
    update: XOR<ProjetoUpdateWithoutTeamsInput, ProjetoUncheckedUpdateWithoutTeamsInput>
    create: XOR<ProjetoCreateWithoutTeamsInput, ProjetoUncheckedCreateWithoutTeamsInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutTeamsInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutTeamsInput, ProjetoUncheckedUpdateWithoutTeamsInput>
  }

  export type ProjetoUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutCronogramaInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutCronogramaInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutCronogramaInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutCronogramaInput, ProjetoUncheckedCreateWithoutCronogramaInput>
  }

  export type ProjetoUpsertWithoutCronogramaInput = {
    update: XOR<ProjetoUpdateWithoutCronogramaInput, ProjetoUncheckedUpdateWithoutCronogramaInput>
    create: XOR<ProjetoCreateWithoutCronogramaInput, ProjetoUncheckedCreateWithoutCronogramaInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutCronogramaInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutCronogramaInput, ProjetoUncheckedUpdateWithoutCronogramaInput>
  }

  export type ProjetoUpdateWithoutCronogramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutCronogramaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutLicenciamentoInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    orientacoes?: OrientacaoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutLicenciamentoInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    orientacoes?: OrientacaoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutLicenciamentoInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutLicenciamentoInput, ProjetoUncheckedCreateWithoutLicenciamentoInput>
  }

  export type ProjetoUpsertWithoutLicenciamentoInput = {
    update: XOR<ProjetoUpdateWithoutLicenciamentoInput, ProjetoUncheckedUpdateWithoutLicenciamentoInput>
    create: XOR<ProjetoCreateWithoutLicenciamentoInput, ProjetoUncheckedCreateWithoutLicenciamentoInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutLicenciamentoInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutLicenciamentoInput, ProjetoUncheckedUpdateWithoutLicenciamentoInput>
  }

  export type ProjetoUpdateWithoutLicenciamentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutLicenciamentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoCreateWithoutOrientacoesInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    cliente: ClientCreateNestedOneWithoutProjetosInput
    levantamento?: LevantamentoCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoUncheckedCreateWithoutOrientacoesInput = {
    id?: string
    nome: string
    clienteId: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
    levantamento?: LevantamentoUncheckedCreateNestedManyWithoutProjetoInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutProjetoInput
    emailConfig?: EmailConfigUncheckedCreateNestedOneWithoutProjetoInput
    sharepoint?: SharePointSiteUncheckedCreateNestedManyWithoutProjetoInput
    teams?: TeamsConfigUncheckedCreateNestedOneWithoutProjetoInput
    cronograma?: CronogramaItemUncheckedCreateNestedManyWithoutProjetoInput
    licenciamento?: LicenciamentoUncheckedCreateNestedOneWithoutProjetoInput
    logs?: LogProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type ProjetoCreateOrConnectWithoutOrientacoesInput = {
    where: ProjetoWhereUniqueInput
    create: XOR<ProjetoCreateWithoutOrientacoesInput, ProjetoUncheckedCreateWithoutOrientacoesInput>
  }

  export type ProjetoUpsertWithoutOrientacoesInput = {
    update: XOR<ProjetoUpdateWithoutOrientacoesInput, ProjetoUncheckedUpdateWithoutOrientacoesInput>
    create: XOR<ProjetoCreateWithoutOrientacoesInput, ProjetoUncheckedCreateWithoutOrientacoesInput>
    where?: ProjetoWhereInput
  }

  export type ProjetoUpdateToOneWithWhereWithoutOrientacoesInput = {
    where?: ProjetoWhereInput
    data: XOR<ProjetoUpdateWithoutOrientacoesInput, ProjetoUncheckedUpdateWithoutOrientacoesInput>
  }

  export type ProjetoUpdateWithoutOrientacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutProjetosNestedInput
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutOrientacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type LevantamentoCreateManyProjetoInput = {
    id?: string
    nome: string
    categoria: string
    criticidade: string
    tempoEstimado: number
    selecionado?: boolean
    observacoes?: string | null
  }

  export type UsuarioCreateManyProjetoInput = {
    id?: string
    nome: string
    departamento?: string | null
    cargo?: string | null
    email: string
    caixaMB?: number | null
    officeLocal?: boolean
    migrarEmail?: boolean
    oneDrive?: boolean
    sharePoint?: boolean
    teams?: boolean
    criadoEm?: Date | string
  }

  export type SharePointSiteCreateManyProjetoInput = {
    id?: string
    nome: string
    tipo: string
    proposito?: string | null
    proprietarios?: string | null
    membros?: string | null
    nivelAcesso?: string | null
    volumeGB?: number | null
    pastaOrigem?: string | null
  }

  export type CronogramaItemCreateManyProjetoInput = {
    id?: string
    nome: string
    responsavel?: string | null
    inicio?: Date | string | null
    fim?: Date | string | null
    status?: string
    ordem?: number | null
  }

  export type LogProjetoCreateManyProjetoInput = {
    id?: string
    mensagem: string
    criadoEm?: Date | string
  }

  export type LevantamentoUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LevantamentoUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LevantamentoUncheckedUpdateManyWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: StringFieldUpdateOperationsInput | string
    criticidade?: StringFieldUpdateOperationsInput | string
    tempoEstimado?: IntFieldUpdateOperationsInput | number
    selecionado?: BoolFieldUpdateOperationsInput | boolean
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    departamento?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    caixaMB?: NullableIntFieldUpdateOperationsInput | number | null
    officeLocal?: BoolFieldUpdateOperationsInput | boolean
    migrarEmail?: BoolFieldUpdateOperationsInput | boolean
    oneDrive?: BoolFieldUpdateOperationsInput | boolean
    sharePoint?: BoolFieldUpdateOperationsInput | boolean
    teams?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharePointSiteUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharePointSiteUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SharePointSiteUncheckedUpdateManyWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    proposito?: NullableStringFieldUpdateOperationsInput | string | null
    proprietarios?: NullableStringFieldUpdateOperationsInput | string | null
    membros?: NullableStringFieldUpdateOperationsInput | string | null
    nivelAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    volumeGB?: NullableFloatFieldUpdateOperationsInput | number | null
    pastaOrigem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CronogramaItemUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CronogramaItemUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CronogramaItemUncheckedUpdateManyWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    responsavel?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordem?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LogProjetoUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogProjetoUncheckedUpdateWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogProjetoUncheckedUpdateManyWithoutProjetoInput = {
    id?: StringFieldUpdateOperationsInput | string
    mensagem?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogCreateManyAnalistaInput = {
    id?: string
    deploymentId: string
    descricao: string
    criadoEm?: Date | string
  }

  export type DecisionLogUpdateWithoutAnalistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeploymentUpdateOneRequiredWithoutDecisionsNestedInput
  }

  export type DecisionLogUncheckedUpdateWithoutAnalistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogUncheckedUpdateManyWithoutAnalistaInput = {
    id?: StringFieldUpdateOperationsInput | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjetoCreateManyClienteInput = {
    id?: string
    nome: string
    descricao?: string | null
    status?: string
    progresso?: number
    dataCriacao?: Date | string
    dataAtualizacao?: Date | string
  }

  export type DeploymentCreateManyClientInput = {
    id?: string
    modelSelected: string
    licensing: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjetoUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
    levantamento?: LevantamentoUncheckedUpdateManyWithoutProjetoNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    emailConfig?: EmailConfigUncheckedUpdateOneWithoutProjetoNestedInput
    sharepoint?: SharePointSiteUncheckedUpdateManyWithoutProjetoNestedInput
    teams?: TeamsConfigUncheckedUpdateOneWithoutProjetoNestedInput
    cronograma?: CronogramaItemUncheckedUpdateManyWithoutProjetoNestedInput
    licenciamento?: LicenciamentoUncheckedUpdateOneWithoutProjetoNestedInput
    orientacoes?: OrientacaoUncheckedUpdateOneWithoutProjetoNestedInput
    logs?: LogProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type ProjetoUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    progresso?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataAtualizacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decisions?: DecisionLogUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decisions?: DecisionLogUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelSelected?: StringFieldUpdateOperationsInput | string
    licensing?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogCreateManyDeploymentInput = {
    id?: string
    analistaId: string
    descricao: string
    criadoEm?: Date | string
  }

  export type DecisionLogUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    analista?: AnalystUpdateOneRequiredWithoutLogsNestedInput
  }

  export type DecisionLogUncheckedUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    analistaId?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionLogUncheckedUpdateManyWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    analistaId?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProjetoCountOutputTypeDefaultArgs instead
     */
    export type ProjetoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjetoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalystCountOutputTypeDefaultArgs instead
     */
    export type AnalystCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalystCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentCountOutputTypeDefaultArgs instead
     */
    export type DeploymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjetoDefaultArgs instead
     */
    export type ProjetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalystDefaultArgs instead
     */
    export type AnalystArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalystDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DecisionLogDefaultArgs instead
     */
    export type DecisionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DecisionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogProjetoDefaultArgs instead
     */
    export type LogProjetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogProjetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentDefaultArgs instead
     */
    export type DeploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LevantamentoDefaultArgs instead
     */
    export type LevantamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LevantamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailConfigDefaultArgs instead
     */
    export type EmailConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SharePointSiteDefaultArgs instead
     */
    export type SharePointSiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SharePointSiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamsConfigDefaultArgs instead
     */
    export type TeamsConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamsConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CronogramaItemDefaultArgs instead
     */
    export type CronogramaItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CronogramaItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LicenciamentoDefaultArgs instead
     */
    export type LicenciamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LicenciamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrientacaoDefaultArgs instead
     */
    export type OrientacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrientacaoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}